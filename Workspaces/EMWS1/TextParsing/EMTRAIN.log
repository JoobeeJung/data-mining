MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 10월 14일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "00시37분17초" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 분석 로그";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* 분석 로그
날짜:                2018년 10월 14일
시간:                00시37분17초
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O2FLA61Q "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O2FLA61Q new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 10월 14일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "00시37분17초" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "사용자:                Administrator";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "사이트:                10503192";
MPRINT(EM_DIAGRAM):   put "플랫폼:            X64_10HOME";
MPRINT(EM_DIAGRAM):   put "관리 릴리스: 9.04.01M4P110916";
MPRINT(EM_DIAGRAM):   put "EM 버전:          14.2";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 10월 14일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "00시37분17초" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "사용자:                Administrator";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 분석 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 스코어 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 리포트 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
22409      proc freq data=EMWS1.TextParsing_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS1.TextParsing_VariableSet noprint;
22410      table ROLE*LEVEL/out=WORK.TextParsingMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.TextParsingMETA;
22411      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: 1개의 관측값을 데이터셋 EMWS1.TEXTPARSING_VARIABLESET.에서 읽었습니다.
NOTE: 데이터셋 WORK.TEXTPARSINGMETA은(는) 1개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 FREQ 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.12 초
      

22412      proc print data=WORK.TextParsingMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.TextParsingMETA label noobs;
22413      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
22414      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "역할" LEVEL = "측도 레벨" COUNT = "빈도 개수";
22415      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
22416      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "변수 요약";
MPRINT(EM_DIAGRAM):   run;
22417      run;

NOTE: 1개의 관측값을 데이터셋 WORK.TEXTPARSINGMETA.에서 읽었습니다.
NOTE: 출력 결과 (프로시저: PRINT, 페이지: 1)
NOTE: 프로시저 PRINT 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.06 초
      

22418      title10;
MPRINT(EM_DIAGRAM):   title10;
22419      %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextParsing: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextParsing: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'DataMining2018';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'Week_Final';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   set EMWS1.Ids_EMINFO;
MPRINT(EM_DIAGRAM):   where key in('HPDMSAMPLE', 'IDSTABLE');
MPRINT(EM_DIAGRAM):   if key = 'HPDMSAMPLE' then call symput('_ForceGrid', '1');
MPRINT(EM_DIAGRAM):   else call symput('_IDS_TABLE', DATA);
MPRINT(EM_DIAGRAM):   run;
MPRINT(HPDM_PERFORMANCE):  ;
PERFORMANCE  DETAILS
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
22766      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
22767      * TextParsing: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * TextParsing: Generation of macros and macro variables;
22768      * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
22769      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

22770      %let EMEXCEPTIONSTRING=;
22771      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
22772      * TRAIN: TextParsing;
MPRINT(EM_DIAGRAM):   * TRAIN: TextParsing;
22773      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
22774      %let EM_ACTION = TRAIN;
22775      %let syscc = 0;
22776      %macro main();
22777        %if %upcase(&EM_ACTION) eq CREATE %then %do;
22778          filename temp catalog 'sashelp.emtxtext.parse_create.source';
22779          %include temp;
22780          %create();
22781        %end;
22782        %if %upcase(&EM_ACTION) eq TRAIN %then %do;
22783          filename temp catalog 'sashelp.emtxtext.parse_train.source';
22784          %include temp;
22785          %train();
22786        %end;
22787        %if %upcase(&EM_ACTION) eq REPORT %then %do;
22788          filename temp catalog 'sashelp.emtxtext.parse_report.source';
22789          %include temp;
22790          %report();
22791        %end;
22792        %if %upcase(&EM_ACTION) eq SCORE %then %do;
22793          filename temp catalog 'sashelp.emtxtext.parse_score.source';
22794          %include temp;
22795          %score();
22796        %end;
22797          %if %upcase(&EM_ACTION) eq OPENTABLE1 %then %do;
22798             filename temp catalog 'sashelp.emtxtext.parse_actions.source';
22799             %include temp;
22800             filename temp;
22801             %openTable1;
22802         %end;
22803      %mend main;
22804      
22805      %main();
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emtxtext.parse_train.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.PARSE_TRAIN.SOURCE입니다.
22806     +%macro train();
22807     +   %global EM_SASMSG;
22808     +   %global sysdocparse;
22809     +   %global syshptmine;
22810     +   %global default_entity;
22811     +   %let EM_SASMSG=TMINE;
22812     +   %let sysdocparse = ;
22813     +   %let syshptmine = ;
22814     +   %let last_parse_node= ;
22816     +   /* Make sure there are no prior text parsing nodes in diagram */
22817     +   %if %sysfunc(exist(&EM_IMPORT_DATA_EMINFO)) %then %do;
22818     +      proc sql noprint;
22819     +      select data into :last_parse_node from &EM_IMPORT_DATA_EMINFO
22820     +         where key="LastTextParsing";
22821     +      quit;
22822     +      %if &last_parse_node ne %then %do;
22823     +         %let EMEXCEPTIONSTRING = EMTOOL.PRIORPARSINGNODE;
22824     +         %goto end_parse_train;
22825     +         %end;
22827     +      %end;
22830     +   /* make sure datasets are inited*/
22831     +    filename temp catalog 'sashelp.emtxtext.parse_actions.source';
22832     +    %include temp;
22833     +    %openTable1();
22835     +   /* check language setinit at runtime */
22836     +   filename temp catalog "sashelp.emtxtext.getlanguages.source";
22837     +   %include temp;
22838     +   %let found_language = ;
22839     +   proc sql noprint;
22840     +      select language into :found_language
22841     +      from work.tm_languages
22842     +      where upcase("&EM_PROPERTY_LANGUAGE") eq upcase(language);
22843     +   quit;
22844     +   %if &found_language eq %then %do;
22845     +      * error if language setinit expired ;
22846     +      /* %let EMEXCEPTIONSTRING = EMTOOL.NOTMLICENSE; */
22847     +      %let EMEXCEPTIONSTRING = EMTOOL.NOLANGLICENSE, %upcase(&EM_PROPERTY_LANGUAGE);
22848     +      %goto end_parse_train;
22849     +   %end;
22851     +   /* There must be a training or raw data set passed in */
22852     +    %if &em_import_data= %then %do;
22853     +      %let EMEXCEPTIONSTRING = EMTOOL.NOTRAINDS;
22854     +      %goto end_parse_train;
22855     +   %end;
22858     +   /* load tgparse macro */
22859     +   filename temp catalog "sashelp.emtxtext.tm_parse.source";
22860     +   %include temp;
22862     +   /* load multiword write to xml macro */
22863     +   filename temp catalog "sashelp.emtxtext.tmwritemulti.source";
22864     +   %include temp;
22866     +   /* retrieve the output datasets so we can write to them */
22867     +   %em_getname(key=terms, type=data);
22868     +   %em_getname(key=tmout, type=data);
22869     +   %em_getname(key=tmoutpos, type=data);
22870     +   %em_getname(key=tmconfig, type=data);
22871     +   %em_getname(key=synonymDS, type=data);
22872     +   %em_getname(key=multiDS, type=data);
22873     +   %em_getname(key=stopList, type=data);
22874     +   %em_getname(key=startList, type=data);
22876     +   %em_getname(key=multiword, type=file, extension=txt);
22878     +   /* variables for choosing the parsing column */
22879     +   %let tm_parsevar = ;
22880     +   %let tm_urivar = ;
22881     +   %let tm_filteredvar = ;
22882     +   %let tm_displayVar = ;
22884     +   /* crawl through the metadata to set some property defaults */
22885     +   data _null_;
22886     +      length parsevar urivar filteredvar $32;
22887     +      retain max_len 0;
22888     +      retain parsevar '';
22889     +      retain urivar '';
22890     +      retain filteredvar '';
22892     +      set &em_data_variableset end=eof;
22894     +      if upcase(ROLE)='TEXT' and USE in ('Y', 'D') and length > max_len then do;
22895     +         parsevar = name;
22896     +         max_len = length;
22897     +      end;
22898     +      if upcase(ROLE)='TEXTLOC' and USE in ('D', 'Y') then filteredvar = name;
22899     +      if ROLE='URIVAR' and USE in ('D', 'Y') then urivar = name;
22901     +      if eof then do;
22902     +         call symput('tm_parsevar', parsevar);
22903     +         call symput('tm_urivar', urivar);
22904     +         call symput('tm_filteredvar', filteredvar);
22905     +      end;
22906     +   run;
22909     +   %if %trim(%left(&tm_filteredvar)) ne %then %do;
22910     +      %let tm_displayVar = &tm_parseVar;
22911     +      %let tm_parsevar = &tm_filteredvar;
22912     +   %end;
22914     +   %em_propertychange(NAME=parseVar, VALUE=&tm_parsevar);
22916     +   %if %trim(%left(&tm_parsevar)) eq %then %do;
22917     +      /* error if no parsevar is found */
22918     +      %let EMEXCEPTIONSTRING = EMTOOL.NOPARSEVAR;
22919     +      %goto end_parse_train;
22920     +   %end;
22921     +   %else %do;
22922     +      /* identify which variable we are parsing */
22923     +      %put &em_codebar;
22924     +      %let errormsg = %sysfunc(sasmsg(sashelp.tmine, EMTOOL.PARSEVAR_NOTE, NOQUOTE, &tm_parsevar));
22925     +      %put &errormsg;
22926     +      %put &em_codebar;
22927     +   %end;
22929     +   /* *** synonym data set changes *** */
22930     +   /* modify the synonymDS to a format that docparse can take (term, termrole, parent, parentrole) */
22931     +   %let category_exists = 0;
22932     +   %let termrole_exists = 0;
22933     +   %let parentrole_exists = 0;
22934     +   %let synonym_warning = ;
22935     +   data _null_;
22936     +      dsid=open("&EM_USER_SYNONYMDS");
22937     +      check=varnum(dsid,'category');
22938     +      if check ne 0 then call symput('category_exists', '1');
22939     +      check=varnum(dsid,'termrole');
22940     +      if check ne 0 then call symput('termrole_exists', '1');
22941     +      check=varnum(dsid,'parentrole');
22942     +      if check ne 0 then call symput('parentrole_exists', '1');
22943     +   run;
22945     +   proc sql noprint;
22946     +      create table work.internal_synds as
22947     +         select term, parent,
22948     +            %if &termrole_exists ne 0 and &parentrole_exists ne 0 %then %do;
22949     +            /* termrole exists and parentrole exists, so just use them */
22950     +               termrole, parentrole
22951     +            %end;
22952     +            %else %if &termrole_exists ne 0 and &parentrole_exists eq 0 %then %do;
22953     +            /* no parentrole or category, so create a termrole as parentrole */
22954     +               %let synonym_warning = 1 ;
22955     +               termrole,
22956     +               termrole as parentrole
22957     +            %end;
22958     +            %else %if &termrole_exists eq 0 and &parentrole_exists ne 0 %then %do;
22959     +            /* no termrole or category, so create a parentrole as termrole*/
22960     +               %let synonym_warning = 1 ;
22961     +               parentrole as termrole,
22962     +               parentrole
22963     +            %end;
22964     +            %else %if &termrole_exists eq 0 and &parentrole_exists eq 0 and &category_exists eq 0 %then %do;
22965     +             /* no termrole, parentrole, and category, so create a blank termrole and a blank parentrole*/
22966     +               "" as termrole,
22967     +               "" as parentrole
22968     +            %end;
22969     +            %else %if &category_exists ne 0 %then %do;
22970     +            /* we're missing both termrole or parentrole, but we have category, so just use that for termrole and parentrole */
22971     +               category as termrole,
22972     +               category as parentrole
22973     +            %end;
22974     +         from &EM_USER_SYNONYMDS;
22975     +   quit;
22977     +   /* reset parentrole_exists and termrole_exists */
22978     +   %let parentrole_exists = 1;
22979     +   %let termrole_exists = 1;
22982     +    %let entities='PERSON', 'DATE', 'COMPANY', 'PERCENT', 'PROP_MISC', 'TITLE',
22983     +                 'TIME', 'PHONE', 'INTERNET', 'ORGANIZATION', 'CURRENCY', 'ADDRESS',
22984     +                 'NOUN_GROUP', 'MEASURE', 'LOCATION', 'SSN', 'TIME_PERIOD';
22986     +    data work.internal_synds;
22987     +        set work.internal_synds;
22988     +        %if &termrole_exists %then %do;
22989     +            if KUPCASE(termrole) in (&entities ) then
22990     +                termrole=KUPCASE(termrole);
22991     +        %end;
22992     +        %if &parentrole_exists %then %do;
22993     +            if KUPCASE(parentrole) in (&entities) then
22994     +                parentrole=KUPCASE(parentrole);
22995     +        %end;
22996     +    run;
22998     +   %let EM_USER_SYNONYMDS = work.internal_synds;
22999     +   %if &synonym_warning ne %then %do;
23000     +      %put &em_codebar;
23001     +      %let errormsg = %sysfunc(sasmsg(sashelp.tmine, EMTOOL.SYN_CHANGE_WARN, NOQUOTE));
23002     +      %put &errormsg;
23003     +      %put &em_codebar;
23004     +   %end;
23006     +   /* Remove duplicate keys from input tables */
23007     +    proc sort data=work.internal_synds nodupkey;
23008     +        by term parent %if &termrole_exists ne 0 and &parentrole_exists ne 0 %then termrole parentrole;
23009     +        %else category; ;
23010     +    run;
23012     +   proc sql noprint;
23013     +       select count(*) into :stoplist_count
23014     +       from &em_user_stoplist;
23015     +       select count(*) into :startlist_count
23016     +       from &em_user_startlist;
23017     +       create view _trainview as select * from &em_import_data;
23018     +    quit;
23020     +    %if &stoplist_count ne 0 %then %do;
23021     +        %let role_exists = 0;
23022     +        data _null_;
23023     +          dsid=open("&em_user_stoplist");
23024     +          check=varnum(dsid,'role');
23025     +          if check ne 0 then call symput('role_exists', '1');
23026     +        run;
23027     +        proc sort data=&em_user_stoplist nodupkey;
23028     +            by term %if &role_exists ne 0 %then role;;
23029     +        run;
23030     +    %end;
23031     +    %else %if &startlist_count ne 0 %then %do;
23032     +        proc sort data=&em_user_startlist nodupkey;
23033     +            by term role;
23034     +        run;
23035     +    %end;
23039     +    /* Filter out unwanted languages */
23040     +    %let filt=;
23041     +    %if %symexist(EM_PROPERTY_FILTERLANG) %then %if &EM_PROPERTY_FILTERLANG ne %then %do;
23042     +        %let filt=%qkupcase(&EM_PROPERTY_FILTERLANG);
23043     +        %let filt=%qsysfunc(KTRANSLATE(%qktrim(&filt),", "," "));
23044     +        %let filt= %superq(filt);
23045     +        %let filt=%qsysfunc(TRANSTRN(&filt, %str(%')%qkupcase(%sysfunc(sasmsg(sashelp.tmine, rpt_text_blank_value, NOQUOTE)))%str(%'), ''));
23046     +        /* need to account for both Chinese languages */
23047     +        %let chineseStr = %qkupcase(%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_chinese_value, NOQUOTE)))', '%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_zho_value, NOQUOTE)))', '%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_zht_value,
23048     + NOQUOTE))));
23049     +        %let filt=%qsysfunc(TRANSTRN(&filt, %qkupcase(%ktrim(%sysfunc(sasmsg(sashelp.tmine, rpt_text_chinese_value, NOQUOTE)))), &chineseStr));
23051     +        filename temp catalog 'sashelp.emtxtext.tm_filter_languages.source';
23052     +        %include temp;
23054     +        %tm_filter_languages(indata=&EM_IMPORT_DATA, outdata=_trainview, languages=%nrbquote(&filt), report_role=TRAIN);
23056     +        proc sql noprint;
23057     +            select count(*) into :doccnt from _trainview;
23058     +        quit;
23060     +        %if &doccnt = 0 %then %do;
23061     +            %let emexceptionstring=EMTOOL.FILTER_DATA_ZERO;
23062     +            %goto end_parse_train;
23063     +        %end;
23064     +    %end;
23066     +    /* prepare training dataset for processing */
23067     +    data &EM_EXPORT_TRAIN.(compress=yes);
23068     +        set _trainview;
23070     +        _document_ = _n_;
23071     +        label _document_="%sysfunc(sasmsg(sashelp.tmine, rpt_text_document_vlabel, NOQUOTE))";
23072     +    run;
23074     +   /* set metadata on &EM_EXPORT_TRAIN to give _document_ a role of id and
23075     +      measurement level of nominal
23076     +    */
23077     +   %em_metachange(name=_document_, role=ID, level=NOMINAL);
23079     +   /* Write the multiword XML out */
23080     +   %tmwritemulti(multids=&EM_USER_MULTIDS,
23081     +                 stopds=&EM_USER_STOPLIST,
23082     +                 startds=&EM_USER_STARTLIST,
23083     +                 synds=&EM_USER_SYNONYMDS,
23084     +                 multi=&EM_USER_MULTIWORD,
23085     +                 multidsout= &EM_LIB..&EM_NODEID._multiall);
23086     +%let default_entity=;
23087     +   /* The main parsing call for the docs */
23088     +   %tm_parse(inds=&EM_EXPORT_TRAIN,
23089     +             outds=&em_user_tmout,
23090     +             keyds=&EM_USER_TERMS,
23091     +             config=&EM_USER_TMCONFIG,
23092     +             multisyn=&EM_USER_MULTIWORD,
23093     +             var=&TM_PARSEVAR,
23094     +             stemming=&EM_PROPERTY_BSTEMS,
23095     +             filevar=&tm_filteredvar,
23096     +             stoplist=&EM_USER_stopList,
23097     +             startlist=&EM_USER_startList,
23098     +             delimit=&EM_PROPERTY_DELIMIT,
23099     +             tagging=&EM_PROPERTY_BPARTOFSPEECH,
23100     +             language=&EM_PROPERTY_LANGUAGE,
23101     +             ng=&EM_PROPERTY_NOUNGROUPS,
23102     +             TGConcepts=%superq(EM_PROPERTY_TGConcepts),
23103     +             TGCategories=&EM_PROPERTY_TGCategories,
23104     +             indexDir=&EM_NODEDIR.&EM_DSEP.,
23105     +             entities=&EM_PROPERTY_BPATTERNS,
23106     +             posignore=&EM_PROPERTY_IGNOREPOS,
23107     +             entignore=&EM_PROPERTY_IGNOREENTITIES,
23108     +             attribignore=&EM_PROPERTY_IGNOREATTRIB,
23109     +             filterds=,
23110     +             filterstatus=,
23111     +             synDS=&EM_USER_SYNONYMDS,
23112     +             outpos=&EM_USER_TMOUTPOS);
23115     +   %if %superq(syshptmine) ne  %then %do;
23116     +      %let EMEXCEPTIONSTRING = EMTOOL.HPTMINE,%superq(syshptmine);
23117     +      %let syscc=0;
23118     +      %goto end_parse_train;
23119     +   %end;
23121     +   %else  %if %superq(sysdocparse) ne  %then %do;
23122     +      %let EMEXCEPTIONSTRING = EMTOOL.DOCPARSE,%superq(sysdocparse);
23123     +      %let syscc=0;
23124     +      %goto end_parse_train;
23125     +   %end;
23128     +    /* add rolestring and attrstring labels for  roles and strings to data set*/
23129     +    proc sql;
23132     +       create table &EM_USER_TERMS as
23133     +         select
23134     +            a.key label= "%sysfunc(sasmsg(sashelp.tmine,rpt_text_key_vlabel,NOQUOTE))",
23135     +            a.term label= "%sysfunc(sasmsg(sashelp.tmine,rpt_text_term_vlabel,NOQUOTE))",
23136     +            a.role,
23137     +            case a.role
23138     +               when 'Abbr'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posabbr_value,   NOQUOTE))"
23139     +               when 'Adj'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posadj_value,   NOQUOTE))"
23140     +               when 'Adv'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posadv_value,   NOQUOTE))"
23141     +               when 'Aux'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posaux_value,   NOQUOTE))"
23142     +               when 'Conj'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posconj_value,   NOQUOTE))"
23143     +               when 'Det'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posdet_value,   NOQUOTE))"
23144     +               when 'Interj'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posinterj_value,   NOQUOTE))"
23145     +               when 'Noun'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnoun_value,   NOQUOTE))"
23146     +               when 'Num'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnum_value,   NOQUOTE))"
23147     +               when 'Part'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospart_value,   NOQUOTE))"
23148     +               when 'Pref'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospref_value,   NOQUOTE))"
23149     +               when 'Prep'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posprep_value,   NOQUOTE))"
23150     +               when 'Pron'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospron_value,   NOQUOTE))"
23151     +               when 'Prop'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posprop_value,   NOQUOTE))"
23152     +               when 'Punct'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospunct_value,   NOQUOTE))"
23153     +               when 'Verb'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posverb_value,   NOQUOTE))"
23154     +               when 'VerbAdj'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posverbadj_value,   NOQUOTE))"
23155     +               when 'PERSON'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posperson_value,   NOQUOTE))"
23156     +               when 'ORGANIZATION'  then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posorganizationerson_value, NOQUOTE))"
23157     +               when 'LOCATION'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poslocation_value, NOQUOTE))"
23158     +               when 'COMPANY'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poscompany_value,  NOQUOTE))"
23159     +               when 'TITLE'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postitle_value,    NOQUOTE))"
23160     +               when 'PHONE'         then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posphone_value,    NOQUOTE))"
23161     +               when 'DATE'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posdate_value,     NOQUOTE))"
23162     +               when 'TIME'          then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postime_value,     NOQUOTE))"
23163     +               when 'INTERNET'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posinternet_value, NOQUOTE))"
23164     +               when 'MEASURE'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posmeasure_value,  NOQUOTE))"
23165     +               when 'NOUN_GROUP'    then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posnoungroup_value,  NOQUOTE))"
23166     +               when 'SSN'           then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posssn_value,        NOQUOTE))"
23167     +               when 'CURRENCY'      then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_poscurrency_value,   NOQUOTE))"
23168     +               when 'PERCENT'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospercent_value,    NOQUOTE))"
23169     +               when 'TIME_PERIOD'   then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_postimeperiod_value, NOQUOTE))"
23170     +               when 'PROP_MISC'     then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_pospropmisc_value,   NOQUOTE))"
23171     +               when 'VEHICLE'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posvehicle_value,    NOQUOTE))"
23172     +               when 'ADDRESS'       then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_posaddress_value,    NOQUOTE))"
23173     +               else              a.role
23174     +          end as rolestring label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_role_vlabel,NOQUOTE))",
23175     +          a.attribute,
23176     +          case a.attribute
23177     +              when 'Alpha'         then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attralpha_value,   NOQUOTE))"
23178     +              when 'Mixed'         then  "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrmixed_value,   NOQUOTE))"
23179     +              when 'Num'           then    "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrnum_value,   NOQUOTE))"
23180     +              when 'Entity'        then "%sysfunc(sasmsg(sashelp.tmine,  rpt_text_attrentity_value,   NOQUOTE))"
23181     +               else             a.ATTRIBUTE
23182     +          end as attrstring label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_attribute_vlabel,NOQUOTE))",
23183     +          /*No weight var at this point*/
23184     +           /*a.weight label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_weight_vlabel,NOQUOTE))" format=5.3,*/
23185     +           a.freq label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_freq_vlabel,NOQUOTE))",
23186     +           a.numdocs label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_numdocs_vlabel,NOQUOTE))",
23187     +           a.keep label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_keep_vlabel,NOQUOTE))",
23188     +           a._ispar label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_isparent_vlabel,NOQUOTE))",
23189     +           a.parent label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_parent_vlabel,NOQUOTE))",
23190     +           a.parent_id label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_parentid_vlabel,NOQUOTE))"
23191     +         from &EM_USER_TERMS  a;
23192     +    quit;
23193     +   data &EM_USER_tmconfig;
23194     +      length multiencoding $24 NG $3
23195     +         %if %superq(EM_PROPERTY_TGConcepts) ne %then %do;
23196     +         litilist $%eval(%klength(%superq(EM_PROPERTY_TGConcepts)) + 2 +
23197     +                       %klength(%superq(default_entity)))
23198     +            %end;
23199     +            ;
23200     +      set &EM_USER_tmconfig;
23202     +            parseVar = lowcase("&tm_parseVar");
23203     +            displayVar = lowcase("&tm_displayVar");
23204     +            indexpath = "&EM_NODEDIR.&EM_DSEP.";
23205     +            multiencoding="utf-8";
23206     +            %if %nrbquote(&filt) ne %then filterLangs="%nrbquote(&filt)"; %else filterLangs="";;
23208     +            /* Need to correct differences between hptmine and tgparse values for tmconfig
23209     +               table [cox] 11/24/2014  These may need to be changed again if we use
23210     +               proc hptmscore for scoring. */
23212     +            if NG="Y" then NG="STD"; else if NG="N" then NG="OFF";
23213     +            if entities="STD" then entities="Y";
23214     +            language=lowcase(language);
23215     +            %if %superq(EM_PROPERTY_TGConcepts) ne
23216     +               and ((&EM_PROPERTY_BPATTERNS eq CUSTOM and %upcase(&EM_PROPERTY_NOUNGROUPS) eq Y)
23217     +                    or &EM_PROPERTY_BPATTERNS eq ALL) %then %do;
23218     +                    litilist="%superq(EM_PROPERTY_TGConcepts)"||';'|| "%superq(default_entity)";
23219     +                    %end;
23220     +            %else %if &EM_PROPERTY_BPATTERNS eq CUSTOM %then %do;
23221     +               entities="Y";
23222     +               litilist="%superq(EM_PROPERTY_TGConcepts)";
23223     +               %end;
23225     +            run;
23228     +   /* Sort our terms data set and create an index for it
23229     +      Sort by term */
23230     +   proc sort data=&em_user_terms;
23231     +      %if %sysfunc(strip(&EM_PROPERTY_IGNOREPOS)) ne %then %do;
23232     +         by term role;
23233     +      %end;
23234     +      %else %do;
23235     +         by term;
23236     +      %end;
23237     +   run;
23239     +   /* Save the dataset information out to EMINFO */
23240     +   data &EM_DATA_EMINFO;
23241     +      length TARGET KEY $32 DATA $43;
23243     +      key="LastTMNode";
23244     +      data="&EM_NODEID";
23245     +      output;
23247     +      key="LastTMNodeType";
23248     +      data="TextParsing";
23249     +      output;
23251     +      key="LastTextParsing";
23252     +      data="&EM_NODEID";
23253     +      output;
23254     +    %if &filt ne %then %do;
23255     +          key="PRESCORECODE";
23256     +          data="&EM_NODEID";
23257     +          output;
23258     +    %end;
23259     +   run;
23263     +%end_parse_train:
23264     +   filename temp;
23265     +   %if ^%symexist(tm_debug) %then %let tm_debug=0;
23266     +   %if &tm_debug =0 %then %do;
23267     +      proc sql noprint;
23268     +         drop table internal_synds;
23269     +         drop table tm_languages;
23270     +         drop view _trainview;
23271     +      quit;
23272     +   %end;
23275     +%mend train;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select data into :last_parse_node from EMWS1.Ids_EMINFO where key="LastTextParsing";
NOTE: No rows were selected.
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.parse_actions.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.PARSE_ACTIONS.SOURCE입니다.
23276     +%macro openTable1();
23277     +/* initiate all possible tables if not already there*/
23279     +   %em_getname(key=synonymDS, type=data);
23280     +   %em_getname(key=multiDS, type=data);
23281     +   %em_getname(key=stopList, type=data);
23282     +   %em_getname(key=startList, type=data);
23284     +   /* set a macro for conditional Syn actions */
23285     +   %global tm_parse_action_syn;
23286     +   %let tm_parse_action_syn=1;
23288     +   %if ^%sysfunc(exist(&em_user_stoplist)) %then %do;
23289     +      proc sql noprint;
23290     +         create table &em_user_stopList
23291     +         (term char(256)
23292     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_term_vlabel, NOQUOTE))",
23293     +          role char(256)
23294     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_role_vlabel, NOQUOTE))"
23295     +             );
23296     +      quit;
23297     +      data &em_user_stoplist;
23298     +         format term $256.;
23299     +         set &em_user_stoplist &em_property_stoplist;
23300     +      run;
23301     +   %end;
23303     +   %if ^%sysfunc(exist(&em_user_synonymds)) %then %do;
23304     +      proc sql noprint;
23305     +         create table &em_user_synonymDS
23306     +         (term char(256)
23307     +label="%sysfunc(sasmsg(sashelp.tmine,  rpt_text_syn_term_vlabel, NOQUOTE))",
23308     +          termrole char(256)
23309     +label="%sysfunc(sasmsg(sashelp.tmine,  rpt_text_syn_termrole_vlabel, NOQUOTE))",
23310     +          parent char(256)
23311     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_syn_parent_vlabel, NOQUOTE))",
23312     +          parentrole char(256)
23313     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_syn_parentrole_vlabel, NOQUOTE))"
23314     +             );
23315     +      quit;
23316     +      data &em_user_synonymds;
23317     +         set &em_user_synonymDS &em_property_synonymds;
23318     +      run;
23319     +   %end;
23321     +   %if ^%sysfunc(exist(&em_user_multids)) %then %do;
23322     +      proc sql noprint;
23323     +         create table &em_user_multiDS
23324     +         (term char(256)
23325     +label="%sysfunc(sasmsg(sashelp.tmine, RPT_TEXT_STOP_TERM_VLABEL, NOQUOTE))",
23326     +          role char(256)
23327     +label="%sysfunc(sasmsg(sashelp.tmine, RPT_TEXT_STOP_ROLE_VLABEL, NOQUOTE))"
23328     +             );
23329     +       quit;
23331     +      data &em_user_multids;
23332     +         set &em_user_multids &em_property_multids;
23333     +      run;
23334     +   %end;
23336     +   %if ^%sysfunc(exist(&em_user_startList)) %then %do;
23337     +     proc sql noprint;
23338     +      create table &EM_USER_startList
23339     +         (term char(256)
23340     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_term_vlabel, NOQUOTE))",
23341     +          role char(256)
23342     +label="%sysfunc(sasmsg(sashelp.tmine, rpt_text_stop_role_vlabel, NOQUOTE))"
23343     +             );
23344     +    quit;
23345     +    data &em_user_startlist;
23346     +         set &em_user_startlist &em_property_startlist;
23347     +      run;
23349     +   %end;
23351     +%mend openTable1;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(OPENTABLE1):  ;
MPRINT(OPENTABLE1):  ;
MPRINT(OPENTABLE1):  ;
MPRINT(OPENTABLE1):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename temp catalog "sashelp.emtxtext.getlanguages.source";
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.GETLANGUAGES.SOURCE입니다.
23353     +data work.raw_tm_languages work.all_languages;
MPRINT(TRAIN):   data work.raw_tm_languages work.all_languages;
23354     +   length language $20;
MPRINT(TRAIN):   length language $20;
23355     +   input language $1-14 displaytext $15-69 prodnum;
MPRINT(TRAIN):   input language $1-14 displaytext $15-69 prodnum;
23356     +
23357     +   output work.all_languages;
MPRINT(TRAIN):   output work.all_languages;
23358     +   if prodnum = 0 or sysprod("PRODNUM"||left(trim(put(prodnum, 8.))))
23359     +        then output work.raw_tm_languages;
MPRINT(TRAIN):   if prodnum = 0 or sysprod("PRODNUM"||left(trim(put(prodnum, 8.)))) then output work.raw_tm_languages;
23360     +   drop prodnum;
MPRINT(TRAIN):   drop prodnum;
23361     +
23362     +   datalines;
MPRINT(TRAIN):   datalines;

NOTE: 데이터셋 WORK.RAW_TM_LANGUAGES은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 데이터셋 WORK.ALL_LANGUAGES은(는) 28개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TRAIN):   ;
MPRINT(TRAIN):   run;
23391     +;
23392     +run;
23393     +
23394     +
23395     +
23396     +
23397     +proc sql noprint;
MPRINT(TRAIN):   proc sql noprint;
23398     +   create table work.tm_languages as
23399     +      select distinct(language), displaytext
23400     +      from work.raw_tm_languages;
MPRINT(TRAIN):   create table work.tm_languages as select distinct(language), displaytext from work.raw_tm_languages;
NOTE: Table WORK.TM_LANGUAGES created, with 2 rows and 2 columns.

23401     +   create table work.all_tm_languages as
23402     +      select distinct(language), displaytext
23403     +      from work.all_languages;
MPRINT(TRAIN):   create table work.all_tm_languages as select distinct(language), displaytext from work.all_languages;
NOTE: Table WORK.ALL_TM_LANGUAGES created, with 27 rows and 2 columns.

23404     +   drop table work.raw_tm_languages;
MPRINT(TRAIN):   drop table work.raw_tm_languages;
NOTE: 테이블 WORK.RAW_TM_LANGUAGES 을(를) 삭제했습니다.
23405     +   drop table work.all_languages;
MPRINT(TRAIN):   drop table work.all_languages;
NOTE: 테이블 WORK.ALL_LANGUAGES 을(를) 삭제했습니다.
23406     +quit;
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.10 초
      

23407     +
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select language into :found_language from work.tm_languages where upcase("Korean") eq upcase(language);
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.00 초
      

MPRINT(TRAIN):   filename temp catalog "sashelp.emtxtext.tm_parse.source";
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_PARSE.SOURCE입니다.
23408     +/* ****************************************************************
23409     + * Name:    tmparse (macro)
23410     + *
23411     + * Support: Jim Cox
23412     + *
23413     + * Usage: %tm_parse(inds=,outds=,keyds=,synds=sashelp.engsynms,keyvar=_document_,
23414     + *                var=,docidvar=, filevar=,config=,
23415     + *                stemming=Y,tagging=Y,ng=Y,entities=NONE,
23416     + *                stoplist=, startlist=, inkey=,doc_id=,
23417     + *                posignore=, entignore=,entkeep=, attribignore=,
23418     + *                reducef=1,termwgt=,cellwgt=,
23419     + *                language=english, multisyn=, nopos=, TGConcepts=,
23420     + *                TGCategories=, indexDir=,out_parent=,
23421     + *                delimit=Formal,outpos=,filterds=,filterstatus=drop);
23422     + * Purpose: To run Text parsing
23423     + *
23424     + * Parms:
23425     + * inds=<dataset> Specifies the input document dataset. This ds has a variable containing
23426     + *      the actual text or a path to the actual text.
23427     + * outds=<dataset> The output OUT table containing variables _TERMNUM_,
23428     + *      _DOCUMENT_,ENTRY. This represents the output term-by- document
23429     + *      frequency matrix.
23430     + * keyds=<dataset> Species the output terms table of terms with their
23431     + *      assoiciated KEY(numeric id) and summary statistics
23432     + * synds=<dataset> An input data set for applying user defined synonyms.
23433     + *      The dataset should contain variables TERM and PARENT and
23434     + *      optionally TERMROLE and PARENTROLE. All occurrences in the text of
23435     + *      matching strings for the term will be assigned the associated parent.
23436     + * keyvar=_document_
23437     + * var=<variable name> Specifies the variable on the inds dataset
23438     + *      that contains the text to be parsed.
23439     + * docidvar=<variable name> This specifies an integer valued variable
23440     + *      that must be on the inds document table. Rather than indexing documents
23441     + *      from 1 to n, this optional setting allow you to control what
23442     + *      id values for documents are used on the OUTds table
23443     + * filevar= Instead of var=, this speicifies the variable on the inds dataset
23444     + *      that contains a path to the plain text documents to be parsed.
23445     + * config=<dataset> An output and an input dataset containing the settings specfied
23446     + *      on this run. If the config exists when specified, the settings
23447     + *      found in the config file will override settings on this macro.
23448     + * stemming=<Y or N> Determines if terms will be stemmed to their root forms.
23449     + * tagging=<Y or N> Determines if the parsed terms will be assigned a
23450     + *      part-of-speech tag.
23451     + * ng=<Y or N> Determines if noun groups will be found as terms.
23452     + * entities=<NONE,DEFAULT, CUSTOM, ALL> Controls if entities are
23453     + *      found during the parse
23454     + *      NONE - do not find entities
23455     + *      DEFAULT - Identify the standard entities
23456     + *      CUSTOM - Use a customizeed file to extract user-specific
23457     + *               entities
23458     + *      ALL - identify the standard entities and extract user-specific entities.
23459     + * stoplist= <dataset> Provide an input list of terms to stop. Variables
23460     + *       are TERM and optionally TERMROLE
23461     + * startlist=<dataset> Provide an input list of terms to keep (all others
23462     + *       will be stopped). Variables are TERM and optionally TERMROLE
23463     + * inkey= <dataset> This option is there to support iterative parsing
23464     + *      It controls the numbering of terms.  The data set inkey comes
23465     + *      from a previous parse and proc tgparse uses the term keys found
23466     + *      there so that identical terms will receive the same key as a previous
23467     + *      parse.
23468     + * doc_id=<nonneg integer>  This also supports iterative parsing and tells
23469     + *      tgparse to start numbering docs at Doc_id rather than with a 1.
23470     + * posignore="POS1" "POS2" .... Allows user to specify a list of part-of-
23471     + *      speech tags. Any terms with these tags will be removed.
23472     + *      For example  posignore="DET" "PREP"
23473     + * entignore="ENT1" "ENT2"... Allows user to specify a list of entity
23474     + *      types. Any terms with these tags will be removed.
23475     + *      For example  entignore="COMPANY" "PRODUCT"
23476     + * entkeep="ENT1" "ENT2" ... Allows user to specify a list of entity
23477     + *      types. Any terms with these tags will be kept and all others
23478     + *       remove. *      For example  entkeep="COMPANY" "PRODUCT"
23479     + * attribignore="ATTRIB1" "ATTRIB2"...Allows user to specify a list of
23480     + *      attributes. Any terms with these attribues will be removed.
23481     + *      For example  posignore="NUM" "PUNCT"
23482     + * reducef=<Positive Integer> Setting lets you specify when to dynamically
23483     + *      stop terms from the analysis. They must appear in at least
23484     + *      reducef documents in order to be kept.
23485     + * termwgt=<NONE, ENTROPY, oR MI> Specify the term weight for each term
23486     + * cellwgt=<NONE or LOG> Specify the cell weight for terms
23487     + * language=<english> Specify the langugage of the text you are parsing
23488     + * multisyn=<filename> Specify the path to a custom multiword term file.
23489     + * nopos=
23490     + * TGConcepts=<filename> Specify the location of custom concept definition
23491     + *       file
23492     + * TGCategories= IGNORED CURRENTLY
23493     + * indexDir= The output location of the search index that can be built with the
23494     + *    input document data.
23495     + * out_parent= An output term-document table that has all children's
23496     + *    (from stemming and synonyms )frequencies
23497     + *    replaced and attributed to their parents. This is the representative form
23498     + *    for the parse collection
23499     + * delimit=Formal IGNORED CURRENTLY
23500     + * outpos=<dataset> An output dataset containing the offset information of
23501     + *    every term in the collection.
23502     + * filterds=<dataset> The name of the dataset of terms used for filtering.
23503     + *        This data set can be used to set terms to keep or drop based
23504     + *        on the filterstatus setting.
23505     + * filterstatus=drop
23506     + * langchk=yes
23507     + *
23508     + * Returns:
23509     + *
23510     + * History:
23511     + * 01Dec05 Initial Coding [cox]
23512     + *
23513     + *
23514     + * Notes:
23515     + * Last Modified By:
23516     + * Last Modified On: Thu Mar 26 13:24:22 2015
23517     + * End
23518     + * ************************************************************** */
23520     +%macro tm_parse(inds=,outds=,keyds=,synds=sashelp.engsynms,docidvar=_document_,
23521     +                 var=, filevar=, config=,
23522     +                 stemming=Y,tagging=Y,ng=Y,entities=NONE,
23523     +                 stoplist=, startlist=, inkey=,doc_id=,reducef=1,termwgt=,cellwgt=,
23524     +                 posignore=, entignore=,entkeep=, attribignore=,
23525     +                 language=english, multisyn=, nopos=, TGConcepts=,
23526     +                 TGCategories=, indexDir=,out_parent=, langchk=yes,
23527     +                 delimit=Formal,outpos=,filterds=,filterstatus=drop);
23529     +%global default_entity;
23530     +%let language=%lowcase(&language);
23531     +%let attribtest=%upcase(&attribignore);
23532     +%let filterstatus=%upcase(&filterstatus);
23533     +%if ^%symexist(tm_hptmineBuildIndex) %then %let tm_hptmineBuildIndex=1;
23534     +%if ^%symexist(tm_hptmineBuildIndex) %then %let tm_hptmineBuildIndex=1;
23535     +%if &tm_hptmineBuildIndex ne 1 %then %let tm_hptmineBuildIndex=0;
23538     +/* Now do tests to determine which proc we will run */
23539     +%if &tm_hptmineBuildIndex=0 and %nrbquote(&indexDir) ne %then %let parse_proc=tgparse;
23541     +/* if asked to select/drop entities or pos also use tgparse
23542     +    [cox] No longer true so removing condition 9/4/2014 */
23543     +/* %else %if &posignore ne or &entignore ne or &entkeep ne
23544     +    %then %let parse_proc=tgparse;
23545     +*/
23547     +/* otherwise, if language not English or German, use tgparse */
23548     +%else %if &language ne english and &language ne german and
23549     +   &language ne chinese and &language ne spanish and
23550     +   &language ne italian and &language ne portuguese and
23551     +   &language ne dutch and &language ne korean and
23552     +   &language ne french and &language ne russian and
23553     +   &language ne finnish and &language ne turkish
23554     +   and &language ne japanese  and &langchk = yes
23555     + %then %let parse_proc=tgparse;
23557     +/* Otherwise, attribignore must contain NUM and PUNCT but not ABBR, ALPHA, or MIXED
23558     +  [cox] No longer true so removing condition 9/4/2014
23559     +  */
23560     +/*
23561     +%else %if %index(&attribtest, NUM) eq 0 or %index(&attribtest, PUNCT) eq 0 or
23562     +   %index(&attribtest, ABBR) ne 0 or %index(&attribtest, ALPHA) ne 0 or
23563     +   %index(&attribtest, MIXED) ne 0 %then %let parse_proc=tgparse;
23564     +*/
23566     +/* finally, must not be updating a previously generated key table */
23568     +%else %if &inkey ne %then %let parse_proc=tgparse;
23569     +   %else %let parse_proc=hptmine;
23571     +   /* delete the tmconfig file so we do not use another tmconfig from a previous node */
23572     +   %if &config ne %then %do;
23573     +      proc sql noprint;
23574     +         drop table &config;
23575     +      quit;
23576     +   %end;
23579     +   /* fix quote problems (replace single quote with double quotes) in posignore=,
23580     +      entignore=, attribignore= .  What about entkeep= (cox)? */
23581     +   data _null_;
23582     +      %if %ktrim(&posignore) ne %then %do;
23583     +         posignore = "&posignore";
23584     +         posignore = transtrn(posignore, "'", '"');
23585     +         call symput("posignore", posignore);
23586     +      %end;
23587     +      %if %ktrim(&entignore) ne %then %do;
23588     +         entignore = "&entignore";
23589     +         entignore = transtrn(entignore, "'", '"');
23590     +         call symput("entignore", entignore);
23591     +      %end;
23592     +      %if %ktrim(&attribignore) ne %then %do;
23593     +         attribignore = "&attribignore";
23594     +         attribignore = transtrn(attribignore, "'", '"');
23595     +         call symput("attribignore", attribignore);
23596     +      %end;
23597     +   run;
23599     +   %let stoplist_count = 0;
23600     +   %let startlist_count = 0;
23601     +   %let synds_count = 0;
23602     +   proc sql noprint;
23603     +      %if "&stoplist" ne "" %then %do;
23604     +         select count(*) into :stoplist_count
23605     +         from &stoplist;
23606     +      %end;
23607     +      %if "&startlist" ne "" %then %do;
23608     +         select count(*) into :startlist_count
23609     +         from &startlist;
23610     +      %end;
23611     +      %if "&synds" ne "" %then %do;
23612     +         select count(*) into :synds_count
23613     +         from &synds;
23614     +      %end;
23615     +   quit;
23617     +   /* control behavior of custom entities */
23618     +   %if &parse_proc eq tgparse %then %let ent_true=yes; %else %let ent_true=std;
23619     +   %if &parse_proc eq tgparse %then %let ent_false=no; %else %let ent_false=none;
23620     +   %let entity_info = ;
23621     +   %if &entities eq NONE %then %do;
23622     +      %let entity_info = entities=&ent_false ;
23623     +      %let entignore = ; %let entkeep=;
23624     +   %end;
23625     +   %else %if &entities eq DEFAULT %then %do;
23626     +      %let entity_info = entities=&ent_true ;
23627     +   %end;
23628     +   /* Otherwise entities are CUSTOM or ALL */
23629     +   %else %do;
23630     +      /* Need to set up default entities if NG on or entities set to ALL */
23631     +      %if &entities eq ALL or %upcase(&ng) eq Y %then %do;
23632     +      %let default_entity = %sysfunc(pathname(SASROOT))&EM_DSEP ;
23634     +      %if "&EM_DSEP" eq "/" %then %do;
23635     +         /* unix */
23636     +         %let default_entity = &default_entity.misc&EM_DSEP.tktg&EM_DSEP. ;
23637     +         %end;
23638     +      %else %if "&EM_DSEP" eq "\" %then %do;
23639     +         /* windows */
23640     +         %let default_entity = &default_entity.tktg&EM_DSEP.sasmisc&EM_DSEP. ;
23641     +         %end;
23642     +      %let entity_language = %lowcase(&language);
23644     +      %if "&entity_language" eq "arabic" %then %do;
23645     +         %let default_entity = &default_entity.ar-ne.li ;
23646     +         %end;
23647     +      %else %if "&entity_language" eq "german" %then %do;
23648     +         %let default_entity = &default_entity.de-ne.li ;
23649     +         %end;
23650     +      %else %if "&entity_language" eq "english" %then %do;
23651     +         %let default_entity = &default_entity.en-ne.li ;
23652     +         %end;
23653     +      %else %if "&entity_language" eq "spanish" %then %do;
23654     +         %let default_entity = &default_entity.es-ne.li ;
23655     +         %end;
23656     +      %else %if "&entity_language" eq "french" %then %do;
23657     +         %let default_entity = &default_entity.fr-ne.li ;
23658     +         %end;
23659     +      %else %if "&entity_language" eq "italian" %then %do;
23660     +         %let default_entity = &default_entity.it-ne.li ;
23661     +         %end;
23662     +      %else %if "&entity_language" eq "japanese" %then %do;
23663     +         %let default_entity = &default_entity.jp-ne.li ;
23664     +         %end;
23665     +      %else %if "&entity_language" eq "korean" %then %do;
23666     +         %let default_entity = &default_entity.kr-ne.li ;
23667     +         %end;
23668     +      %else %if "&entity_language" eq "dutch" %then %do;
23669     +         %let default_entity = &default_entity.nl-ne.li ;
23670     +         %end;
23671     +      %else %if "&entity_language" eq "polish" %then %do;
23672     +         %let default_entity = &default_entity.pl-ne.li ;
23673     +         %end;
23674     +      %else %if "&entity_language" eq "portuguese" %then %do;
23675     +         %let default_entity = &default_entity.pt-ne.li ;
23676     +         %end;
23677     +      %else %if "&entity_language" eq "chinese" %then %do;
23678     +         %let default_entity = &default_entity.zh-ne.li ;
23679     +         %end;
23680     +      %else %if "&entity_language" eq "russian" %then %do;
23681     +         %let default_entity = &default_entity.ru-ne.li ;
23682     +         %end;
23683     +      %else %if "&entity_language" eq "turkish" %then %do;
23684     +         %let default_entity = &default_entity.tr-ne.li ;
23685     +         %end;
23686     +      %else %if "&entity_language" eq "thai" %then %do;
23687     +         %let default_entity = &default_entity.th-ne.li ;
23688     +         %end;
23689     +      %else %if "&entity_language" eq "vietnamese" %then %do;
23690     +         %let default_entity = &default_entity.vi-ne.li ;
23691     +         %end;
23692     +      %else %if "&entity_language" eq "norwegian" %then %do;
23693     +         %let default_entity = &default_entity.no-ne.li ;
23694     +         %end;
23695     +      %else %if "&entity_language" eq "danish" %then %do;
23696     +         %let default_entity = &default_entity.da-ne.li ;
23697     +         %end;
23698     +      %else %if "&entity_language" eq "greek" %then %do;
23699     +         %let default_entity = &default_entity.el-ne.li ;
23700     +         %end;
23701     +      %else %if "&entity_language" eq "romanian" %then %do;
23702     +         %let default_entity = &default_entity.ro-ne.li ;
23703     +         %end;
23704     +      %else %if "&entity_language" eq "hebrew" %then %do;
23705     +         %let default_entity = &default_entity.he-ne.li ;
23706     +         %end;
23707     +      %else %if "&entity_language" eq "czech" %then %do;
23708     +         %let default_entity = &default_entity.cs-ne.li ;
23709     +         %end;
23710     +      %else %if "&entity_language" eq "slovak" %then %do;
23711     +         %let default_entity = &default_entity.sk-ne.li ;
23712     +         %end;
23713     +      %else %if "&entity_language" eq "hungarian" %then %do;
23714     +         %let default_entity = &default_entity.hu-ne.li ;
23715     +         %end;
23716     +      %else %if "&entity_language" eq "indonesian" %then %do;
23717     +         %let default_entity = &default_entity.id-ne.li ;
23718     +         %end;
23719     +      %else %if "&entity_language" eq "finnish" %then %do;
23720     +         %let default_entity = &default_entity.fi-ne.li ;
23721     +         %end;
23722     +      %else %let default_entity=&ent_false;
23724     +         %end;
23726     +   %if &entities eq CUSTOM %then %do;
23727     +      %if %superq(TGConcepts) ne %then %do;
23728     +         %if &parse_proc eq tgparse %then %let ent_flag=&ent_true;
23729     +         %else %let ent_flag=&ent_false;
23730     +         %let entity_info = entities=&ent_flag litilist=("&TGConcepts") ;
23731     +      %end;
23732     +      %else %do;
23733     +         %let entity_info = entities=&ent_false ;
23734     +      %end;
23736     +      /* %let entignore = ; */
23737     +      %end;
23738     +   %else %if &entities eq ALL %then %do;
23740     +      %if %nrbquote(&TGConcepts) ne %then %do;
23741     +         %if &parse_proc eq tgparse %then
23742     +            %let entity_info= entities=&ent_true litilist=("&default_entity" "&TGConcepts") ;
23743     +         %else %let entity_info= entities=&ent_true litilist=("&TGConcepts") ;
23744     +         %end;
23745     +      %else %let entity_info= entities=&ent_true;
23748     +      %end;
23750     +%end;
23752     +   /* main docparse call */
23753     +%if &parse_proc eq tgparse %then %do;
23754     +      proc tgparse data=&inds key=&keyds out=&outds
23755     +         %if &filterds ne %then %do;
23756     +            %if %upcase(&filterstatus) eq DROP %then stop=&filterds;
23757     +            %else %if %upcase(&filterstatus) eq KEEP %then start=&filterds;
23758     +            %else %if %upcase(&filterstatus) eq IGNORE %then ignore=&filterds;
23759     +            %else %if %upcase(&filterstatus) eq RETAIN %then retain=&filterds;
23760     +            %end;
23761     +         %if &config ne %then config=&config;
23762     +         %if &nopos ne %then NOPOS;
23763     +         %if &synds_count ne 0 %then syn=&synds;
23764     +         %if "&multisyn" ne "" %then multiterm="&multisyn";
23765     +         %if %upcase(&stemming) eq Y %then stemming=yes ; %else stemming=no ;
23766     +         %if %upcase(&tagging) eq Y %then tagging=yes ; %else tagging=no ;
23767     +         &entity_info
23768     +         /* %if "%trim(%left(&TGCategories))" ne "" %then TGCategories=&TGCategories ; */
23769     +         %if "%nrbquote(&indexDir)" ne "" %then %do;
23770     +            buildindex=yes
23771     +            indexpath="%nrbquote(&indexDir)"
23772     +         %end;
23773     +         %if &stoplist_count ne 0  %then stop=&stoplist;
23774     +         %else %if &startlist_count ne 0  %then start=&startlist;
23775     +         %if %upcase(&ng) eq Y %then ng=std ;
23776     +         %else ng=off ;
23777     +         %if &filevar ne %then namedfile;
23778     +         %if %lowcase(&language) ne other %then language=%lowcase(&language);
23779     +         %else plugin="SAS";
23780     +         %if &outpos ne %then %do; outoffset=&outpos addsentence addparagraph %end;
23781     +         %if &inkey ne %then  inkey=&inkey;
23782     +         %if &doc_id ne %then doc_id=&doc_id;
23784     +         ;
23785     +      var %if &filevar ne %then &filevar; %else &var; ;
23786     +      %if %upcase(&docidvar) ne _DOCUMENT_ %then id &docidvar;;
23788     +      select &posignore "Newline" / drop;
23789     +      %if &attribignore ne %then select &attribignore / group="attributes" drop; ;
23790     +      %if &entkeep ne and &entignore =  %then %do;
23791     +          select &entkeep / group="entities" keep;
23792     +      %end;
23793     +      %else %do;
23794     +          %if &entignore ne %then select &entignore / group="entities" drop; ;
23795     +      %end;
23796     +      run;
23797     +%end;
23799     +%else %do;
23801     +proc hptmine data=&inds language=&language;
23802     +    var %if &filevar ne %then &filevar; %else &var; ;
23803     +   doc_id &docidvar;
23804     +   parse reducef=&reducef outterms=&keyds
23805     +      %if &filevar ne %then namedfile;
23807     +      %if &filterds ne %then %do;
23808     +          %if %upcase(&filterstatus) eq DROP or %upcase(&filterstatus) eq IGNORE
23809     +             %then stop=&filterds;
23810     +          %else %if %upcase(&filterstatus) eq KEEP or %upcase(&filterstatus) eq RETAIN
23811     +             %then start=&filterds;
23812     +          %if %upcase(&filterstatus) ne IGNORE and %upcase(&filterstatus) ne RETAIN
23813     +             %then showdroppedterms;
23814     +      %end;
23815     +      %else showdroppedterms;
23817     +      %if &termwgt ne %then termwgt=&termwgt;
23818     +      %if &cellwgt ne %then cellwgt=&cellwgt;
23819     +      %if %upcase(&stemming) ne Y %then nostemming;
23820     +      %if %upcase(&tagging) ne Y %then notagging;
23821     +      %if %upcase(&ng) ne Y %then nonoungroups;
23822     +   %if &stoplist_count ne 0  %then stop=&stoplist;
23823     +   %else %if &startlist_count ne 0  %then start=&startlist;
23824     +%if 0 %then %do;
23825     +%end;
23826     +      %if &synds_count ne 0 %then syn=&synds;
23827     +         &entity_info
23828     +      %if "&multisyn" ne "" %then multiterm="&multisyn";
23829     +      %if "%nrbquote(&indexDir)" ne "" %then %do;
23830     +            buildindex
23831     +            indexpath="%nrbquote(&indexDir)"
23832     +      %end;
23834     +      %if &outds ne %then outchild=&outds;
23835     +      %if &outpos ne %then outpos=&outpos;
23836     +      %if &config ne %then outconfig=&config;
23837     +      %if &out_parent ne %then outparent=&out_parent;
23839     +   ;
23840     +     %if &posignore ne %then select &posignore "Newline" / ignore; ;
23841     +        %if &attribignore eq %then %let attribignore="";
23842     +      select &attribignore / group="attributes" ignore;
23843     +      %if &entkeep ne and &entignore =  %then %do;
23844     +         select &entkeep / group="entities" keep; ;
23845     +      %end;
23846     +      %else %do;
23847     +          %if &entignore ne %then select &entignore / group="entities" ignore; ;
23848     +      %end;
23849     +      performance /* nthreads=1 */ details;
23850     +   run;
23851     +%if %symexist(syshptmine) %then %let sysdocparse=&syshptmine;
23852     +%else %let sysdocparse=;
23854     +/* Change term and outpos tables so that they correspond to tgparse variable names */
23857     +/* Change term and outpos tables so that they correspond to tgparse variable names */
23858     +proc sql noprint;
23859     +   create table &keyds as select *,_keep as keep from &keyds
23860     +      order by _keep desc,numdocs desc;
23861     +  %if &outpos ne %then %do;
23862     +     create table tempKey as select
23863     +        a.key as _termnum_,
23864     +        a.term,
23865     +        a.role
23866     +        from &keyds a
23867     +        where a._ispar ne '+';
23869     +     create table tempoutpos as select
23870     +        a.document as _document_,
23871     +        a.sentence as _sentence_,
23872     +        a._start_ as _offset_,
23873     +        a._end_ - a._start_+1 as _length_,
23874     +        b._termnum_
23875     +        from &outpos as a , tempKey as b
23876     +        where b.term=a.term and b.role=a.role;
23878     +     create table tempoutds as select
23879     +        a.*
23880     +        from &outds as a, tempkey as b
23881     +        where a._termnum_= b._termnum_;
23883     +      create table &outpos as select
23884     +        a._document_,
23885     +        a._sentence_,
23886     +        a._offset_,
23887     +        a. _length_,
23888     +        a._termnum_,
23889     +        b._count_
23890     +        from tempoutpos as a, tempoutds as b
23891     +        where a._termnum_=b._termnum_ and a._document_ =b._document_;
23893     +       drop table tempoutpos;
23894     +       drop table tempKey;
23895     +     %end;
23896     +     /* improve tmutil performance*/
23897     +     proc sort data=&outds;
23898     +       by _termnum_ _document_;
23899     +     run;
23900     +  quit;
23902     +%end;
23904     +%end_tmparse:
23906     +%mend;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   filename temp catalog "sashelp.emtxtext.tmwritemulti.source";
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TMWRITEMULTI.SOURCE입니다.
23907     +/* ****************************************************************
23908     + * Name:    tmwritemulti.sas (macro)
23909     + *
23910     + *
23911     + * Usage: %tmwritemulti(multids=, stopds=, startds=, synds=, multi=);
23912     + * Purpose: To write out the text file for the multiword dictionary.  This will
23913     + *  include multiword term in the data= file as well as
23914     + * Parameters
23915     + * multids   = data set with multiword terms and their roles
23916     + * stopds    = stop word list - look for multiword terms
23917     + * startds   = start word list - look for multiword terms
23918     + * synds     = data set with synonyms and their roles
23919     + * multi     = multiterm text file.
23920     + * End
23921     + * ************************************************************** */
23922     +
23923     +
23924     +%macro tmwritemulti(multids=, stopds=, startds=, synds=, multi=, multidsout=);
23925     +
23926     +   * create a multiword terms data set ;
23927     +   proc sql noprint;
23928     +      create table _multiterms_
23929     +         (term   char(256),
23930     +          role   char(256));
23931     +   quit;
23932     +
23933     +   %let synds_count = ;
23934     +   %let stopds_count = ;
23935     +   %let startds_count = ;
23936     +   %let multids_count = ;
23937     +   proc sql noprint;
23938     +      select count(*) into :synds_count
23939     +      from &synds;
23940     +
23941     +      select count(*) into :stopds_count
23942     +      from &stopds;
23943     +
23944     +      %if &startds ne %then
23945     +      select count(*) into :startds_count
23946     +      from &startds;
23947     +      %else %let startds_count = 0;;
23948     +
23949     +      select count(*) into :multids_count
23950     +      from &multids;
23951     +   quit;
23952     +
23953     +   * check the synonym ds for multiword terms ;
23954     +   %if &synds_count ne 0 %then %do;
23955     +      %find_multiword_terms(data_in=&synds, data_append=_multiterms_);
23956     +   %end;
23957     +
23958     +   * check the stopTerms ds for multiword terms ;
23959     +   %if &stopds_count ne 0 %then %do;
23960     +      %find_multiword_terms(data_in=&stopds, data_append=_multiterms_);
23961     +   %end;
23962     +
23963     +   * check the startTerms ds for multiword terms;
23964     +   %if &startds_count ne 0 %then %do;
23965     +      %find_multiword_terms(data_in=&startds, data_append=_multiterms_);
23966     +   %end;
23967     +
23968     +   * check the multids for multiword terms ;
23969     +   %if &multids_count ne 0 %then %do;
23970     +      data work.multids_temp;
23971     +         length term $256 role $256;
23972     +         set &multids;
23973     +         if role eq '' then role='Noun';
23974     +      run;
23975     +      proc append base=_multiterms_ data=work.multids_temp(keep=term role) force;
23976     +      run;
23977     +      proc sql noprint;
23978     +         drop table work.multids_temp;
23979     +      run;
23980     +   %end;
23981     +
23982     +   * add lower and upper case variations to the multi word terms ;
23983     +
23984     +   data _multiterms_;
23985     +      set _multiterms_;
23986     +      term = transtrn(term, ':', '\:');
23987     +
23988     +      * output exactly as is ;
23989     +      output;
23990     +      * output lower case versions ;
23991     +      term=lowcase(term);
23992     +      output;
23993     +      * output upper case versions ;
23994     +      term=upcase(term);
23995     +      output;
23996     +      * output uppercase first letter of each term, lower rest ;
23997     +      term = propcase(term);
23998     +      output;
23999     +   run;
24000     +
24001     +   * remove duplicate term entries ;
24002     +   proc sort data= _multiterms_ nodupkey;
24003     +      by term role;
24004     +   run;
24005     +
24006     +   filename _multout "&multi";
24007     +
24008     +   * write out all the multiword terms ;
24009     +   data &multidsout;
24010     +      set _multiterms_;
24011     +      file _multout encoding="utf-8";
24012     +      put term ':3:' role;
24013     +   run;
24014     +
24015     +   %if ^%symexist(tm_debug) %then %let tm_debug=0;
24016     +   %if &tm_debug =0 %then %do;
24017     +      proc sql noprint;
24018     +         drop table work._multiterms_;
24019     +      quit;
24020     +   %end;
24021     +
24022     +%mend tmwritemulti;
24023     +
24024     +
24025     +/*
24026     +
24027     +%tmwritemulti(language="english", data=sashelp.engsynms);
24028     +
24029     +*/
24030     +
24031     +%macro find_multiword_terms(data_in=, data_append=);
24032     +
24033     +   data &data_in._temp (keep=term role);
24034     +      length term $ 256 role $ 256 category $ 256 child $ 256 childrole $ 256 parent $ 256 parentrole $ 256;
24035     +
24036     +      set &data_in;
24037     +
24038     +      if lengthn(kcompress(ktrim(term))) < lengthn(ktrim(term)) then do;
24039     +         if childrole ne '' then category = childrole;
24040     +         if role ne '' then category = role;
24041     +
24042     +         if lowcase(category) eq category then category=propcase(category) ;
24043     +
24044     +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
24045     +         else if category eq 'NOUN_GROUP' then role = 'Noun';
24046     +         else if category eq '' then role='Noun';
24047     +         else role = 'Prop';
24048     +
24049     +         output;
24050     +      end;
24051     +
24052     +      if "&data_in"="&synds" and anypunct(term,1) > 0 then do;
24053     +         term = prxchange('s/([\/\\<>,()])/ $1 /', -1, term);
24054     +         if role ne '' then category = role;
24055     +
24056     +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
24057     +         else if category eq 'NOUN_GROUP' then role = 'Noun';
24058     +         else if category eq '' then role='Noun';
24059     +         else role = 'Prop';
24060     +
24061     +         output;
24062     +      end;
24063     +
24064     +      if lengthn(kcompress(ktrim(parent))) < lengthn(ktrim(parent)) and ktrim(parent) ne ktrim(term) then do;
24065     +         term = parent;
24066     +         if parentrole ne '' then category = childrole;
24067     +
24068     +         if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
24069     +         else if category eq 'NOUN_GROUP' then role = 'Noun';
24070     +         else if category eq '' then role='Noun';
24071     +         else role = 'Prop';
24072     +         output;
24073     +      end;
24074     +   run;
24075     +
24076     +   proc append base=&data_append data=&data_in._temp force;
24077     +   run;
24078     +
24079     +   proc sql noprint;
24080     +      drop table &data_in._temp;
24081     +   quit;
24082     +%mend find_multiword_terms;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   length parsevar urivar filteredvar $32;
MPRINT(TRAIN):   retain max_len 0;
MPRINT(TRAIN):   retain parsevar '';
MPRINT(TRAIN):   retain urivar '';
MPRINT(TRAIN):   retain filteredvar '';
MPRINT(TRAIN):   set EMWS1.TextParsing_VariableSet end=eof;
MPRINT(TRAIN):   if upcase(ROLE)='TEXT' and USE in ('Y', 'D') and length > max_len then do;
MPRINT(TRAIN):   parsevar = name;
MPRINT(TRAIN):   max_len = length;
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   if upcase(ROLE)='TEXTLOC' and USE in ('D', 'Y') then filteredvar = name;
MPRINT(TRAIN):   if ROLE='URIVAR' and USE in ('D', 'Y') then urivar = name;
MPRINT(TRAIN):   if eof then do;
MPRINT(TRAIN):   call symput('tm_parsevar', parsevar);
MPRINT(TRAIN):   call symput('tm_urivar', urivar);
MPRINT(TRAIN):   call symput('tm_filteredvar', filteredvar);
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   run;

NOTE: 1개의 관측값을 데이터셋 EMWS1.TEXTPARSING_VARIABLESET.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(EM_PROPERTYCHANGE):   data WORK.EM_USER_PROPERTY;
MPRINT(EM_PROPERTYCHANGE):   length NAME $32 VALUE $400;
MPRINT(EM_PROPERTYCHANGE):   NAME = "parseVar";
MPRINT(EM_PROPERTYCHANGE):   VALUE = "Contents";
MPRINT(EM_PROPERTYCHANGE):   output;
MPRINT(EM_PROPERTYCHANGE):   run;

NOTE: 데이터셋 WORK.EM_USER_PROPERTY은(는) 1개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(EM_PROPERTYCHANGE):   run;
MPRINT(TRAIN):  ;
*------------------------------------------------------------*
NOTE: 파싱에 사용된 변수: Contents
*------------------------------------------------------------*
MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   dsid=open("EMWS1.TextParsing_synonymDS");
MPRINT(TRAIN):   check=varnum(dsid,'category');
MPRINT(TRAIN):   if check ne 0 then call symput('category_exists', '1');
MPRINT(TRAIN):   check=varnum(dsid,'termrole');
MPRINT(TRAIN):   if check ne 0 then call symput('termrole_exists', '1');
MPRINT(TRAIN):   check=varnum(dsid,'parentrole');
MPRINT(TRAIN):   if check ne 0 then call symput('parentrole_exists', '1');
MPRINT(TRAIN):   run;

NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   create table work.internal_synds as select term, parent, termrole, parentrole from EMWS1.TextParsing_synonymDS;
NOTE: Table WORK.INTERNAL_SYNDS created, with 0 rows and 4 columns.

MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TRAIN):   data work.internal_synds;
MPRINT(TRAIN):   set work.internal_synds;
MPRINT(TRAIN):   if KUPCASE(termrole) in ('PERSON', 'DATE', 'COMPANY', 'PERCENT', 'PROP_MISC', 'TITLE', 'TIME', 'PHONE', 'INTERNET', 'ORGANIZATION', 'CURRENCY', 'ADDRESS', 'NOUN_GROUP', 'MEASURE', 'LOCATION', 'SSN', 'TIME_PERIOD' ) then 
termrole=KUPCASE(termrole);
MPRINT(TRAIN):   if KUPCASE(parentrole) in ('PERSON', 'DATE', 'COMPANY', 'PERCENT', 'PROP_MISC', 'TITLE', 'TIME', 'PHONE', 'INTERNET', 'ORGANIZATION', 'CURRENCY', 'ADDRESS', 'NOUN_GROUP', 'MEASURE', 'LOCATION', 'SSN', 'TIME_PERIOD') then 
parentrole=KUPCASE(parentrole);
MPRINT(TRAIN):   run;

NOTE: 0개의 관측값을 데이터셋 WORK.INTERNAL_SYNDS.에서 읽었습니다.
NOTE: 데이터셋 WORK.INTERNAL_SYNDS은(는) 0개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TRAIN):   proc sort data=work.internal_synds nodupkey;
MPRINT(TRAIN):   by term parent termrole parentrole ;
MPRINT(TRAIN):   run;

NOTE: 입력 데이터셋이 비어 있습니다.
NOTE: 중복 키값을 가지고 있는 0개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK.INTERNAL_SYNDS은(는) 0개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select count(*) into :stoplist_count from EMWS1.TextParsing_stopList;
MPRINT(TRAIN):   select count(*) into :startlist_count from EMWS1.TextParsing_startList;
MPRINT(TRAIN):   create view _trainview as select * from EMWS1.Ids_DATA;
NOTE: SQL view WORK._TRAINVIEW has been defined.
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TRAIN):   proc sort data=EMWS1.TextParsing_startList nodupkey;
MPRINT(TRAIN):   by term role;
MPRINT(TRAIN):   run;

NOTE: 입력 데이터셋이 이미 정렬되어 있어서, 정렬을 실행하지 않았습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
      

MPRINT(TRAIN):   data EMWS1.TextParsing_TRAIN(compress=yes);
MPRINT(TRAIN):   set _trainview;
MPRINT(TRAIN):   _document_ = _n_;
MPRINT(TRAIN):   label _document_= "문서";
MPRINT(TRAIN):   run;

NOTE: View EMWS1.IDS_DATA.VIEW 실행(총 프로세스 시간):
      실행 시간           0.21 초
      cpu 시간            0.20 초
      
NOTE: 800개의 관측값을 데이터셋 DM_LIB.NEWS_800.에서 읽었습니다.
NOTE: 800개의 관측값을 데이터셋 EMWS1.IDS_DATA.에서 읽었습니다.
NOTE: 800개의 관측값을 데이터셋 WORK._TRAINVIEW.에서 읽었습니다.
NOTE: 데이터셋 EMWS1.TEXTPARSING_TRAIN은(는) 800개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 데이터셋 'EMWS1.TEXTPARSING_TRAIN'을(를) 압축해서 크기가 65.22%(으)로 줄었습니다. 
      압축된 파일은 8페이지입니다. 압축되지 않은 파일은 23페이지가 필요합니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.29 초
      cpu 시간            0.29 초
      

MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   length KEY $32 DELETE $1 UNAME $32 ROLE $32 LEVEL $10 ORDER $8 COMMENT $64 LOWERLIMIT 8 UPPERLIMIT 8;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("_document_");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("ID");
MPRINT(EM_METACHANGE):   LEVEL = upcase("NOMINAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   run;

NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 1개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TRAIN):  ;
MPRINT(TMWRITEMULTI):   * create a multiword terms data set ;
MPRINT(TMWRITEMULTI):   proc sql noprint;
MPRINT(TMWRITEMULTI):   create table _multiterms_ (term char(256), role char(256));
NOTE: Table WORK._MULTITERMS_ created, with 0 rows and 2 columns.
MPRINT(TMWRITEMULTI):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMWRITEMULTI):   proc sql noprint;
MPRINT(TMWRITEMULTI):   select count(*) into :synds_count from work.internal_synds;
MPRINT(TMWRITEMULTI):   select count(*) into :stopds_count from EMWS1.TextParsing_stopList;
MPRINT(TMWRITEMULTI):   select count(*) into :startds_count from EMWS1.TextParsing_startList;
MPRINT(TMWRITEMULTI):   select count(*) into :multids_count from EMWS1.TextParsing_multiDS;
MPRINT(TMWRITEMULTI):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMWRITEMULTI):   * check the synonym ds for multiword terms ;
MPRINT(TMWRITEMULTI):   * check the stopTerms ds for multiword terms ;
MPRINT(TMWRITEMULTI):   * check the startTerms ds for multiword terms;
MPRINT(FIND_MULTIWORD_TERMS):   data EMWS1.TextParsing_startList_temp (keep=term role);
MPRINT(FIND_MULTIWORD_TERMS):   length term $ 256 role $ 256 category $ 256 child $ 256 childrole $ 256 parent $ 256 parentrole $ 256;
MPRINT(FIND_MULTIWORD_TERMS):   set EMWS1.TextParsing_startList;
MPRINT(FIND_MULTIWORD_TERMS):   if lengthn(kcompress(ktrim(term))) < lengthn(ktrim(term)) then do;
MPRINT(FIND_MULTIWORD_TERMS):   if childrole ne '' then category = childrole;
MPRINT(FIND_MULTIWORD_TERMS):   if role ne '' then category = role;
MPRINT(FIND_MULTIWORD_TERMS):   if lowcase(category) eq category then category=propcase(category) ;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   if "EMWS1.TextParsing_startList"="work.internal_synds" and anypunct(term,1) > 0 then do;
MPRINT(FIND_MULTIWORD_TERMS):   term = prxchange('s/([\/\\<>,()])/ $1 /', -1, term);
MPRINT(FIND_MULTIWORD_TERMS):   if role ne '' then category = role;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   if lengthn(kcompress(ktrim(parent))) < lengthn(ktrim(parent)) and ktrim(parent) ne ktrim(term) then do;
MPRINT(FIND_MULTIWORD_TERMS):   term = parent;
MPRINT(FIND_MULTIWORD_TERMS):   if parentrole ne '' then category = childrole;
MPRINT(FIND_MULTIWORD_TERMS):   if category in ('Adj','Adv','Noun','Prep','Conj','Interj','Pron','Prop', 'Verbadj') then role=category;
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq 'NOUN_GROUP' then role = 'Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else if category eq '' then role='Noun';
MPRINT(FIND_MULTIWORD_TERMS):   else role = 'Prop';
MPRINT(FIND_MULTIWORD_TERMS):   output;
MPRINT(FIND_MULTIWORD_TERMS):   end;
MPRINT(FIND_MULTIWORD_TERMS):   run;

NOTE: 변수 child이(가) 초기화되지 않았습니다.
NOTE: 변수 childrole이(가) 초기화되지 않았습니다.
NOTE: 변수 parent이(가) 초기화되지 않았습니다.
NOTE: 변수 parentrole이(가) 초기화되지 않았습니다.
NOTE: 71개의 관측값을 데이터셋 EMWS1.TEXTPARSING_STARTLIST.에서 읽었습니다.
NOTE: 데이터셋 EMWS1.TEXTPARSING_STARTLIST_TEMP은(는) 0개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(FIND_MULTIWORD_TERMS):   proc append base=_multiterms_ data=EMWS1.TextParsing_startList_temp force;
MPRINT(FIND_MULTIWORD_TERMS):   run;

NOTE: EMWS1.TEXTPARSING_STARTLIST_TEMP 을(를)WORK._MULTITERMS_(으)로 추가하는 중입니다.
NOTE: 0개의 관측값을 데이터셋 EMWS1.TEXTPARSING_STARTLIST_TEMP.에서 읽었습니다.
NOTE: 0개 관측값이 추가되었습니다.
NOTE: 데이터셋 WORK._MULTITERMS_은(는) 0개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 APPEND 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(FIND_MULTIWORD_TERMS):   proc sql noprint;
MPRINT(FIND_MULTIWORD_TERMS):   drop table EMWS1.TextParsing_startList_temp;
NOTE: 테이블 EMWS1.TEXTPARSING_STARTLIST_TEMP 을(를) 삭제했습니다.
MPRINT(FIND_MULTIWORD_TERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TMWRITEMULTI):  ;
MPRINT(TMWRITEMULTI):   * check the multids for multiword terms ;
MPRINT(TMWRITEMULTI):   * add lower and upper case variations to the multi word terms ;
MPRINT(TMWRITEMULTI):   data _multiterms_;
MPRINT(TMWRITEMULTI):   set _multiterms_;
MPRINT(TMWRITEMULTI):   term = transtrn(term, ':', '\:');
MPRINT(TMWRITEMULTI):   * output exactly as is ;
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   * output lower case versions ;
MPRINT(TMWRITEMULTI):   term=lowcase(term);
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   * output upper case versions ;
MPRINT(TMWRITEMULTI):   term=upcase(term);
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   * output uppercase first letter of each term, lower rest ;
MPRINT(TMWRITEMULTI):   term = propcase(term);
MPRINT(TMWRITEMULTI):   output;
MPRINT(TMWRITEMULTI):   run;

NOTE: 0개의 관측값을 데이터셋 WORK._MULTITERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._MULTITERMS_은(는) 0개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMWRITEMULTI):   * remove duplicate term entries ;
MPRINT(TMWRITEMULTI):   proc sort data= _multiterms_ nodupkey;
MPRINT(TMWRITEMULTI):   by term role;
MPRINT(TMWRITEMULTI):   run;

NOTE: 입력 데이터셋이 비어 있습니다.
NOTE: 중복 키값을 가지고 있는 0개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._MULTITERMS_은(는) 0개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMWRITEMULTI):   filename _multout "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\multiword.txt";
MPRINT(TMWRITEMULTI):   * write out all the multiword terms ;
MPRINT(TMWRITEMULTI):   data EMWS1.TextParsing_multiall;
MPRINT(TMWRITEMULTI):   set _multiterms_;
MPRINT(TMWRITEMULTI):   file _multout encoding="utf-8";
MPRINT(TMWRITEMULTI):   put term ':3:' role;
MPRINT(TMWRITEMULTI):   run;

NOTE: 파일 _MULTOUT:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\multiword.txt,
      RECFM=V,LRECL=131068,파일 크기 (바이트)=0,
      마지막 수정일=2018년 10월 14일 00시37분22초,
      생성 시간=2018년 10월 08일 20시35분49초

NOTE: 0개의 레코드를 파일 _MULTOUT에 기록했습니다.
NOTE: 0개의 관측값을 데이터셋 WORK._MULTITERMS_.에서 읽었습니다.
NOTE: 데이터셋 EMWS1.TEXTPARSING_MULTIALL은(는) 0개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TRAIN):  ;
MPRINT(TM_PARSE):   proc sql noprint;
MPRINT(TM_PARSE):   drop table EMWS1.TextParsing_tmconfig;
NOTE: 테이블 EMWS1.TEXTPARSING_TMCONFIG 을(를) 삭제했습니다.
MPRINT(TM_PARSE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_PARSE):   data _null_;
MPRINT(TM_PARSE):   posignore = "'ABBR' 'ADJ' 'ADV' 'AUX' 'CONJ' 'DET' 'INTERJ' 'NUM' 'PART' 'PREF' 'PREP' 'PRON' 'PROP' 'VERB' 'VERBADJ'";
MPRINT(TM_PARSE):   posignore = transtrn(posignore, "'", '"');
MPRINT(TM_PARSE):   call symput("posignore", posignore);
MPRINT(TM_PARSE):   attribignore = "'PUNCT' 'NUM' 'ABBR' 'MIXED'";
MPRINT(TM_PARSE):   attribignore = transtrn(attribignore, "'", '"');
MPRINT(TM_PARSE):   call symput("attribignore", attribignore);
MPRINT(TM_PARSE):   run;

NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TM_PARSE):   proc sql noprint;
MPRINT(TM_PARSE):   select count(*) into :stoplist_count from EMWS1.TextParsing_stopList;
MPRINT(TM_PARSE):   select count(*) into :startlist_count from EMWS1.TextParsing_startList;
MPRINT(TM_PARSE):   select count(*) into :synds_count from work.internal_synds;
MPRINT(TM_PARSE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_PARSE):   proc hptmine data=EMWS1.TextParsing_TRAIN language=korean;
MPRINT(TM_PARSE):   var Contents ;
MPRINT(TM_PARSE):   doc_id _document_;
MPRINT(TM_PARSE):   parse reducef=1 outterms=EMWS1.TextParsing_terms showdroppedterms nostemming notagging nonoungroups start=EMWS1.TextParsing_startList entities=none 
multiterm="C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\multiword.txt" buildindex indexpath="C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\" outchild=EMWS1.TextParsing_tmout 
outpos=EMWS1.TextParsing_tmoutpos outconfig=EMWS1.TextParsing_tmconfig ;
MPRINT(TM_PARSE):   select "ABBR" "ADJ" "ADV" "AUX" "CONJ" "DET" "INTERJ" "NUM" "PART" "PREF" "PREP" "PRON" "PROP" "VERB" "VERBADJ" "Newline" / ignore ;
MPRINT(TM_PARSE):   select "PUNCT" "NUM" "ABBR" "MIXED" / group="attributes" ignore;
MPRINT(TM_PARSE):   ;
MPRINT(TM_PARSE):   performance details;
MPRINT(TM_PARSE):   run;

NOTE: No SPARSEFORMAT option is specified. SPARSEFORMAT=COO will be run by default.
NOTE: No TERMWGT option is specified. TERMWGT=ENTROPY will be run by default.
NOTE: No CELLWGT option is specified. CELLWGT=LOG will be run by default.
NOTE: The HPTMINE procedure is executing in single-machine mode.
WARNING:  The specified multiword list was unable to be processed and will be ignored.
NOTE: 800개의 관측값을 데이터셋 EMWS1.TEXTPARSING_TRAIN.에서 읽었습니다.
NOTE: 71개의 관측값을 데이터셋 EMWS1.TEXTPARSING_STARTLIST.에서 읽었습니다.
NOTE: 데이터셋 EMWS1.TEXTPARSING_TERMS은(는) 16050개의 관측값과 11개의 변수를 가지고 있습니다.
NOTE: 데이터셋 EMWS1.TEXTPARSING_TMOUT은(는) 96040개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 데이터셋 EMWS1.TEXTPARSING_TMOUTPOS은(는) 158076개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: 데이터셋 EMWS1.TEXTPARSING_TMCONFIG은(는) 1개의 관측값과 18개의 변수를 가지고 있습니다.
NOTE: 출력 결과 (프로시저: HPTMINE, 페이지: 2)
NOTE: 프로시저 HPTMINE 실행(총 프로세스 시간):
      실행 시간           57.86 초
      cpu 시간            2:24.59
      

MPRINT(TM_PARSE):   proc sql noprint;
MPRINT(TM_PARSE):   create table EMWS1.TextParsing_terms as select *,_keep as keep from EMWS1.TextParsing_terms order by _keep desc,numdocs desc;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS1.TEXTPARSING_TERMS created, with 16050 rows and 12 columns.

MPRINT(TM_PARSE):   create table tempKey as select a.key as _termnum_, a.term, a.role from EMWS1.TextParsing_terms a where a._ispar ne '+';
NOTE: Table WORK.TEMPKEY created, with 16050 rows and 3 columns.

MPRINT(TM_PARSE):   create table tempoutpos as select a.document as _document_, a.sentence as _sentence_, a._start_ as _offset_, a._end_ - a._start_+1 as _length_, b._termnum_ from EMWS1.TextParsing_tmoutpos as a , tempKey as b where b.term=a.term and 
b.role=a.role;
NOTE: Table WORK.TEMPOUTPOS created, with 158076 rows and 5 columns.

MPRINT(TM_PARSE):   create table tempoutds as select a.* from EMWS1.TextParsing_tmout as a, tempkey as b where a._termnum_= b._termnum_;
NOTE: Table WORK.TEMPOUTDS created, with 96040 rows and 3 columns.

MPRINT(TM_PARSE):   create table EMWS1.TextParsing_tmoutpos as select a._document_, a._sentence_, a._offset_, a. _length_, a._termnum_, b._count_ from tempoutpos as a, tempoutds as b where a._termnum_=b._termnum_ and a._document_ =b._document_;
NOTE: Table EMWS1.TEXTPARSING_TMOUTPOS created, with 158076 rows and 6 columns.

MPRINT(TM_PARSE):   drop table tempoutpos;
NOTE: 테이블 WORK.TEMPOUTPOS 을(를) 삭제했습니다.
MPRINT(TM_PARSE):   drop table tempKey;
NOTE: 테이블 WORK.TEMPKEY 을(를) 삭제했습니다.
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           1.02 초
      cpu 시간            1.00 초
      

MPRINT(TM_PARSE):   proc sort data=EMWS1.TextParsing_tmout;
MPRINT(TM_PARSE):   by _termnum_ _document_;
MPRINT(TM_PARSE):   run;

NOTE: 96040개의 관측값을 데이터셋 EMWS1.TEXTPARSING_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 EMWS1.TEXTPARSING_TMOUT은(는) 96040개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.14 초
      cpu 시간            0.14 초
      

MPRINT(TM_PARSE):   quit;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc sql;
MPRINT(TRAIN):   create table EMWS1.TextParsing_terms as select a.key label= "키", a.term label= "용어", a.role, case a.role when 'Abbr' then "Abbr" when 'Adj' then "Adj" when 'Adv' then "Adv" when 'Aux' then "Aux" when 'Conj' then "Conj" when 'Det' then 
"Det" when 'Interj' then "Interj" when 'Noun' then "Noun" when 'Num' then "Num" when 'Part' then "Part" when 'Pref' then "Pref" when 'Prep' then "Prep" when 'Pron' then "Pron" when 'Prop' then "Prop" when 'Punct' then "Punct" when 'Verb' then "Verb" when 
'VerbAdj' then "VerbAdj" when 'PERSON' then "인명" when 'ORGANIZATION' then "조직" when 'LOCATION' then "위치" when 'COMPANY' then "회사" when 'TITLE' then "직위" when 'PHONE' then "전화 번호" when 'DATE' then "날짜" when 'TIME' then "시간" when 
'INTERNET' then "인터넷" when 'MEASURE' then "측도" when 'NOUN_GROUP' then "명사 그룹" when 'SSN' then "주민등록번호" when 'CURRENCY' then "통화" when 'PERCENT' then "백분율" when 'TIME_PERIOD' then "기간" when 'PROP_MISC' then "기타 고유명사" when 
'VEHICLE' then "차량" when 'ADDRESS' then "주소" else a.role end as rolestring label="역할", a.attribute, case a.attribute when 'Alpha' then "알파" when 'Mixed' then "혼합" when 'Num' then "숫자" when 'Entity' then "엔터티" else a.ATTRIBUTE end as 
attrstring label="속성", a.freq label="빈도", a.numdocs label="문서 수", a.keep label="유지", a._ispar label="상위/하위 상태", a.parent label="상위", a.parent_id label="상위 ID" from EMWS1.TextParsing_terms a;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS1.TEXTPARSING_TERMS created, with 16050 rows and 12 columns.

MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.84 초
      cpu 시간            0.84 초
      

MPRINT(TRAIN):   data EMWS1.TextParsing_tmconfig;
MPRINT(TRAIN):   length multiencoding $24 NG $3 ;
MPRINT(TRAIN):   set EMWS1.TextParsing_tmconfig;
MPRINT(TRAIN):   parseVar = lowcase("Contents                        ");
MPRINT(TRAIN):   displayVar = lowcase("");
MPRINT(TRAIN):   indexpath = "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\";
MPRINT(TRAIN):   multiencoding="utf-8";
MPRINT(TRAIN):   filterLangs="";
MPRINT(TRAIN):   if NG="Y" then NG="STD";
MPRINT(TRAIN):   else if NG="N" then NG="OFF";
MPRINT(TRAIN):   if entities="STD" then entities="Y";
MPRINT(TRAIN):   language=lowcase(language);
MPRINT(TRAIN):   run;

NOTE: 1개의 관측값을 데이터셋 EMWS1.TEXTPARSING_TMCONFIG.에서 읽었습니다.
NOTE: 데이터셋 EMWS1.TEXTPARSING_TMCONFIG은(는) 1개의 관측값과 23개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TRAIN):   proc sort data=EMWS1.TextParsing_terms;
MPRINT(TRAIN):   by term role;
MPRINT(TRAIN):   run;

NOTE: 16050개의 관측값을 데이터셋 EMWS1.TEXTPARSING_TERMS.에서 읽었습니다.
NOTE: 데이터셋 EMWS1.TEXTPARSING_TERMS은(는) 16050개의 관측값과 12개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TRAIN):   data EMWS1.TextParsing_EMINFO;
MPRINT(TRAIN):   length TARGET KEY $32 DATA $43;
MPRINT(TRAIN):   key="LastTMNode";
MPRINT(TRAIN):   data="TextParsing";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTMNodeType";
MPRINT(TRAIN):   data="TextParsing";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTextParsing";
MPRINT(TRAIN):   data="TextParsing";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   run;

NOTE: 변수 TARGET이(가) 초기화되지 않았습니다.
NOTE: 데이터셋 EMWS1.TEXTPARSING_EMINFO은(는) 3개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TRAIN):   filename temp;
NOTE: Fileref TEMP을(를) 삭제했습니다.
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: TextParsing;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
24083      *------------------------------------------------------------*;
24084      * End TRAIN: TextParsing;
24085      *------------------------------------------------------------*;
24086      
24087      
24088      
24089      

24090      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
24091      * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
24092      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
24093      ;
MPRINT(EM_DIAGRAM):   ;
24094      ;
MPRINT(EM_DIAGRAM):   ;
24095      ;
MPRINT(EM_DIAGRAM):   ;
24096      ;
MPRINT(EM_DIAGRAM):   ;
24097      quit;
MPRINT(EM_DIAGRAM):   quit;
24098      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
24099      * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
24100      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
24101      /*; *"; *'; */
24102      ;
MPRINT(EM_DIAGRAM):   ;
24103      run;
MPRINT(EM_DIAGRAM):   run;
24104      quit;
MPRINT(EM_DIAGRAM):   quit;
24105      /* Reset EM Options */
24106      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
24107      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
24108      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
24109      proc sort data=WORK.EM_METACHANGE;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_METACHANGE;
24110      by key uname;
MPRINT(EM_DIAGRAM):   by key uname;
24111      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: 1개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 1개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

24112      filename x "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\CDELTA_TRAIN.sas";
MPRINT(EM_DIAGRAM):    filename x "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\CDELTA_TRAIN.sas";
24113      data _null_;
MPRINT(EM_DIAGRAM):   data _null_;
24114      file x;
MPRINT(EM_DIAGRAM):   file x;
24115      put 'if upcase(NAME) = "_DOCUMENT_" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "_DOCUMENT_" then do;';
24116      put 'ROLE = "ID";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "ID";';
24117      put 'LEVEL = "NOMINAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "NOMINAL";';
24118      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
24119      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: 파일 X:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS1\TextParsing\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,파일 크기 (바이트)=0,
      마지막 수정일=2018년 10월 14일 00시38분22초,
      생성 시간=2018년 10월 08일 20시30분33초

NOTE: 4개의 레코드를 파일 X에 기록했습니다.
      최소 레코드 길이는 4입니다.
      최대 레코드 길이는 39입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
      

24120      filename x;
MPRINT(EM_DIAGRAM):   filename x;
NOTE: Fileref X을(를) 삭제했습니다.
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
