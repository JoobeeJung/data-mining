*------------------------------------------------------------*
사용자:                Administrator
날짜:                2018년 11월 20일
시간:                10시00분52초
사이트:                10503192
플랫폼:            X64_10HOME
관리 릴리스: 9.04.01M4P110916
EM 버전:          14.2
* 
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 20일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "10시00분22초" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 분석 로그";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* 분석 로그
날짜:                2018년 11월 20일
시간:                10시00분22초
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O0CBODGW "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O0CBODGW new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 20일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "10시00분22초" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "사용자:                Administrator";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "사이트:                10503192";
MPRINT(EM_DIAGRAM):   put "플랫폼:            X64_10HOME";
MPRINT(EM_DIAGRAM):   put "관리 릴리스: 9.04.01M4P110916";
MPRINT(EM_DIAGRAM):   put "EM 버전:          14.2";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 20일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "10시00분22초" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "사용자:                Administrator";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 분석 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 스코어 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 리포트 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
34199      proc freq data=EMWS6.Neural_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS6.Neural_VariableSet noprint;
34200      table ROLE*LEVEL/out=WORK.NeuralMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.NeuralMETA;
34201      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 25개의 관측값을 데이터셋 EMWS6.NEURAL_VARIABLESET.에서 읽었습니다.
NOTE: 데이터셋 WORK.NEURALMETA은(는) 5개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 FREQ 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
 
34202      proc print data=WORK.NeuralMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.NeuralMETA label noobs;
34203      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
34204      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "역할" LEVEL = "측도 레벨" COUNT = "빈도 개수";
34205      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
34206      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "변수 요약";
MPRINT(EM_DIAGRAM):   run;
34207      run;
 
NOTE: 5개의 관측값을 데이터셋 WORK.NEURALMETA.에서 읽었습니다.
NOTE: 출력 결과 (프로시저: PRINT, 페이지: 7)
NOTE: 프로시저 PRINT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
34208      title10;
MPRINT(EM_DIAGRAM):   title10;
34209      %let EMNORLEN = %DMNORLEN;
MPRINT(EM_DIAGRAM):
EMWS6.Part_TRAIN EMWS6.Part_TRAIN
EMWS6.Part_TRAIN EMWS6.Part_TRAIN EMWS6 Part_TRAIN
EMWS6.Part_TRAIN EMWS6.Part_TRAIN
EMWS6.Part_TRAIN EMWS6.Part_TRAIN EMWS6 Part_TRAIN
MPRINT(EM_DIAGRAM):    proc dmdb data=EMWS6.Part_TRAIN classout=WORK._DMDBCLASSTARGET(keep=NAME NRAW CRAW LEVEL FREQUENCY NMISSPERCENT);
MPRINT(EM_DIAGRAM):   class RESPOND(DESC) ;
MPRINT(EM_DIAGRAM):   run;
Executing  SASHELP.EMCORE.EMINFOITERATOR.SCL _INIT >>
Executing  SASHELP.EMCORE.EMINFOITERATOR.SCL setMetaData >>
Executing  SASHELP.EMCORE.EMINFOITERATOR.SCL next >>
Executing  SASHELP.EMCORE.EMINFOITERATOR.SCL next >>
Executing  SASHELP.EMCORE.EMINFOITERATOR.SCL setMetaData >>
Executing  SASHELP.EMCORE.EMINFOITERATOR.SCL next >>
Executing  SASHELP.EMCORE.EMINFOITERATOR.SCL next >>
Executing  SASHELP.EMCORE.EMINFOITERATOR.SCL _term >>
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   set WORK._DMDBCLASSTARGET;
MPRINT(EM_DIAGRAM):   where ^(NRAW eq . and CRAW eq '') and NAME="RESPOND";
MPRINT(EM_DIAGRAM):   if _N_=1 then call symput('_newevent', strip(LEVEL));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc sort data=WORK._DMDBCLASSTARGET out=_TEMPCLASS(keep=LEVEL FREQUENCY NMISSPERCENT rename=(LEVEL=RESPOND));
MPRINT(EM_DIAGRAM):   by LEVEL;
MPRINT(EM_DIAGRAM):   where ^(NRAW eq . and CRAW eq '') and NAME="RESPOND";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _TEMPCLASS;
MPRINT(EM_DIAGRAM):   set _TEMPCLASS;
MPRINT(EM_DIAGRAM):   NMISSPERCENT= NMISSPERCENT/100;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    proc sort data=EMWS6.Ids_RESPOND_DD out=_sortedDecdata;
MPRINT(EM_DIAGRAM):   by RESPOND;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   merge _TEMPCLASS(in=_a) _sortedDecdata(in=_b);
MPRINT(EM_DIAGRAM):   by RESPOND;
MPRINT(EM_DIAGRAM):   if (_a and ^_b) or (^_a and _b) then call symput('_emresetDec', '1');
MPRINT(EM_DIAGRAM):   run;
34238      data WORK.Neural_EVENT(KEEP=VARIABLE LABEL LEVEL EVENT NUMLEVELS ORDER);
MPRINT(EM_DIAGRAM):    data WORK.Neural_EVENT(KEEP=VARIABLE LABEL LEVEL EVENT NUMLEVELS ORDER);
34239      length ORDER $20;
MPRINT(EM_DIAGRAM):   length ORDER $20;
34240      label VARIABLE = "%sysfunc(sasmsg(sashelp.dmine, rpt_target_vlabel,  NOQUOTE))" EVENT = "%sysfunc(sasmsg(sashelp.dmine, assmt_event_vlabel, NOQUOTE))" NUMLEVELS = "%sysfunc(sasmsg(sashelp.dmine, rpt_numcat_vlabel, NOQUOTE))" LEVEL =
34241         "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" ORDER = "%sysfunc(sasmsg(sashelp.dmine, meta_order_vlabel, NOQUOTE))" LABEL = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label VARIABLE = "타겟" EVENT = "이벤트" NUMLEVELS = "레벨 수" LEVEL = "측도 레벨" ORDER = "순서" LABEL = "레이블";
34242      set EMWS6.IDS_RESPOND_DM( where=(_TYPE_="TARGET"));
MPRINT(EM_DIAGRAM):   set EMWS6.IDS_RESPOND_DM( where=(_TYPE_="TARGET"));
34243      NumLevels=2;
MPRINT(EM_DIAGRAM):   NumLevels=2;
34244      select(upcase(ORDER));
MPRINT(EM_DIAGRAM):   select(upcase(ORDER));
34245      when('DESC') ORDER = 'Descending';
MPRINT(EM_DIAGRAM):   when('DESC') ORDER = 'Descending';
34246      when('ASC') ORDER = 'Ascending';
MPRINT(EM_DIAGRAM):   when('ASC') ORDER = 'Ascending';
34247      when('FMTDESC') ORDER = 'Formatted Descending';
MPRINT(EM_DIAGRAM):   when('FMTDESC') ORDER = 'Formatted Descending';
34248      when('FMTASC') ORDER = 'Formatted Ascending';
MPRINT(EM_DIAGRAM):   when('FMTASC') ORDER = 'Formatted Ascending';
34249      otherwise ORDER = 'Descending';
MPRINT(EM_DIAGRAM):   otherwise ORDER = 'Descending';
34250      end;
MPRINT(EM_DIAGRAM):   end;
34251      output;
MPRINT(EM_DIAGRAM):   output;
34252      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS6.IDS_RESPOND_DM.에서 읽었습니다.
      WHERE _TYPE_='TARGET';
NOTE: 데이터셋 WORK.NEURAL_EVENT은(는) 1개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
 
34253      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
34254      proc print data=WORK.Neural_EVENT noobs label;
MPRINT(EM_DIAGRAM):   proc print data=WORK.Neural_EVENT noobs label;
34255      var VARIABLE EVENT LEVEL NUMLEVELS ORDER LABEL;
MPRINT(EM_DIAGRAM):   var VARIABLE EVENT LEVEL NUMLEVELS ORDER LABEL;
34256      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
34257      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_modelEvent_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "모델 이벤트";
MPRINT(EM_DIAGRAM):   run;
34258      run;
 
NOTE: 1개의 관측값을 데이터셋 WORK.NEURAL_EVENT.에서 읽었습니다.
NOTE: 출력 결과 (프로시저: PRINT, 페이지: 8)
NOTE: 프로시저 PRINT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
34259      title10;
MPRINT(EM_DIAGRAM):   title10;
"타겟 "RESPOND"에 대해 정의된 의사결정이 없습니다."
34260      proc print data = EMWS6.Ids_RESPOND_DM noobs label;
MPRINT(EM_DIAGRAM):    proc print data = EMWS6.Ids_RESPOND_DM noobs label;
34261      var _type_ variable label;
MPRINT(EM_DIAGRAM):   var _type_ variable label;
34262      where _type_ ^in('MATRIX', 'DECISION', 'TRAINPRIOR', 'DATAPRIOR', 'DECPRIOR');
MPRINT(EM_DIAGRAM):   where _type_ ^in('MATRIX', 'DECISION', 'TRAINPRIOR', 'DATAPRIOR', 'DECPRIOR');
34263      label _TYPE_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_type_vlabel,     NOQUOTE))" VARIABLE = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel, NOQUOTE))" LABEL = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label _TYPE_ = "유형" VARIABLE = "변수" LABEL = "레이블";
34264      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
34265      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_predDecVars_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "예측 및 의사결정 변수";
MPRINT(EM_DIAGRAM):   run;
34266      run;
 
NOTE: 7개의 관측값을 데이터셋 EMWS6.IDS_RESPOND_DM.에서 읽었습니다.
      WHERE _type_ not in ('DATAPRIOR', 'DECISION', 'DECPRIOR', 'MATRIX', 'TRAINPRIOR');
NOTE: 출력 결과 (프로시저: PRINT, 페이지: 9)
NOTE: 프로시저 PRINT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
34267      title10;
MPRINT(EM_DIAGRAM):   title10;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Neural: 분석용 메타데이터 준비;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   data WORK.M0LTHNU_;
MPRINT(EM_DIAGRAM):   set WORK.M0LTHNU_;
MPRINT(EM_DIAGRAM):   where(use = 'Y' or (role = 'INPUT' and use = 'D'));
MPRINT(EM_DIAGRAM):   if (role = 'REJECTED') then role = 'INPUT';
MPRINT(EM_DIAGRAM):   run;
34277      data WORK.M0LTHNU_;
MPRINT(EM_DIAGRAM):    data WORK.M0LTHNU_;
34278      set WORK.M0LTHNU_ end=eof;
MPRINT(EM_DIAGRAM):   set WORK.M0LTHNU_ end=eof;
34279      output;
MPRINT(EM_DIAGRAM):   output;
34280      if eof then do;
MPRINT(EM_DIAGRAM):   if eof then do;
34281      NAME="";
MPRINT(EM_DIAGRAM):   NAME="";
34282      ROLE="COST";
MPRINT(EM_DIAGRAM):   ROLE="COST";
34283      LEVEL="INTERVAL";
MPRINT(EM_DIAGRAM):   LEVEL="INTERVAL";
34284      TYPE="N";
MPRINT(EM_DIAGRAM):   TYPE="N";
34285      output;
MPRINT(EM_DIAGRAM):   output;
34286      end;
MPRINT(EM_DIAGRAM):   end;
34287      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 17개의 관측값을 데이터셋 WORK.M0LTHNU_.에서 읽었습니다.
NOTE: 데이터셋 WORK.M0LTHNU_은(는) 18개의 관측값과 21개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
NOTE: 2개의 관측값을 데이터셋 EMWS6.IDS_RESPOND_DD.에서 읽었습니다.
NOTE: 데이터셋 WORK.RESPOND은(는) 2개의 관측값과 7개의 변수를 가지고 있습니다.
NOTE: 2개의 관측값을 데이터셋 EMWS6.IDS_RESPOND_DD.에서 읽었습니다.
NOTE: 데이터셋 WORK.RESPOND은(는) 2개의 관측값과 7개의 변수를 가지고 있습니다.
34288      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
34289      * Neural: Create decision matrix;
MPRINT(EM_DIAGRAM):   * Neural: Create decision matrix;
34290      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34291      data WORK.RESPOND;
MPRINT(EM_DIAGRAM):   data WORK.RESPOND;
34292        length   RESPOND                          $  32
34293                 COUNT                                8
34294                 DATAPRIOR                            8
34295                 TRAINPRIOR                           8
34296                 DECPRIOR                             8
34297                 DECISION1                            8
34298                 DECISION2                            8
34299                 ;
MPRINT(EM_DIAGRAM):   length RESPOND $ 32 COUNT 8 DATAPRIOR 8 TRAINPRIOR 8 DECPRIOR 8 DECISION1 8 DECISION2 8 ;
34300
34301        label    COUNT="Level Counts"
34302                 DATAPRIOR="Data Proportions"
34303                 TRAINPRIOR="Training Proportions"
34304                 DECPRIOR="Decision Priors"
34305                 DECISION1="1"
34306                 DECISION2="0"
34307                 ;
MPRINT(EM_DIAGRAM):   label COUNT= "Level Counts" DATAPRIOR= "Data Proportions" TRAINPRIOR= "Training Proportions" DECPRIOR= "Decision Priors" DECISION1= "1" DECISION2= "0" ;
34308        format   COUNT 10.
34309                 ;
MPRINT(EM_DIAGRAM):   format COUNT 10. ;
34310      RESPOND="1"; COUNT=767; DATAPRIOR=0.0767; TRAINPRIOR=0.0767; DECPRIOR=.; DECISION1=1; DECISION2=0;
MPRINT(EM_DIAGRAM):   RESPOND="1";
MPRINT(EM_DIAGRAM):   COUNT=767;
MPRINT(EM_DIAGRAM):   DATAPRIOR=0.0767;
MPRINT(EM_DIAGRAM):   TRAINPRIOR=0.0767;
MPRINT(EM_DIAGRAM):   DECPRIOR=.;
MPRINT(EM_DIAGRAM):   DECISION1=1;
MPRINT(EM_DIAGRAM):   DECISION2=0;
34311      output;
MPRINT(EM_DIAGRAM):   output;
34312      RESPOND="0"; COUNT=9233; DATAPRIOR=0.9233; TRAINPRIOR=0.9233; DECPRIOR=.; DECISION1=0; DECISION2=1;
MPRINT(EM_DIAGRAM):   RESPOND="0";
MPRINT(EM_DIAGRAM):   COUNT=9233;
MPRINT(EM_DIAGRAM):   DATAPRIOR=0.9233;
MPRINT(EM_DIAGRAM):   TRAINPRIOR=0.9233;
MPRINT(EM_DIAGRAM):   DECPRIOR=.;
MPRINT(EM_DIAGRAM):   DECISION1=0;
MPRINT(EM_DIAGRAM):   DECISION2=1;
34313      output;
MPRINT(EM_DIAGRAM):   output;
34314      ;
MPRINT(EM_DIAGRAM):   ;
34315      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 데이터셋 WORK.RESPOND은(는) 2개의 관측값과 7개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
34316      proc datasets lib=work nolist;
MPRINT(EM_DIAGRAM):   proc datasets lib=work nolist;
34317      modify RESPOND(type=PROFIT label=RESPOND);
MPRINT(EM_DIAGRAM):   modify RESPOND(type=PROFIT label= RESPOND);
MPRINT(EM_DIAGRAM):   label DECISION1= '1';
MPRINT(EM_DIAGRAM):   label DECISION2= '0';
MPRINT(EM_DIAGRAM):   run;
34318      label DECISION1= '1';
34319      label DECISION2= '0';
34320      run;
 
NOTE: WORK.RESPOND.DATA에 대한 MODIFY에 성공했습니다.
34321      quit;
MPRINT(EM_DIAGRAM):   quit;
 
NOTE: 프로시저 DATASETS 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
34322      data EM_Neural;
MPRINT(EM_DIAGRAM):   data EM_Neural;
34323      set EMWS6.Part_TRAIN(keep=
34324      AGE BUY12 BUY18 BUY6 CLIMATE COA6 DISCBUY FICO INCOME LOC MARRIED ORGSRC
34325      OWNHOME RESPOND RETURN24 SEX VALUE24 );
MPRINT(EM_DIAGRAM):   set EMWS6.Part_TRAIN(keep= AGE BUY12 BUY18 BUY6 CLIMATE COA6 DISCBUY FICO INCOME LOC MARRIED ORGSRC OWNHOME RESPOND RETURN24 SEX VALUE24 );
34326      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 3999개의 관측값을 데이터셋 EMWS6.PART_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_NEURAL은(는) 3999개의 관측값과 17개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Neural: DMDBClass Macro ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
34327      *------------------------------------------------------------* ;
34328      * Neural: DMDBClass Macro ;
34329      *------------------------------------------------------------* ;
34330      %macro DMDBClass;
34331          CLIMATE(ASC) COA6(ASC) DISCBUY(ASC) LOC(ASC) MARRIED(ASC) ORGSRC(ASC)
34332         OWNHOME(ASC) RESPOND(DESC) RETURN24(ASC) SEX(ASC)
34333      %mend DMDBClass;
34334      *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
34335      * Neural: DMDBVar Macro ;
MPRINT(EM_DIAGRAM):   * Neural: DMDBVar Macro ;
34336      *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
34337      %macro DMDBVar;
34338          AGE BUY12 BUY18 BUY6 FICO INCOME VALUE24
34339      %mend DMDBVar;
34340      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34341      * Neural: Create DMDB;
MPRINT(EM_DIAGRAM):   * Neural: Create DMDB;
34342      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34343      proc dmdb batch data=WORK.EM_Neural
34344      dmdbcat=WORK.Neural_DMDB
34345      maxlevel = 513
34346      ;
MPRINT(EM_DIAGRAM):   proc dmdb batch data=WORK.EM_Neural dmdbcat=WORK.Neural_DMDB maxlevel = 513 ;
MPRINT(EM_DIAGRAM):   class
34347      class %DMDBClass;
MPRINT(DMDBCLASS):   CLIMATE(ASC) COA6(ASC) DISCBUY(ASC) LOC(ASC) MARRIED(ASC) ORGSRC(ASC) OWNHOME(ASC) RESPOND(DESC) RETURN24(ASC) SEX(ASC)
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   var
34348      var %DMDBVar;
MPRINT(DMDBVAR):   AGE BUY12 BUY18 BUY6 FICO INCOME VALUE24
MPRINT(EM_DIAGRAM):  ;
34349      target
34350      RESPOND
34351      ;
MPRINT(EM_DIAGRAM):   target RESPOND ;
34352      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: Records processed = 3999   Memory used = 511K.
NOTE: 3999개의 관측값을 데이터셋 WORK.EM_NEURAL.에서 읽었습니다.
NOTE: 프로시저 DMDB 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(EM_DIAGRAM):   quit;
MPRINT(EM_DIAGRAM):   *--- end code ---*;
34353      quit;
34354      *--- end code ---*;
 
34355      *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------* ;
34356      * Neural: Interval Input Variables Macro ;
MPRINT(EM_DIAGRAM):   * Neural: Interval Input Variables Macro ;
34357      *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
34358      %macro INTINPUTS;
34359          AGE BUY12 BUY18 BUY6 FICO INCOME VALUE24
34360      %mend INTINPUTS;
34361      *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
34362      * Neural: Binary 입력 Macro ;
MPRINT(EM_DIAGRAM):   * Neural: Binary 입력 Macro ;
34363      *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
34364      %macro BININPUTS;
34365          COA6 DISCBUY MARRIED OWNHOME RETURN24 SEX
34366      %mend BININPUTS;
34367      *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
34368      * Neural: Nominal 입력 Macro ;
MPRINT(EM_DIAGRAM):   * Neural: Nominal 입력 Macro ;
34369      *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
34370      %macro NOMINPUTS;
34371          CLIMATE LOC ORGSRC
34372      %mend NOMINPUTS;
34373      *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
34374      * Neural: Ordinal 입력 Macro ;
MPRINT(EM_DIAGRAM):   * Neural: Ordinal 입력 Macro ;
34375      *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
34376      %macro ORDINPUTS;
34377
34378      %mend ORDINPUTS;
34379      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34380      * 신경망 분석;
MPRINT(EM_DIAGRAM):   * 신경망 분석;
34381      ;
MPRINT(EM_DIAGRAM):   ;
34382      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34383      proc neural data=EM_Neural dmdbcat=WORK.Neural_DMDB
34384      validdata = EMWS6.Part_VALIDATE
34385      random=12345
34386      ;
MPRINT(EM_DIAGRAM):   proc neural data=EM_Neural dmdbcat=WORK.Neural_DMDB validdata = EMWS6.Part_VALIDATE random=12345 ;
34387      nloptions
34388      ;
MPRINT(EM_DIAGRAM):   nloptions ;
34389      performance alldetails noutilfile;
MPRINT(EM_DIAGRAM):   performance alldetails noutilfile;
34390      netopts
34391      decay=0;
MPRINT(EM_DIAGRAM):   netopts decay=0;
MPRINT(EM_DIAGRAM):   input
34392      input %INTINPUTS / level=interval id=intvl
MPRINT(INTINPUTS):   AGE BUY12 BUY18 BUY6 FICO INCOME VALUE24
34393      ;
MPRINT(EM_DIAGRAM):   / level=interval id=intvl ;
MPRINT(EM_DIAGRAM):   input
34394      input %BININPUTS / level=nominal id=bin
MPRINT(BININPUTS):   COA6 DISCBUY MARRIED OWNHOME RETURN24 SEX
34395      ;
MPRINT(EM_DIAGRAM):   / level=nominal id=bin ;
MPRINT(EM_DIAGRAM):   input
34396      input %NOMINPUTS / level=nominal id=nom
MPRINT(NOMINPUTS):   CLIMATE LOC ORGSRC
34397      ;
MPRINT(EM_DIAGRAM):   / level=nominal id=nom ;
34398      target RESPOND / level=NOMINAL id=RESPOND
34399      bias
34400      ;
MPRINT(EM_DIAGRAM):   target RESPOND / level=NOMINAL id=RESPOND bias ;
34401      arch MLP
34402      Hidden=3
34403      ;
MPRINT(EM_DIAGRAM):   arch MLP Hidden=3 ;
34404      Prelim 5 preiter=10
34405      pretime=3600
34406      Outest=EMWS6.Neural_PRELIM_OUTEST
34407      ;
MPRINT(EM_DIAGRAM):   Prelim 5 preiter=10 pretime=3600 Outest=EMWS6.Neural_PRELIM_OUTEST ;
NOTE:  Synchronizing the objectives and the Solution.
NOTE: LEVMAR Optimization cannot be completed.
NOTE: LEVMAR needs more than 10 iterations or 2147483647 function calls.
NOTE: LEVMAR Optimization cannot be completed.
NOTE: LEVMAR needs more than 10 iterations or 2147483647 function calls.
NOTE: LEVMAR Optimization cannot be completed.
NOTE: LEVMAR needs more than 10 iterations or 2147483647 function calls.
NOTE: LEVMAR Optimization cannot be completed.
NOTE: LEVMAR needs more than 10 iterations or 2147483647 function calls.
NOTE: LEVMAR Optimization cannot be completed.
NOTE: LEVMAR needs more than 10 iterations or 2147483647 function calls.
NOTE: 데이터셋 EMWS6.NEURAL_PRELIM_OUTEST은(는) 11개의 관측값과 106개의 변수를 가지고 있습니다.
34408      save network=EMWS6.Neural_NETWORK.dm_neural;
MPRINT(EM_DIAGRAM):   save network=EMWS6.Neural_NETWORK.dm_neural;
NOTE: Creating a new Catalogue with entry EMWS6.NEURAL_NETWORK.DM_NEURAL.
NOTE: Entry EMWS6.NEURAL_NETWORK.DM_NEURAL has been opened.
NOTE: Entry EMWS6.NEURAL_NETWORK.DM_NEURAL has been closed.
34409      train Maxiter=50
34410      maxtime=14400
34411      Outest=EMWS6.Neural_outest estiter=1
34412      Outfit=EMWS6.Neural_OUTFIT
34413      ;
MPRINT(EM_DIAGRAM):   train Maxiter=50 maxtime=14400 Outest=EMWS6.Neural_outest estiter=1 Outfit=EMWS6.Neural_OUTFIT ;
WARNING: LEVMAR Optimization cannot be completed.
NOTE: LEVMAR needs more than 50 iterations or 2147483647 function calls.
NOTE: 데이터셋 EMWS6.NEURAL_OUTEST은(는) 144개의 관측값과 106개의 변수를 가지고 있습니다.
NOTE: 데이터셋 EMWS6.NEURAL_OUTFIT은(는) 104개의 관측값과 36개의 변수를 가지고 있습니다.
34414      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 데이터셋 WORK.EM_NEURAL은(는) 3999개의 관측값과 17개의 변수를 가지고 있습니다.
NOTE: 데이터셋 EMWS6.PART_VALIDATE은(는) 3000개의 관측값과 27개의 변수를 가지고 있습니다.
NOTE: Closing the Neural Application.
NOTE: 출력 결과 (프로시저: NEURAL, 페이지: 10-13)
NOTE: 프로시저 NEURAL 실행(총 프로세스 시간):
      실행 시간           20.49 초
      cpu 시간            20.14 초
 
 
MPRINT(EM_DIAGRAM):   quit;
34415      quit;
 
34416      proc sort data=EMWS6.Neural_OUTFIT(where=(_iter_ ne . and _NAME_="OVERALL")) out=fit_Neural;
MPRINT(EM_DIAGRAM):    proc sort data=EMWS6.Neural_OUTFIT(where=(_iter_ ne . and _NAME_="OVERALL")) out=fit_Neural;
34417      by _VAVERR_;
MPRINT(EM_DIAGRAM):   by _VAVERR_;
34418      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 52개의 관측값을 데이터셋 EMWS6.NEURAL_OUTFIT.에서 읽었습니다.
      WHERE (_iter_ not = .) and (_NAME_='OVERALL');
NOTE: 데이터셋 WORK.FIT_NEURAL은(는) 52개의 관측값과 36개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
34419      %GLOBAL ITER;
34420      data _null_;
MPRINT(EM_DIAGRAM):   data _null_;
34421      set fit_Neural(obs=1);
MPRINT(EM_DIAGRAM):   set fit_Neural(obs=1);
34422      call symput('ITER',put(_ITER_, 6.));
MPRINT(EM_DIAGRAM):   call symput('ITER',put(_ITER_, 6.));
34423      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 1개의 관측값을 데이터셋 WORK.FIT_NEURAL.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
34424      data EMWS6.Neural_INITIAL;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_INITIAL;
34425      set EMWS6.Neural_outest(where=(_ITER_ eq &ITER and _OBJ_ ne .));
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_outest(where=(_ITER_ eq 1 and _OBJ_ ne .));
34426      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS6.NEURAL_OUTEST.에서 읽었습니다.
      WHERE (_ITER_=1) and (_OBJ_ not = .);
NOTE: 데이터셋 EMWS6.NEURAL_INITIAL은(는) 1개의 관측값과 106개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
34427      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
34428      * 신경망 모델 선택;
MPRINT(EM_DIAGRAM):   * 신경망 모델 선택;
34429      ;
MPRINT(EM_DIAGRAM):   ;
34430      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34431      proc neural data=EM_Neural dmdbcat=WORK.Neural_DMDB
34432      validdata = EMWS6.Part_VALIDATE
34433      network = EMWS6.Neural_NETWORK.dm_neural
34434      random=12345
34435      ;
MPRINT(EM_DIAGRAM):   proc neural data=EM_Neural dmdbcat=WORK.Neural_DMDB validdata = EMWS6.Part_VALIDATE network = EMWS6.Neural_NETWORK.dm_neural random=12345 ;
NOTE: Entry EMWS6.NEURAL_NETWORK.DM_NEURAL has been opened.
NOTE: Entry EMWS6.NEURAL_NETWORK.DM_NEURAL has been closed.
34436      nloptions noprint;
MPRINT(EM_DIAGRAM):   nloptions noprint;
34437      performance alldetails noutilfile;
MPRINT(EM_DIAGRAM):   performance alldetails noutilfile;
34438      initial inest=EMWS6.Neural_INITIAL;
MPRINT(EM_DIAGRAM):   initial inest=EMWS6.Neural_INITIAL;
NOTE: 데이터셋 EMWS6.NEURAL_INITIAL은(는) 1개의 관측값과 106개의 변수를 가지고 있습니다.
34439      train tech=NONE;
MPRINT(EM_DIAGRAM):   train tech=NONE;
NOTE: No optimization performed.
34440      code file="C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\SCORECODE.sas"
34441      group=Neural
34442      ;
MPRINT(EM_DIAGRAM):   code file="C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\SCORECODE.sas" group=Neural ;
NOTE: External file C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\SCORECODE.sas opened.
34443      ;
MPRINT(EM_DIAGRAM):   ;
34444      code file="C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\RESIDUALSCORECODE.sas"
34445      group=Neural
34446      residual
34447      ;
MPRINT(EM_DIAGRAM):   code file="C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\RESIDUALSCORECODE.sas" group=Neural residual ;
NOTE: External file C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\RESIDUALSCORECODE.sas opened.
34448      ;
MPRINT(EM_DIAGRAM):   ;
34449      score data=EMWS6.Part_TRAIN out=_NULL_
34450      outfit=WORK.FIT1
34451      role=TRAIN
34452      outkey=EMWS6.Neural_OUTKEY;
MPRINT(EM_DIAGRAM):   score data=EMWS6.Part_TRAIN out=_NULL_ outfit=WORK.FIT1 role=TRAIN outkey=EMWS6.Neural_OUTKEY;
NOTE: 데이터셋 EMWS6.NEURAL_OUTKEY은(는) 43개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: 데이터셋 EMWS6.PART_TRAIN은(는) 3999개의 관측값과 27개의 변수를 가지고 있습니다.
NOTE: 데이터셋 WORK.FIT1은(는) 2개의 관측값과 23개의 변수를 가지고 있습니다.
34453      score data=EMWS6.Part_VALIDATE out=_NULL_
34454      outfit=WORK.FIT2
34455      role=VALID
34456      outkey=EMWS6.Neural_OUTKEY;
MPRINT(EM_DIAGRAM):   score data=EMWS6.Part_VALIDATE out=_NULL_ outfit=WORK.FIT2 role=VALID outkey=EMWS6.Neural_OUTKEY;
NOTE: 데이터셋 EMWS6.NEURAL_OUTKEY은(는) 43개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: 데이터셋 EMWS6.PART_VALIDATE은(는) 3000개의 관측값과 27개의 변수를 가지고 있습니다.
NOTE: 데이터셋 WORK.FIT2은(는) 2개의 관측값과 15개의 변수를 가지고 있습니다.
34457      score data=EMWS6.Part_TEST out=_NULL_
34458      outfit=WORK.FIT3
34459      role=TEST
34460      outkey=EMWS6.Neural_OUTKEY;
MPRINT(EM_DIAGRAM):   score data=EMWS6.Part_TEST out=_NULL_ outfit=WORK.FIT3 role=TEST outkey=EMWS6.Neural_OUTKEY;
NOTE: 데이터셋 EMWS6.NEURAL_OUTKEY은(는) 43개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: 데이터셋 EMWS6.PART_TEST은(는) 3001개의 관측값과 27개의 변수를 가지고 있습니다.
NOTE: 데이터셋 WORK.FIT3은(는) 2개의 관측값과 17개의 변수를 가지고 있습니다.
34461      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 데이터셋 WORK.EM_NEURAL은(는) 3999개의 관측값과 17개의 변수를 가지고 있습니다.
NOTE: 데이터셋 EMWS6.PART_VALIDATE은(는) 3000개의 관측값과 27개의 변수를 가지고 있습니다.
NOTE: Closing the Neural Application.
NOTE: 프로시저 NEURAL 실행(총 프로세스 시간):
      실행 시간           0.24 초
      cpu 시간            0.23 초
 
 
MPRINT(EM_DIAGRAM):   quit;
34462      quit;
34463      data EMWS6.Neural_OUTFIT;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_OUTFIT;
34464      merge WORK.FIT1 WORK.FIT2 WORK.FIT3;
MPRINT(EM_DIAGRAM):   merge WORK.FIT1 WORK.FIT2 WORK.FIT3;
34465      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 2개의 관측값을 데이터셋 WORK.FIT1.에서 읽었습니다.
NOTE: 2개의 관측값을 데이터셋 WORK.FIT2.에서 읽었습니다.
NOTE: 2개의 관측값을 데이터셋 WORK.FIT3.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_OUTFIT은(는) 2개의 관측값과 51개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
34466      data EMWS6.Neural_EMESTIMATE;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_EMESTIMATE;
34467      set EMWS6.Neural_outest;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_outest;
34468      if _type_ ^in('HESSIAN' 'GRAD');
MPRINT(EM_DIAGRAM):   if _type_ ^in('HESSIAN' 'GRAD');
34469      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 144개의 관측값을 데이터셋 EMWS6.NEURAL_OUTEST.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_EMESTIMATE은(는) 52개의 관측값과 106개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
34470      proc datasets lib=work nolist;
MPRINT(EM_DIAGRAM):   proc datasets lib=work nolist;
34471      delete EM_Neural;
MPRINT(EM_DIAGRAM):   delete EM_Neural;
34472      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: WORK.EM_NEURAL(memtype=DATA)을(를) 삭제하는 중입니다.
34473      quit;
MPRINT(EM_DIAGRAM):   quit;
 
NOTE: 프로시저 DATASETS 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
34474      data EMWS6.Neural_PLOTDS(where=(_iter_ ne . and _NAME_="OVERALL"));
MPRINT(EM_DIAGRAM):    data EMWS6.Neural_PLOTDS(where=(_iter_ ne . and _NAME_="OVERALL"));
34475      set fit_Neural;
MPRINT(EM_DIAGRAM):   set fit_Neural;
34476      attrib _ITER_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_trainiterations_vlabel  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   attrib _ITER_ label="분석 반복";
34477      attrib _NAME_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_varsel_label_name  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   attrib _NAME_ label="이름";
34478      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 52개의 관측값을 데이터셋 WORK.FIT_NEURAL.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_PLOTDS은(는) 52개의 관측값과 36개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
34479      proc sort data=EMWS6.Neural_PLOTDS;
MPRINT(EM_DIAGRAM):   proc sort data=EMWS6.Neural_PLOTDS;
34480      by _ITER_;
MPRINT(EM_DIAGRAM):   by _ITER_;
34481      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 52개의 관측값을 데이터셋 EMWS6.NEURAL_PLOTDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_PLOTDS은(는) 52개의 관측값과 36개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
34482      data tempweight (drop= _tech_ _decay_ _seed_ _nobj_ _obj_ _objerr_ _averr_ _p_num_ where=(_type_ eq "PARMS" and _iter_ eq 1) );
MPRINT(EM_DIAGRAM):    data tempweight (drop= _tech_ _decay_ _seed_ _nobj_ _obj_ _objerr_ _averr_ _p_num_ where=(_type_ eq "PARMS" and _iter_ eq 1) );
34483      set EMWS6.Neural_EMESTIMATE;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_EMESTIMATE;
34484      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 52개의 관측값을 데이터셋 EMWS6.NEURAL_EMESTIMATE.에서 읽었습니다.
NOTE: 데이터셋 WORK.TEMPWEIGHT은(는) 1개의 관측값과 98개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
34485      proc sort;
MPRINT(EM_DIAGRAM):   proc sort;
34486      by _name_;
MPRINT(EM_DIAGRAM):   by _name_;
34487      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 1개의 관측값을 데이터셋 WORK.TEMPWEIGHT.에서 읽었습니다.
NOTE: 데이터셋 WORK.TEMPWEIGHT은(는) 1개의 관측값과 98개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
34488      proc transpose data=tempweight out=EMWS6.Neural_WEIGHTDS;
MPRINT(EM_DIAGRAM):   proc transpose data=tempweight out=EMWS6.Neural_WEIGHTDS;
34489      by _name_;
MPRINT(EM_DIAGRAM):   by _name_;
34490      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 1개의 관측값을 데이터셋 WORK.TEMPWEIGHT.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_WEIGHTDS은(는) 96개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
34491      data EMWS6.Neural_WEIGHTDS;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_WEIGHTDS;
34492      set EMWS6.Neural_WEIGHTDS;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_WEIGHTDS;
34493      FROM = trim(left(scan(_LABEL_, 1, '->')));
MPRINT(EM_DIAGRAM):   FROM = trim(left(scan(_LABEL_, 1, '->')));
34494      TO = trim(left(scan(_LABEL_, 2, '>')));
MPRINT(EM_DIAGRAM):   TO = trim(left(scan(_LABEL_, 2, '>')));
34495      WEIGHT = COL1;
MPRINT(EM_DIAGRAM):   WEIGHT = COL1;
34496      if (TO eq '') or (FROM eq '') then delete;
MPRINT(EM_DIAGRAM):   if (TO eq '') or (FROM eq '') then delete;
34497      label _LABEL_ ="%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel  , NOQUOTE))" FROM = "%sysfunc(sasmsg(sashelp.dmine, rpt_from_vlabel  , NOQUOTE))" TO = "%sysfunc(sasmsg(sashelp.dmine, rpt_into_vlabel  , NOQUOTE))" WEIGHT =
34498         "%sysfunc(sasmsg(sashelp.dmine, rpt_weight_vlabel  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   label _LABEL_ = "레이블" FROM = "From" TO = "Into" WEIGHT = "가중치";
34499      keep FROM TO WEIGHT _LABEL_;
MPRINT(EM_DIAGRAM):   keep FROM TO WEIGHT _LABEL_;
34500      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 96개의 관측값을 데이터셋 EMWS6.NEURAL_WEIGHTDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_WEIGHTDS은(는) 91개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
34501      proc sort data=EMWS6.Neural_WEIGHTDS nodupkey;
MPRINT(EM_DIAGRAM):   proc sort data=EMWS6.Neural_WEIGHTDS nodupkey;
34502      by _LABEL_;
MPRINT(EM_DIAGRAM):   by _LABEL_;
34503      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 91개의 관측값을 데이터셋 EMWS6.NEURAL_WEIGHTDS.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 0개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_WEIGHTDS은(는) 91개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 20일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "10시00분46초" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 스코어 로그";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* 스코어 로그
날짜:                2018년 11월 20일
시간:                10시00분46초
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O0VUYT8N "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O0VUYT8N new;
MPRINT(EM_DIAGRAM):   run;
34605      data work.outkey;
MPRINT(EM_DIAGRAM):    data work.outkey;
34606      set EMWS6.Neural_OUTKEY;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_OUTKEY;
34607      if upcase(ROLE) in('HIDDEN', 'STANDARD');
MPRINT(EM_DIAGRAM):   if upcase(ROLE) in('HIDDEN', 'STANDARD');
34608      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 43개의 관측값을 데이터셋 EMWS6.NEURAL_OUTKEY.에서 읽었습니다.
NOTE: 데이터셋 WORK.OUTKEY은(는) 10개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
34609      filename emflow "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMFLOWSCORE.sas";
MPRINT(EM_DIAGRAM):    filename emflow "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMFLOWSCORE.sas";
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Neural: Scoring DATA data;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
34610      *------------------------------------------------------------*;
34611      * Neural: Scoring DATA data;
34612      *------------------------------------------------------------*;
34613      data EMWS6.Neural_TRAIN
34614      / view=EMWS6.Neural_TRAIN
34615      ;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_TRAIN / view=EMWS6.Neural_TRAIN ;
34616      set EMWS6.Part_TRAIN
34617      ;
MPRINT(EM_DIAGRAM):   set EMWS6.Part_TRAIN ;
34618      %inc emflow;
MPRINT(EM_DIAGRAM):   ***********************************;
MPRINT(EM_DIAGRAM):   *** Begin Scoring Code for Neural;
MPRINT(EM_DIAGRAM):   ***********************************;
MPRINT(EM_DIAGRAM):   DROP _DM_BAD _EPS _NOCL_ _MAX_ _MAXP_ _SUM_ _NTRIALS;
MPRINT(EM_DIAGRAM):   _DM_BAD = 0;
MPRINT(EM_DIAGRAM):   _NOCL_ = .;
MPRINT(EM_DIAGRAM):   _MAX_ = .;
MPRINT(EM_DIAGRAM):   _MAXP_ = .;
MPRINT(EM_DIAGRAM):   _SUM_ = .;
MPRINT(EM_DIAGRAM):   _NTRIALS = .;
MPRINT(EM_DIAGRAM):   _EPS = 1E-10;
MPRINT(EM_DIAGRAM):   LENGTH _WARN_ $4 F_RESPOND $ 12 ;
MPRINT(EM_DIAGRAM):   label S_AGE = 'Standard: AGE' ;
MPRINT(EM_DIAGRAM):   label S_BUY12 = 'Standard: BUY12' ;
MPRINT(EM_DIAGRAM):   label S_BUY18 = 'Standard: BUY18' ;
MPRINT(EM_DIAGRAM):   label S_BUY6 = 'Standard: BUY6' ;
MPRINT(EM_DIAGRAM):   label S_FICO = 'Standard: FICO' ;
MPRINT(EM_DIAGRAM):   label S_INCOME = 'Standard: INCOME' ;
MPRINT(EM_DIAGRAM):   label S_VALUE24 = 'Standard: VALUE24' ;
MPRINT(EM_DIAGRAM):   label COA60 = 'Dummy: COA6=0' ;
MPRINT(EM_DIAGRAM):   label DISCBUY0 = 'Dummy: DISCBUY=0' ;
MPRINT(EM_DIAGRAM):   label MARRIED0 = 'Dummy: MARRIED=0' ;
MPRINT(EM_DIAGRAM):   label OWNHOME0 = 'Dummy: OWNHOME=0' ;
MPRINT(EM_DIAGRAM):   label RETURN240 = 'Dummy: RETURN24=0' ;
MPRINT(EM_DIAGRAM):   label SEXF = 'Dummy: SEX=F' ;
MPRINT(EM_DIAGRAM):   label CLIMATE10 = 'Dummy: CLIMATE=10' ;
MPRINT(EM_DIAGRAM):   label CLIMATE20 = 'Dummy: CLIMATE=20' ;
MPRINT(EM_DIAGRAM):   label LOCA = 'Dummy: LOC=A' ;
MPRINT(EM_DIAGRAM):   label LOCB = 'Dummy: LOC=B' ;
MPRINT(EM_DIAGRAM):   label LOCC = 'Dummy: LOC=C' ;
MPRINT(EM_DIAGRAM):   label LOCD = 'Dummy: LOC=D' ;
MPRINT(EM_DIAGRAM):   label LOCE = 'Dummy: LOC=E' ;
MPRINT(EM_DIAGRAM):   label LOCF = 'Dummy: LOC=F' ;
MPRINT(EM_DIAGRAM):   label LOCG = 'Dummy: LOC=G' ;
MPRINT(EM_DIAGRAM):   label ORGSRCC = 'Dummy: ORGSRC=C' ;
MPRINT(EM_DIAGRAM):   label ORGSRCD = 'Dummy: ORGSRC=D' ;
MPRINT(EM_DIAGRAM):   label ORGSRCI = 'Dummy: ORGSRC=I' ;
MPRINT(EM_DIAGRAM):   label ORGSRCO = 'Dummy: ORGSRC=O' ;
MPRINT(EM_DIAGRAM):   label ORGSRCP = 'Dummy: ORGSRC=P' ;
MPRINT(EM_DIAGRAM):   label ORGSRCR = 'Dummy: ORGSRC=R' ;
MPRINT(EM_DIAGRAM):   label H11 = 'Hidden: H1=1' ;
MPRINT(EM_DIAGRAM):   label H12 = 'Hidden: H1=2' ;
MPRINT(EM_DIAGRAM):   label H13 = 'Hidden: H1=3' ;
MPRINT(EM_DIAGRAM):   label I_RESPOND = 'Into: RESPOND' ;
MPRINT(EM_DIAGRAM):   label F_RESPOND = 'From: RESPOND' ;
MPRINT(EM_DIAGRAM):   label U_RESPOND = 'Unnormalized Into: RESPOND' ;
MPRINT(EM_DIAGRAM):   label P_RESPOND1 = 'Predicted: RESPOND=1' ;
MPRINT(EM_DIAGRAM):   label R_RESPOND1 = 'Residual: RESPOND=1' ;
MPRINT(EM_DIAGRAM):   label P_RESPOND0 = 'Predicted: RESPOND=0' ;
MPRINT(EM_DIAGRAM):   label R_RESPOND0 = 'Residual: RESPOND=0' ;
MPRINT(EM_DIAGRAM):   label _WARN_ = "Warnings";
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for COA6 ;
MPRINT(EM_DIAGRAM):   drop COA60 ;
MPRINT(EM_DIAGRAM):   if missing( COA6 ) then do;
MPRINT(EM_DIAGRAM):   COA60 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( COA6 , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   COA60 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   COA60 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   COA60 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for DISCBUY ;
MPRINT(EM_DIAGRAM):   drop DISCBUY0 ;
MPRINT(EM_DIAGRAM):   if missing( DISCBUY ) then do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( DISCBUY , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for MARRIED ;
MPRINT(EM_DIAGRAM):   drop MARRIED0 ;
MPRINT(EM_DIAGRAM):   if missing( MARRIED ) then do;
MPRINT(EM_DIAGRAM):   MARRIED0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( MARRIED , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   MARRIED0 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   MARRIED0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   MARRIED0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for OWNHOME ;
MPRINT(EM_DIAGRAM):   drop OWNHOME0 ;
MPRINT(EM_DIAGRAM):   if missing( OWNHOME ) then do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( OWNHOME , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for RETURN24 ;
MPRINT(EM_DIAGRAM):   drop RETURN240 ;
MPRINT(EM_DIAGRAM):   if missing( RETURN24 ) then do;
MPRINT(EM_DIAGRAM):   RETURN240 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( RETURN24 , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   RETURN240 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   RETURN240 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   RETURN240 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for SEX ;
MPRINT(EM_DIAGRAM):   drop SEXF ;
MPRINT(EM_DIAGRAM):   if missing( SEX ) then do;
MPRINT(EM_DIAGRAM):   SEXF = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm1 $ 1;
MPRINT(EM_DIAGRAM):   drop _dm1 ;
MPRINT(EM_DIAGRAM):   _dm1 = put( SEX , $CHAR1. );
MPRINT(DMNORMIP):   call dmnorm(_dm1,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm1 = 'M' then do;
MPRINT(EM_DIAGRAM):   SEXF = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm1 = 'F' then do;
MPRINT(EM_DIAGRAM):   SEXF = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   SEXF = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for CLIMATE ;
MPRINT(EM_DIAGRAM):   drop CLIMATE10 CLIMATE20 ;
MPRINT(EM_DIAGRAM):   if missing( CLIMATE ) then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = .;
MPRINT(EM_DIAGRAM):   CLIMATE20 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm2 $ 2;
MPRINT(EM_DIAGRAM):   drop _dm2 ;
MPRINT(EM_DIAGRAM):   _dm2 = put( CLIMATE , $CHAR2. );
MPRINT(DMNORMIP):   call dmnorm(_dm2,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm2 = '20' then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = 0;
MPRINT(EM_DIAGRAM):   CLIMATE20 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm2 = '30' then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = -1;
MPRINT(EM_DIAGRAM):   CLIMATE20 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm2 = '10' then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = 1;
MPRINT(EM_DIAGRAM):   CLIMATE20 = 0;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = .;
MPRINT(EM_DIAGRAM):   CLIMATE20 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for LOC ;
MPRINT(EM_DIAGRAM):   drop LOCA LOCB LOCC LOCD LOCE LOCF LOCG ;
MPRINT(EM_DIAGRAM):   *** encoding is sparse, initialize to zero;
MPRINT(EM_DIAGRAM):   LOCA = 0;
MPRINT(EM_DIAGRAM):   LOCB = 0;
MPRINT(EM_DIAGRAM):   LOCC = 0;
MPRINT(EM_DIAGRAM):   LOCD = 0;
MPRINT(EM_DIAGRAM):   LOCE = 0;
MPRINT(EM_DIAGRAM):   LOCF = 0;
MPRINT(EM_DIAGRAM):   LOCG = 0;
MPRINT(EM_DIAGRAM):   if missing( LOC ) then do;
MPRINT(EM_DIAGRAM):   LOCA = .;
MPRINT(EM_DIAGRAM):   LOCB = .;
MPRINT(EM_DIAGRAM):   LOCC = .;
MPRINT(EM_DIAGRAM):   LOCD = .;
MPRINT(EM_DIAGRAM):   LOCE = .;
MPRINT(EM_DIAGRAM):   LOCF = .;
MPRINT(EM_DIAGRAM):   LOCG = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm1 $ 1;
MPRINT(EM_DIAGRAM):   drop _dm1 ;
MPRINT(EM_DIAGRAM):   _dm1 = put( LOC , $CHAR1. );
MPRINT(DMNORMIP):   call dmnorm(_dm1,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   _dm_find = 0;
MPRINT(EM_DIAGRAM):   drop _dm_find;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'D' then do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'B' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'A' then do;
MPRINT(EM_DIAGRAM):   LOCA = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'B' then do;
MPRINT(EM_DIAGRAM):   LOCB = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'C' then do;
MPRINT(EM_DIAGRAM):   LOCC = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'D' then do;
MPRINT(EM_DIAGRAM):   LOCD = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'F' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'E' then do;
MPRINT(EM_DIAGRAM):   LOCE = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'F' then do;
MPRINT(EM_DIAGRAM):   LOCF = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'G' then do;
MPRINT(EM_DIAGRAM):   LOCG = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'H' then do;
MPRINT(EM_DIAGRAM):   LOCA = -1;
MPRINT(EM_DIAGRAM):   LOCB = -1;
MPRINT(EM_DIAGRAM):   LOCC = -1;
MPRINT(EM_DIAGRAM):   LOCD = -1;
MPRINT(EM_DIAGRAM):   LOCE = -1;
MPRINT(EM_DIAGRAM):   LOCF = -1;
MPRINT(EM_DIAGRAM):   LOCG = -1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   if not _dm_find then do;
MPRINT(EM_DIAGRAM):   LOCA = .;
MPRINT(EM_DIAGRAM):   LOCB = .;
MPRINT(EM_DIAGRAM):   LOCC = .;
MPRINT(EM_DIAGRAM):   LOCD = .;
MPRINT(EM_DIAGRAM):   LOCE = .;
MPRINT(EM_DIAGRAM):   LOCF = .;
MPRINT(EM_DIAGRAM):   LOCG = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for ORGSRC ;
MPRINT(EM_DIAGRAM):   drop ORGSRCC ORGSRCD ORGSRCI ORGSRCO ORGSRCP ORGSRCR ;
MPRINT(EM_DIAGRAM):   *** encoding is sparse, initialize to zero;
MPRINT(EM_DIAGRAM):   ORGSRCC = 0;
MPRINT(EM_DIAGRAM):   ORGSRCD = 0;
MPRINT(EM_DIAGRAM):   ORGSRCI = 0;
MPRINT(EM_DIAGRAM):   ORGSRCO = 0;
MPRINT(EM_DIAGRAM):   ORGSRCP = 0;
MPRINT(EM_DIAGRAM):   ORGSRCR = 0;
MPRINT(EM_DIAGRAM):   if missing( ORGSRC ) then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = .;
MPRINT(EM_DIAGRAM):   ORGSRCD = .;
MPRINT(EM_DIAGRAM):   ORGSRCI = .;
MPRINT(EM_DIAGRAM):   ORGSRCO = .;
MPRINT(EM_DIAGRAM):   ORGSRCP = .;
MPRINT(EM_DIAGRAM):   ORGSRCR = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm1 $ 1;
MPRINT(EM_DIAGRAM):   drop _dm1 ;
MPRINT(EM_DIAGRAM):   _dm1 = put( ORGSRC , $CHAR1. );
MPRINT(DMNORMIP):   call dmnorm(_dm1,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   _dm_find = 0;
MPRINT(EM_DIAGRAM):   drop _dm_find;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'O' then do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'D' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'C' then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'D' then do;
MPRINT(EM_DIAGRAM):   ORGSRCD = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'I' then do;
MPRINT(EM_DIAGRAM):   ORGSRCI = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'O' then do;
MPRINT(EM_DIAGRAM):   ORGSRCO = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'R' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'P' then do;
MPRINT(EM_DIAGRAM):   ORGSRCP = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'R' then do;
MPRINT(EM_DIAGRAM):   ORGSRCR = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'U' then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = -1;
MPRINT(EM_DIAGRAM):   ORGSRCD = -1;
MPRINT(EM_DIAGRAM):   ORGSRCI = -1;
MPRINT(EM_DIAGRAM):   ORGSRCO = -1;
MPRINT(EM_DIAGRAM):   ORGSRCP = -1;
MPRINT(EM_DIAGRAM):   ORGSRCR = -1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   if not _dm_find then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = .;
MPRINT(EM_DIAGRAM):   ORGSRCD = .;
MPRINT(EM_DIAGRAM):   ORGSRCI = .;
MPRINT(EM_DIAGRAM):   ORGSRCO = .;
MPRINT(EM_DIAGRAM):   ORGSRCP = .;
MPRINT(EM_DIAGRAM):   ORGSRCR = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Checking missing input Interval *** *************************;
MPRINT(EM_DIAGRAM):   IF NMISS( AGE , BUY12 , BUY18 , BUY6 , FICO , INCOME , VALUE24 ) THEN DO;
MPRINT(EM_DIAGRAM):   SUBSTR(_WARN_, 1, 1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node intvl ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 0 THEN DO;
MPRINT(EM_DIAGRAM):   S_AGE = -4.41220858751264 + 0.09911431652588 * AGE ;
MPRINT(EM_DIAGRAM):   S_BUY12 = -0.47495016976613 + 2.34774502953616 * BUY12 ;
MPRINT(EM_DIAGRAM):   S_BUY18 = -0.59899695416057 + 1.75743860578732 * BUY18 ;
MPRINT(EM_DIAGRAM):   S_BUY6 = -0.35938865799343 + 2.96941165974324 * BUY6 ;
MPRINT(EM_DIAGRAM):   S_FICO = -23.7003109498374 + 0.03411600761233 * FICO ;
MPRINT(EM_DIAGRAM):   S_INCOME = -2.9309588225649 + 0.06162016678243 * INCOME ;
MPRINT(EM_DIAGRAM):   S_VALUE24 = -1.65368962520984 + 0.00645651495403 * VALUE24 ;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ELSE DO;
MPRINT(EM_DIAGRAM):   IF MISSING( AGE ) THEN S_AGE = . ;
MPRINT(EM_DIAGRAM):   ELSE S_AGE = -4.41220858751264 + 0.09911431652588 * AGE ;
MPRINT(EM_DIAGRAM):   IF MISSING( BUY12 ) THEN S_BUY12 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_BUY12 = -0.47495016976613 + 2.34774502953616 * BUY12 ;
MPRINT(EM_DIAGRAM):   IF MISSING( BUY18 ) THEN S_BUY18 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_BUY18 = -0.59899695416057 + 1.75743860578732 * BUY18 ;
MPRINT(EM_DIAGRAM):   IF MISSING( BUY6 ) THEN S_BUY6 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_BUY6 = -0.35938865799343 + 2.96941165974324 * BUY6 ;
MPRINT(EM_DIAGRAM):   IF MISSING( FICO ) THEN S_FICO = . ;
MPRINT(EM_DIAGRAM):   ELSE S_FICO = -23.7003109498374 + 0.03411600761233 * FICO ;
MPRINT(EM_DIAGRAM):   IF MISSING( INCOME ) THEN S_INCOME = . ;
MPRINT(EM_DIAGRAM):   ELSE S_INCOME = -2.9309588225649 + 0.06162016678243 * INCOME ;
MPRINT(EM_DIAGRAM):   IF MISSING( VALUE24 ) THEN S_VALUE24 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_VALUE24 = -1.65368962520984 + 0.00645651495403 * VALUE24 ;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node bin ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node nom ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node H1 ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 0 THEN DO;
MPRINT(EM_DIAGRAM):   H11 = -1.63844613947577 * S_AGE + -0.0006834495316 * S_BUY12 + -1.11920941857236 * S_BUY18 + -0.15449094415096 * S_BUY6 + -0.36108421052445 * S_FICO + 0.29193651520759 * S_INCOME + -0.53974295029901 * S_VALUE24 ;
MPRINT(EM_DIAGRAM):   H12 = 2.04070186234985 * S_AGE + -0.82334081428811 * S_BUY12 + 0.91553224280882 * S_BUY18 + -0.50033050635957 * S_BUY6 + -1.43166253029579 * S_FICO + 1.53196393911802 * S_INCOME + 1.17270711955564 * S_VALUE24 ;
MPRINT(EM_DIAGRAM):   H13 = 0.84574733578473 * S_AGE + 0.18802877429238 * S_BUY12 + -1.89191139981326 * S_BUY18 + 0.20058908494166 * S_BUY6 + -0.01161876595264 * S_FICO + 1.03788205942031 * S_INCOME + -0.04924604220188 * S_VALUE24 ;
MPRINT(EM_DIAGRAM):   H11 = H11 + -0.1988644311203 * COA60 + 0.68224787732582 * DISCBUY0 + -1.53390155389653 * MARRIED0 + 2.00437791742167 * OWNHOME0 + 0.88877058553497 * RETURN240 + -0.90483360227295 * SEXF ;
MPRINT(EM_DIAGRAM):   H12 = H12 + -0.37262471971785 * COA60 + -0.2049179662907 * DISCBUY0 + 0.10126199387394 * MARRIED0 + -1.51051913605472 * OWNHOME0 + -1.67939230329831 * RETURN240 + 0.0498695322584 * SEXF ;
MPRINT(EM_DIAGRAM):   H13 = H13 + 0.86228008872216 * COA60 + 0.61114127966391 * DISCBUY0 + 0.04574756543432 * MARRIED0 + 0.55158128240389 * OWNHOME0 + 0.19412426500861 * RETURN240 + -0.56321531111583 * SEXF ;
MPRINT(EM_DIAGRAM):   H11 = H11 + 1.1818176049225 * CLIMATE10 + -1.32058220720595 * CLIMATE20 + -0.58467627942889 * LOCA + -0.68972041678241 * LOCB + 0.30774237767357 * LOCC + 1.53078886973103 * LOCD + -0.34280592357562 * LOCE + -0.83618623857709 * LOCF +
0.01349481352948 * LOCG + -1.16955338386382 * ORGSRCC + 0.2455345729593 * ORGSRCD + 1.08120148293387 * ORGSRCI + -0.88297036165384 * ORGSRCO + 1.00916264530826 * ORGSRCP + 0.9602561921295 * ORGSRCR ;
MPRINT(EM_DIAGRAM):   H12 = H12 + -0.12745978178409 * CLIMATE10 + -1.00277157738408 * CLIMATE20 + -0.98868063297518 * LOCA + -0.96820178142632 * LOCB + 2.34325778788059 * LOCC + -0.45228620744141 * LOCD + 0.33681000164501 * LOCE + -0.53346358071112 * LOCF
+ 0.07322369931179 * LOCG + 0.71346080215181 * ORGSRCC + -0.15781793379033 * ORGSRCD + -4.85198276807088 * ORGSRCI + 1.76010505508802 * ORGSRCO + 1.22048952682581 * ORGSRCP + 1.46892428056809 * ORGSRCR ;
MPRINT(EM_DIAGRAM):   H13 = H13 + 0.09097091651634 * CLIMATE10 + -0.3965639355109 * CLIMATE20 + -0.50515435042955 * LOCA + -0.6025682016322 * LOCB + -0.21236281616384 * LOCC + -0.65003155376952 * LOCD + 0.75926680476961 * LOCE + -0.60543681094647 * LOCF +
-0.26230283406764 * LOCG + -0.73511454268996 * ORGSRCC + 0.75076149399272 * ORGSRCD + 0.32730886330929 * ORGSRCI + -0.05672858974123 * ORGSRCO + -0.33079089144214 * ORGSRCP + 1.35547292991141 * ORGSRCR ;
MPRINT(EM_DIAGRAM):   H11 = 1.94012350352894 + H11 ;
MPRINT(EM_DIAGRAM):   H12 = -3.49518156519206 + H12 ;
MPRINT(EM_DIAGRAM):   H13 = 1.19970335108207 + H13 ;
MPRINT(EM_DIAGRAM):   H11 = TANH(H11 );
MPRINT(EM_DIAGRAM):   H12 = TANH(H12 );
MPRINT(EM_DIAGRAM):   H13 = TANH(H13 );
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ELSE DO;
MPRINT(EM_DIAGRAM):   H11 = .;
MPRINT(EM_DIAGRAM):   H12 = .;
MPRINT(EM_DIAGRAM):   H13 = .;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node RESPOND ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for RESPOND ;
MPRINT(EM_DIAGRAM):   drop RESPOND1 RESPOND0 ;
MPRINT(EM_DIAGRAM):   label F_RESPOND = 'From: RESPOND' ;
MPRINT(EM_DIAGRAM):   length F_RESPOND $ 12;
MPRINT(EM_DIAGRAM):   F_RESPOND = put( RESPOND , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(F_RESPOND,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if missing( RESPOND ) then do;
MPRINT(EM_DIAGRAM):   RESPOND1 = .;
MPRINT(EM_DIAGRAM):   RESPOND0 = .;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if F_RESPOND = '0' then do;
MPRINT(EM_DIAGRAM):   RESPOND1 = 0;
MPRINT(EM_DIAGRAM):   RESPOND0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if F_RESPOND = '1' then do;
MPRINT(EM_DIAGRAM):   RESPOND1 = 1;
MPRINT(EM_DIAGRAM):   RESPOND0 = 0;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   RESPOND1 = .;
MPRINT(EM_DIAGRAM):   RESPOND0 = .;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 0 THEN DO;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = 1.24114471688656 * H11 + 0.68120616904803 * H12 + -1.0075458443965 * H13 ;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = -2.2955746741664 + P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = 0;
MPRINT(EM_DIAGRAM):   _MAX_ = MAX (P_RESPOND1 , P_RESPOND0 );
MPRINT(EM_DIAGRAM):   _SUM_ = 0.;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = EXP(P_RESPOND1 - _MAX_);
MPRINT(EM_DIAGRAM):   _SUM_ = _SUM_ + P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = EXP(P_RESPOND0 - _MAX_);
MPRINT(EM_DIAGRAM):   _SUM_ = _SUM_ + P_RESPOND0 ;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = P_RESPOND1 / _SUM_;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = P_RESPOND0 / _SUM_;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ELSE DO;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = .;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = .;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 1 THEN DO;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = 0.07431340872374;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = 0.92568659127625;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *****************************;
MPRINT(EM_DIAGRAM):   *** Writing the Residuals of the Node RESPOND ;
MPRINT(EM_DIAGRAM):   *** ******************************;
MPRINT(EM_DIAGRAM):   IF MISSING( RESPOND1 ) THEN R_RESPOND1 = . ;
MPRINT(EM_DIAGRAM):   ELSE R_RESPOND1 = RESPOND1 - P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   IF MISSING( RESPOND0 ) THEN R_RESPOND0 = . ;
MPRINT(EM_DIAGRAM):   ELSE R_RESPOND0 = RESPOND0 - P_RESPOND0 ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the I_RESPOND AND U_RESPOND ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   _MAXP_ = P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   I_RESPOND = "1           " ;
MPRINT(EM_DIAGRAM):   U_RESPOND = 1;
MPRINT(EM_DIAGRAM):   IF( _MAXP_ LT P_RESPOND0 ) THEN DO;
MPRINT(EM_DIAGRAM):   _MAXP_ = P_RESPOND0 ;
MPRINT(EM_DIAGRAM):   I_RESPOND = "0           " ;
MPRINT(EM_DIAGRAM):   U_RESPOND = 0;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ********************************;
MPRINT(EM_DIAGRAM):   *** End Scoring Code for Neural;
MPRINT(EM_DIAGRAM):   ********************************;
MPRINT(EM_DIAGRAM):   drop S_AGE S_BUY12 S_BUY18 S_BUY6 S_FICO S_INCOME S_VALUE24 H11 H12 H13 ;
MPRINT(EM_DIAGRAM):   run;
35268      run;
 
NOTE: DATA STEP 뷰가 파일 EMWS6.NEURAL_TRAIN에 저장되었습니다.
NOTE: 저장된 DATA STEP 뷰는 다른 운영 체제에서 실행할 수 없습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
 
 
MPRINT(EM_DIAGRAM):   quit;
35269      quit;
35270      filename emflow;
MPRINT(EM_DIAGRAM):   filename emflow;
NOTE: Fileref EMFLOW을(를) 삭제했습니다.
35271      filename emflow "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMFLOWSCORE.sas";
MPRINT(EM_DIAGRAM):    filename emflow "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMFLOWSCORE.sas";
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Neural: Scoring VALIDATE data;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35272      *------------------------------------------------------------*;
35273      * Neural: Scoring VALIDATE data;
35274      *------------------------------------------------------------*;
35275      data EMWS6.Neural_VALIDATE
35276      / view=EMWS6.Neural_VALIDATE
35277      ;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_VALIDATE / view=EMWS6.Neural_VALIDATE ;
35278      set EMWS6.Part_VALIDATE
35279      ;
MPRINT(EM_DIAGRAM):   set EMWS6.Part_VALIDATE ;
35280      %inc emflow;
MPRINT(EM_DIAGRAM):   ***********************************;
MPRINT(EM_DIAGRAM):   *** Begin Scoring Code for Neural;
MPRINT(EM_DIAGRAM):   ***********************************;
MPRINT(EM_DIAGRAM):   DROP _DM_BAD _EPS _NOCL_ _MAX_ _MAXP_ _SUM_ _NTRIALS;
MPRINT(EM_DIAGRAM):   _DM_BAD = 0;
MPRINT(EM_DIAGRAM):   _NOCL_ = .;
MPRINT(EM_DIAGRAM):   _MAX_ = .;
MPRINT(EM_DIAGRAM):   _MAXP_ = .;
MPRINT(EM_DIAGRAM):   _SUM_ = .;
MPRINT(EM_DIAGRAM):   _NTRIALS = .;
MPRINT(EM_DIAGRAM):   _EPS = 1E-10;
MPRINT(EM_DIAGRAM):   LENGTH _WARN_ $4 F_RESPOND $ 12 ;
MPRINT(EM_DIAGRAM):   label S_AGE = 'Standard: AGE' ;
MPRINT(EM_DIAGRAM):   label S_BUY12 = 'Standard: BUY12' ;
MPRINT(EM_DIAGRAM):   label S_BUY18 = 'Standard: BUY18' ;
MPRINT(EM_DIAGRAM):   label S_BUY6 = 'Standard: BUY6' ;
MPRINT(EM_DIAGRAM):   label S_FICO = 'Standard: FICO' ;
MPRINT(EM_DIAGRAM):   label S_INCOME = 'Standard: INCOME' ;
MPRINT(EM_DIAGRAM):   label S_VALUE24 = 'Standard: VALUE24' ;
MPRINT(EM_DIAGRAM):   label COA60 = 'Dummy: COA6=0' ;
MPRINT(EM_DIAGRAM):   label DISCBUY0 = 'Dummy: DISCBUY=0' ;
MPRINT(EM_DIAGRAM):   label MARRIED0 = 'Dummy: MARRIED=0' ;
MPRINT(EM_DIAGRAM):   label OWNHOME0 = 'Dummy: OWNHOME=0' ;
MPRINT(EM_DIAGRAM):   label RETURN240 = 'Dummy: RETURN24=0' ;
MPRINT(EM_DIAGRAM):   label SEXF = 'Dummy: SEX=F' ;
MPRINT(EM_DIAGRAM):   label CLIMATE10 = 'Dummy: CLIMATE=10' ;
MPRINT(EM_DIAGRAM):   label CLIMATE20 = 'Dummy: CLIMATE=20' ;
MPRINT(EM_DIAGRAM):   label LOCA = 'Dummy: LOC=A' ;
MPRINT(EM_DIAGRAM):   label LOCB = 'Dummy: LOC=B' ;
MPRINT(EM_DIAGRAM):   label LOCC = 'Dummy: LOC=C' ;
MPRINT(EM_DIAGRAM):   label LOCD = 'Dummy: LOC=D' ;
MPRINT(EM_DIAGRAM):   label LOCE = 'Dummy: LOC=E' ;
MPRINT(EM_DIAGRAM):   label LOCF = 'Dummy: LOC=F' ;
MPRINT(EM_DIAGRAM):   label LOCG = 'Dummy: LOC=G' ;
MPRINT(EM_DIAGRAM):   label ORGSRCC = 'Dummy: ORGSRC=C' ;
MPRINT(EM_DIAGRAM):   label ORGSRCD = 'Dummy: ORGSRC=D' ;
MPRINT(EM_DIAGRAM):   label ORGSRCI = 'Dummy: ORGSRC=I' ;
MPRINT(EM_DIAGRAM):   label ORGSRCO = 'Dummy: ORGSRC=O' ;
MPRINT(EM_DIAGRAM):   label ORGSRCP = 'Dummy: ORGSRC=P' ;
MPRINT(EM_DIAGRAM):   label ORGSRCR = 'Dummy: ORGSRC=R' ;
MPRINT(EM_DIAGRAM):   label H11 = 'Hidden: H1=1' ;
MPRINT(EM_DIAGRAM):   label H12 = 'Hidden: H1=2' ;
MPRINT(EM_DIAGRAM):   label H13 = 'Hidden: H1=3' ;
MPRINT(EM_DIAGRAM):   label I_RESPOND = 'Into: RESPOND' ;
MPRINT(EM_DIAGRAM):   label F_RESPOND = 'From: RESPOND' ;
MPRINT(EM_DIAGRAM):   label U_RESPOND = 'Unnormalized Into: RESPOND' ;
MPRINT(EM_DIAGRAM):   label P_RESPOND1 = 'Predicted: RESPOND=1' ;
MPRINT(EM_DIAGRAM):   label R_RESPOND1 = 'Residual: RESPOND=1' ;
MPRINT(EM_DIAGRAM):   label P_RESPOND0 = 'Predicted: RESPOND=0' ;
MPRINT(EM_DIAGRAM):   label R_RESPOND0 = 'Residual: RESPOND=0' ;
MPRINT(EM_DIAGRAM):   label _WARN_ = "Warnings";
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for COA6 ;
MPRINT(EM_DIAGRAM):   drop COA60 ;
MPRINT(EM_DIAGRAM):   if missing( COA6 ) then do;
MPRINT(EM_DIAGRAM):   COA60 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( COA6 , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   COA60 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   COA60 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   COA60 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for DISCBUY ;
MPRINT(EM_DIAGRAM):   drop DISCBUY0 ;
MPRINT(EM_DIAGRAM):   if missing( DISCBUY ) then do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( DISCBUY , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for MARRIED ;
MPRINT(EM_DIAGRAM):   drop MARRIED0 ;
MPRINT(EM_DIAGRAM):   if missing( MARRIED ) then do;
MPRINT(EM_DIAGRAM):   MARRIED0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( MARRIED , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   MARRIED0 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   MARRIED0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   MARRIED0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for OWNHOME ;
MPRINT(EM_DIAGRAM):   drop OWNHOME0 ;
MPRINT(EM_DIAGRAM):   if missing( OWNHOME ) then do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( OWNHOME , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for RETURN24 ;
MPRINT(EM_DIAGRAM):   drop RETURN240 ;
MPRINT(EM_DIAGRAM):   if missing( RETURN24 ) then do;
MPRINT(EM_DIAGRAM):   RETURN240 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( RETURN24 , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   RETURN240 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   RETURN240 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   RETURN240 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for SEX ;
MPRINT(EM_DIAGRAM):   drop SEXF ;
MPRINT(EM_DIAGRAM):   if missing( SEX ) then do;
MPRINT(EM_DIAGRAM):   SEXF = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm1 $ 1;
MPRINT(EM_DIAGRAM):   drop _dm1 ;
MPRINT(EM_DIAGRAM):   _dm1 = put( SEX , $CHAR1. );
MPRINT(DMNORMIP):   call dmnorm(_dm1,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm1 = 'M' then do;
MPRINT(EM_DIAGRAM):   SEXF = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm1 = 'F' then do;
MPRINT(EM_DIAGRAM):   SEXF = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   SEXF = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for CLIMATE ;
MPRINT(EM_DIAGRAM):   drop CLIMATE10 CLIMATE20 ;
MPRINT(EM_DIAGRAM):   if missing( CLIMATE ) then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = .;
MPRINT(EM_DIAGRAM):   CLIMATE20 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm2 $ 2;
MPRINT(EM_DIAGRAM):   drop _dm2 ;
MPRINT(EM_DIAGRAM):   _dm2 = put( CLIMATE , $CHAR2. );
MPRINT(DMNORMIP):   call dmnorm(_dm2,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm2 = '20' then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = 0;
MPRINT(EM_DIAGRAM):   CLIMATE20 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm2 = '30' then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = -1;
MPRINT(EM_DIAGRAM):   CLIMATE20 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm2 = '10' then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = 1;
MPRINT(EM_DIAGRAM):   CLIMATE20 = 0;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = .;
MPRINT(EM_DIAGRAM):   CLIMATE20 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for LOC ;
MPRINT(EM_DIAGRAM):   drop LOCA LOCB LOCC LOCD LOCE LOCF LOCG ;
MPRINT(EM_DIAGRAM):   *** encoding is sparse, initialize to zero;
MPRINT(EM_DIAGRAM):   LOCA = 0;
MPRINT(EM_DIAGRAM):   LOCB = 0;
MPRINT(EM_DIAGRAM):   LOCC = 0;
MPRINT(EM_DIAGRAM):   LOCD = 0;
MPRINT(EM_DIAGRAM):   LOCE = 0;
MPRINT(EM_DIAGRAM):   LOCF = 0;
MPRINT(EM_DIAGRAM):   LOCG = 0;
MPRINT(EM_DIAGRAM):   if missing( LOC ) then do;
MPRINT(EM_DIAGRAM):   LOCA = .;
MPRINT(EM_DIAGRAM):   LOCB = .;
MPRINT(EM_DIAGRAM):   LOCC = .;
MPRINT(EM_DIAGRAM):   LOCD = .;
MPRINT(EM_DIAGRAM):   LOCE = .;
MPRINT(EM_DIAGRAM):   LOCF = .;
MPRINT(EM_DIAGRAM):   LOCG = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm1 $ 1;
MPRINT(EM_DIAGRAM):   drop _dm1 ;
MPRINT(EM_DIAGRAM):   _dm1 = put( LOC , $CHAR1. );
MPRINT(DMNORMIP):   call dmnorm(_dm1,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   _dm_find = 0;
MPRINT(EM_DIAGRAM):   drop _dm_find;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'D' then do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'B' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'A' then do;
MPRINT(EM_DIAGRAM):   LOCA = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'B' then do;
MPRINT(EM_DIAGRAM):   LOCB = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'C' then do;
MPRINT(EM_DIAGRAM):   LOCC = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'D' then do;
MPRINT(EM_DIAGRAM):   LOCD = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'F' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'E' then do;
MPRINT(EM_DIAGRAM):   LOCE = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'F' then do;
MPRINT(EM_DIAGRAM):   LOCF = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'G' then do;
MPRINT(EM_DIAGRAM):   LOCG = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'H' then do;
MPRINT(EM_DIAGRAM):   LOCA = -1;
MPRINT(EM_DIAGRAM):   LOCB = -1;
MPRINT(EM_DIAGRAM):   LOCC = -1;
MPRINT(EM_DIAGRAM):   LOCD = -1;
MPRINT(EM_DIAGRAM):   LOCE = -1;
MPRINT(EM_DIAGRAM):   LOCF = -1;
MPRINT(EM_DIAGRAM):   LOCG = -1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   if not _dm_find then do;
MPRINT(EM_DIAGRAM):   LOCA = .;
MPRINT(EM_DIAGRAM):   LOCB = .;
MPRINT(EM_DIAGRAM):   LOCC = .;
MPRINT(EM_DIAGRAM):   LOCD = .;
MPRINT(EM_DIAGRAM):   LOCE = .;
MPRINT(EM_DIAGRAM):   LOCF = .;
MPRINT(EM_DIAGRAM):   LOCG = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for ORGSRC ;
MPRINT(EM_DIAGRAM):   drop ORGSRCC ORGSRCD ORGSRCI ORGSRCO ORGSRCP ORGSRCR ;
MPRINT(EM_DIAGRAM):   *** encoding is sparse, initialize to zero;
MPRINT(EM_DIAGRAM):   ORGSRCC = 0;
MPRINT(EM_DIAGRAM):   ORGSRCD = 0;
MPRINT(EM_DIAGRAM):   ORGSRCI = 0;
MPRINT(EM_DIAGRAM):   ORGSRCO = 0;
MPRINT(EM_DIAGRAM):   ORGSRCP = 0;
MPRINT(EM_DIAGRAM):   ORGSRCR = 0;
MPRINT(EM_DIAGRAM):   if missing( ORGSRC ) then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = .;
MPRINT(EM_DIAGRAM):   ORGSRCD = .;
MPRINT(EM_DIAGRAM):   ORGSRCI = .;
MPRINT(EM_DIAGRAM):   ORGSRCO = .;
MPRINT(EM_DIAGRAM):   ORGSRCP = .;
MPRINT(EM_DIAGRAM):   ORGSRCR = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm1 $ 1;
MPRINT(EM_DIAGRAM):   drop _dm1 ;
MPRINT(EM_DIAGRAM):   _dm1 = put( ORGSRC , $CHAR1. );
MPRINT(DMNORMIP):   call dmnorm(_dm1,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   _dm_find = 0;
MPRINT(EM_DIAGRAM):   drop _dm_find;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'O' then do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'D' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'C' then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'D' then do;
MPRINT(EM_DIAGRAM):   ORGSRCD = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'I' then do;
MPRINT(EM_DIAGRAM):   ORGSRCI = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'O' then do;
MPRINT(EM_DIAGRAM):   ORGSRCO = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'R' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'P' then do;
MPRINT(EM_DIAGRAM):   ORGSRCP = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'R' then do;
MPRINT(EM_DIAGRAM):   ORGSRCR = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'U' then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = -1;
MPRINT(EM_DIAGRAM):   ORGSRCD = -1;
MPRINT(EM_DIAGRAM):   ORGSRCI = -1;
MPRINT(EM_DIAGRAM):   ORGSRCO = -1;
MPRINT(EM_DIAGRAM):   ORGSRCP = -1;
MPRINT(EM_DIAGRAM):   ORGSRCR = -1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   if not _dm_find then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = .;
MPRINT(EM_DIAGRAM):   ORGSRCD = .;
MPRINT(EM_DIAGRAM):   ORGSRCI = .;
MPRINT(EM_DIAGRAM):   ORGSRCO = .;
MPRINT(EM_DIAGRAM):   ORGSRCP = .;
MPRINT(EM_DIAGRAM):   ORGSRCR = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Checking missing input Interval *** *************************;
MPRINT(EM_DIAGRAM):   IF NMISS( AGE , BUY12 , BUY18 , BUY6 , FICO , INCOME , VALUE24 ) THEN DO;
MPRINT(EM_DIAGRAM):   SUBSTR(_WARN_, 1, 1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node intvl ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 0 THEN DO;
MPRINT(EM_DIAGRAM):   S_AGE = -4.41220858751264 + 0.09911431652588 * AGE ;
MPRINT(EM_DIAGRAM):   S_BUY12 = -0.47495016976613 + 2.34774502953616 * BUY12 ;
MPRINT(EM_DIAGRAM):   S_BUY18 = -0.59899695416057 + 1.75743860578732 * BUY18 ;
MPRINT(EM_DIAGRAM):   S_BUY6 = -0.35938865799343 + 2.96941165974324 * BUY6 ;
MPRINT(EM_DIAGRAM):   S_FICO = -23.7003109498374 + 0.03411600761233 * FICO ;
MPRINT(EM_DIAGRAM):   S_INCOME = -2.9309588225649 + 0.06162016678243 * INCOME ;
MPRINT(EM_DIAGRAM):   S_VALUE24 = -1.65368962520984 + 0.00645651495403 * VALUE24 ;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ELSE DO;
MPRINT(EM_DIAGRAM):   IF MISSING( AGE ) THEN S_AGE = . ;
MPRINT(EM_DIAGRAM):   ELSE S_AGE = -4.41220858751264 + 0.09911431652588 * AGE ;
MPRINT(EM_DIAGRAM):   IF MISSING( BUY12 ) THEN S_BUY12 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_BUY12 = -0.47495016976613 + 2.34774502953616 * BUY12 ;
MPRINT(EM_DIAGRAM):   IF MISSING( BUY18 ) THEN S_BUY18 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_BUY18 = -0.59899695416057 + 1.75743860578732 * BUY18 ;
MPRINT(EM_DIAGRAM):   IF MISSING( BUY6 ) THEN S_BUY6 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_BUY6 = -0.35938865799343 + 2.96941165974324 * BUY6 ;
MPRINT(EM_DIAGRAM):   IF MISSING( FICO ) THEN S_FICO = . ;
MPRINT(EM_DIAGRAM):   ELSE S_FICO = -23.7003109498374 + 0.03411600761233 * FICO ;
MPRINT(EM_DIAGRAM):   IF MISSING( INCOME ) THEN S_INCOME = . ;
MPRINT(EM_DIAGRAM):   ELSE S_INCOME = -2.9309588225649 + 0.06162016678243 * INCOME ;
MPRINT(EM_DIAGRAM):   IF MISSING( VALUE24 ) THEN S_VALUE24 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_VALUE24 = -1.65368962520984 + 0.00645651495403 * VALUE24 ;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node bin ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node nom ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node H1 ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 0 THEN DO;
MPRINT(EM_DIAGRAM):   H11 = -1.63844613947577 * S_AGE + -0.0006834495316 * S_BUY12 + -1.11920941857236 * S_BUY18 + -0.15449094415096 * S_BUY6 + -0.36108421052445 * S_FICO + 0.29193651520759 * S_INCOME + -0.53974295029901 * S_VALUE24 ;
MPRINT(EM_DIAGRAM):   H12 = 2.04070186234985 * S_AGE + -0.82334081428811 * S_BUY12 + 0.91553224280882 * S_BUY18 + -0.50033050635957 * S_BUY6 + -1.43166253029579 * S_FICO + 1.53196393911802 * S_INCOME + 1.17270711955564 * S_VALUE24 ;
MPRINT(EM_DIAGRAM):   H13 = 0.84574733578473 * S_AGE + 0.18802877429238 * S_BUY12 + -1.89191139981326 * S_BUY18 + 0.20058908494166 * S_BUY6 + -0.01161876595264 * S_FICO + 1.03788205942031 * S_INCOME + -0.04924604220188 * S_VALUE24 ;
MPRINT(EM_DIAGRAM):   H11 = H11 + -0.1988644311203 * COA60 + 0.68224787732582 * DISCBUY0 + -1.53390155389653 * MARRIED0 + 2.00437791742167 * OWNHOME0 + 0.88877058553497 * RETURN240 + -0.90483360227295 * SEXF ;
MPRINT(EM_DIAGRAM):   H12 = H12 + -0.37262471971785 * COA60 + -0.2049179662907 * DISCBUY0 + 0.10126199387394 * MARRIED0 + -1.51051913605472 * OWNHOME0 + -1.67939230329831 * RETURN240 + 0.0498695322584 * SEXF ;
MPRINT(EM_DIAGRAM):   H13 = H13 + 0.86228008872216 * COA60 + 0.61114127966391 * DISCBUY0 + 0.04574756543432 * MARRIED0 + 0.55158128240389 * OWNHOME0 + 0.19412426500861 * RETURN240 + -0.56321531111583 * SEXF ;
MPRINT(EM_DIAGRAM):   H11 = H11 + 1.1818176049225 * CLIMATE10 + -1.32058220720595 * CLIMATE20 + -0.58467627942889 * LOCA + -0.68972041678241 * LOCB + 0.30774237767357 * LOCC + 1.53078886973103 * LOCD + -0.34280592357562 * LOCE + -0.83618623857709 * LOCF +
0.01349481352948 * LOCG + -1.16955338386382 * ORGSRCC + 0.2455345729593 * ORGSRCD + 1.08120148293387 * ORGSRCI + -0.88297036165384 * ORGSRCO + 1.00916264530826 * ORGSRCP + 0.9602561921295 * ORGSRCR ;
MPRINT(EM_DIAGRAM):   H12 = H12 + -0.12745978178409 * CLIMATE10 + -1.00277157738408 * CLIMATE20 + -0.98868063297518 * LOCA + -0.96820178142632 * LOCB + 2.34325778788059 * LOCC + -0.45228620744141 * LOCD + 0.33681000164501 * LOCE + -0.53346358071112 * LOCF
+ 0.07322369931179 * LOCG + 0.71346080215181 * ORGSRCC + -0.15781793379033 * ORGSRCD + -4.85198276807088 * ORGSRCI + 1.76010505508802 * ORGSRCO + 1.22048952682581 * ORGSRCP + 1.46892428056809 * ORGSRCR ;
MPRINT(EM_DIAGRAM):   H13 = H13 + 0.09097091651634 * CLIMATE10 + -0.3965639355109 * CLIMATE20 + -0.50515435042955 * LOCA + -0.6025682016322 * LOCB + -0.21236281616384 * LOCC + -0.65003155376952 * LOCD + 0.75926680476961 * LOCE + -0.60543681094647 * LOCF +
-0.26230283406764 * LOCG + -0.73511454268996 * ORGSRCC + 0.75076149399272 * ORGSRCD + 0.32730886330929 * ORGSRCI + -0.05672858974123 * ORGSRCO + -0.33079089144214 * ORGSRCP + 1.35547292991141 * ORGSRCR ;
MPRINT(EM_DIAGRAM):   H11 = 1.94012350352894 + H11 ;
MPRINT(EM_DIAGRAM):   H12 = -3.49518156519206 + H12 ;
MPRINT(EM_DIAGRAM):   H13 = 1.19970335108207 + H13 ;
MPRINT(EM_DIAGRAM):   H11 = TANH(H11 );
MPRINT(EM_DIAGRAM):   H12 = TANH(H12 );
MPRINT(EM_DIAGRAM):   H13 = TANH(H13 );
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ELSE DO;
MPRINT(EM_DIAGRAM):   H11 = .;
MPRINT(EM_DIAGRAM):   H12 = .;
MPRINT(EM_DIAGRAM):   H13 = .;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node RESPOND ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for RESPOND ;
MPRINT(EM_DIAGRAM):   drop RESPOND1 RESPOND0 ;
MPRINT(EM_DIAGRAM):   label F_RESPOND = 'From: RESPOND' ;
MPRINT(EM_DIAGRAM):   length F_RESPOND $ 12;
MPRINT(EM_DIAGRAM):   F_RESPOND = put( RESPOND , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(F_RESPOND,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if missing( RESPOND ) then do;
MPRINT(EM_DIAGRAM):   RESPOND1 = .;
MPRINT(EM_DIAGRAM):   RESPOND0 = .;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if F_RESPOND = '0' then do;
MPRINT(EM_DIAGRAM):   RESPOND1 = 0;
MPRINT(EM_DIAGRAM):   RESPOND0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if F_RESPOND = '1' then do;
MPRINT(EM_DIAGRAM):   RESPOND1 = 1;
MPRINT(EM_DIAGRAM):   RESPOND0 = 0;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   RESPOND1 = .;
MPRINT(EM_DIAGRAM):   RESPOND0 = .;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 0 THEN DO;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = 1.24114471688656 * H11 + 0.68120616904803 * H12 + -1.0075458443965 * H13 ;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = -2.2955746741664 + P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = 0;
MPRINT(EM_DIAGRAM):   _MAX_ = MAX (P_RESPOND1 , P_RESPOND0 );
MPRINT(EM_DIAGRAM):   _SUM_ = 0.;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = EXP(P_RESPOND1 - _MAX_);
MPRINT(EM_DIAGRAM):   _SUM_ = _SUM_ + P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = EXP(P_RESPOND0 - _MAX_);
MPRINT(EM_DIAGRAM):   _SUM_ = _SUM_ + P_RESPOND0 ;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = P_RESPOND1 / _SUM_;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = P_RESPOND0 / _SUM_;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ELSE DO;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = .;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = .;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 1 THEN DO;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = 0.07431340872374;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = 0.92568659127625;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *****************************;
MPRINT(EM_DIAGRAM):   *** Writing the Residuals of the Node RESPOND ;
MPRINT(EM_DIAGRAM):   *** ******************************;
MPRINT(EM_DIAGRAM):   IF MISSING( RESPOND1 ) THEN R_RESPOND1 = . ;
MPRINT(EM_DIAGRAM):   ELSE R_RESPOND1 = RESPOND1 - P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   IF MISSING( RESPOND0 ) THEN R_RESPOND0 = . ;
MPRINT(EM_DIAGRAM):   ELSE R_RESPOND0 = RESPOND0 - P_RESPOND0 ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the I_RESPOND AND U_RESPOND ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   _MAXP_ = P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   I_RESPOND = "1           " ;
MPRINT(EM_DIAGRAM):   U_RESPOND = 1;
MPRINT(EM_DIAGRAM):   IF( _MAXP_ LT P_RESPOND0 ) THEN DO;
MPRINT(EM_DIAGRAM):   _MAXP_ = P_RESPOND0 ;
MPRINT(EM_DIAGRAM):   I_RESPOND = "0           " ;
MPRINT(EM_DIAGRAM):   U_RESPOND = 0;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ********************************;
MPRINT(EM_DIAGRAM):   *** End Scoring Code for Neural;
MPRINT(EM_DIAGRAM):   ********************************;
MPRINT(EM_DIAGRAM):   drop S_AGE S_BUY12 S_BUY18 S_BUY6 S_FICO S_INCOME S_VALUE24 H11 H12 H13 ;
35930      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: DATA STEP 뷰가 파일 EMWS6.NEURAL_VALIDATE에 저장되었습니다.
NOTE: 저장된 DATA STEP 뷰는 다른 운영 체제에서 실행할 수 없습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(EM_DIAGRAM):   quit;
35931      quit;
35932      filename emflow;
MPRINT(EM_DIAGRAM):   filename emflow;
NOTE: Fileref EMFLOW을(를) 삭제했습니다.
35933      filename emflow "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMFLOWSCORE.sas";
MPRINT(EM_DIAGRAM):    filename emflow "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMFLOWSCORE.sas";
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Neural: Scoring TEST data;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35934      *------------------------------------------------------------*;
35935      * Neural: Scoring TEST data;
35936      *------------------------------------------------------------*;
35937      data EMWS6.Neural_TEST
35938      / view=EMWS6.Neural_TEST
35939      ;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_TEST / view=EMWS6.Neural_TEST ;
35940      set EMWS6.Part_TEST
35941      ;
MPRINT(EM_DIAGRAM):   set EMWS6.Part_TEST ;
35942      %inc emflow;
MPRINT(EM_DIAGRAM):   ***********************************;
MPRINT(EM_DIAGRAM):   *** Begin Scoring Code for Neural;
MPRINT(EM_DIAGRAM):   ***********************************;
MPRINT(EM_DIAGRAM):   DROP _DM_BAD _EPS _NOCL_ _MAX_ _MAXP_ _SUM_ _NTRIALS;
MPRINT(EM_DIAGRAM):   _DM_BAD = 0;
MPRINT(EM_DIAGRAM):   _NOCL_ = .;
MPRINT(EM_DIAGRAM):   _MAX_ = .;
MPRINT(EM_DIAGRAM):   _MAXP_ = .;
MPRINT(EM_DIAGRAM):   _SUM_ = .;
MPRINT(EM_DIAGRAM):   _NTRIALS = .;
MPRINT(EM_DIAGRAM):   _EPS = 1E-10;
MPRINT(EM_DIAGRAM):   LENGTH _WARN_ $4 F_RESPOND $ 12 ;
MPRINT(EM_DIAGRAM):   label S_AGE = 'Standard: AGE' ;
MPRINT(EM_DIAGRAM):   label S_BUY12 = 'Standard: BUY12' ;
MPRINT(EM_DIAGRAM):   label S_BUY18 = 'Standard: BUY18' ;
MPRINT(EM_DIAGRAM):   label S_BUY6 = 'Standard: BUY6' ;
MPRINT(EM_DIAGRAM):   label S_FICO = 'Standard: FICO' ;
MPRINT(EM_DIAGRAM):   label S_INCOME = 'Standard: INCOME' ;
MPRINT(EM_DIAGRAM):   label S_VALUE24 = 'Standard: VALUE24' ;
MPRINT(EM_DIAGRAM):   label COA60 = 'Dummy: COA6=0' ;
MPRINT(EM_DIAGRAM):   label DISCBUY0 = 'Dummy: DISCBUY=0' ;
MPRINT(EM_DIAGRAM):   label MARRIED0 = 'Dummy: MARRIED=0' ;
MPRINT(EM_DIAGRAM):   label OWNHOME0 = 'Dummy: OWNHOME=0' ;
MPRINT(EM_DIAGRAM):   label RETURN240 = 'Dummy: RETURN24=0' ;
MPRINT(EM_DIAGRAM):   label SEXF = 'Dummy: SEX=F' ;
MPRINT(EM_DIAGRAM):   label CLIMATE10 = 'Dummy: CLIMATE=10' ;
MPRINT(EM_DIAGRAM):   label CLIMATE20 = 'Dummy: CLIMATE=20' ;
MPRINT(EM_DIAGRAM):   label LOCA = 'Dummy: LOC=A' ;
MPRINT(EM_DIAGRAM):   label LOCB = 'Dummy: LOC=B' ;
MPRINT(EM_DIAGRAM):   label LOCC = 'Dummy: LOC=C' ;
MPRINT(EM_DIAGRAM):   label LOCD = 'Dummy: LOC=D' ;
MPRINT(EM_DIAGRAM):   label LOCE = 'Dummy: LOC=E' ;
MPRINT(EM_DIAGRAM):   label LOCF = 'Dummy: LOC=F' ;
MPRINT(EM_DIAGRAM):   label LOCG = 'Dummy: LOC=G' ;
MPRINT(EM_DIAGRAM):   label ORGSRCC = 'Dummy: ORGSRC=C' ;
MPRINT(EM_DIAGRAM):   label ORGSRCD = 'Dummy: ORGSRC=D' ;
MPRINT(EM_DIAGRAM):   label ORGSRCI = 'Dummy: ORGSRC=I' ;
MPRINT(EM_DIAGRAM):   label ORGSRCO = 'Dummy: ORGSRC=O' ;
MPRINT(EM_DIAGRAM):   label ORGSRCP = 'Dummy: ORGSRC=P' ;
MPRINT(EM_DIAGRAM):   label ORGSRCR = 'Dummy: ORGSRC=R' ;
MPRINT(EM_DIAGRAM):   label H11 = 'Hidden: H1=1' ;
MPRINT(EM_DIAGRAM):   label H12 = 'Hidden: H1=2' ;
MPRINT(EM_DIAGRAM):   label H13 = 'Hidden: H1=3' ;
MPRINT(EM_DIAGRAM):   label I_RESPOND = 'Into: RESPOND' ;
MPRINT(EM_DIAGRAM):   label F_RESPOND = 'From: RESPOND' ;
MPRINT(EM_DIAGRAM):   label U_RESPOND = 'Unnormalized Into: RESPOND' ;
MPRINT(EM_DIAGRAM):   label P_RESPOND1 = 'Predicted: RESPOND=1' ;
MPRINT(EM_DIAGRAM):   label R_RESPOND1 = 'Residual: RESPOND=1' ;
MPRINT(EM_DIAGRAM):   label P_RESPOND0 = 'Predicted: RESPOND=0' ;
MPRINT(EM_DIAGRAM):   label R_RESPOND0 = 'Residual: RESPOND=0' ;
MPRINT(EM_DIAGRAM):   label _WARN_ = "Warnings";
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for COA6 ;
MPRINT(EM_DIAGRAM):   drop COA60 ;
MPRINT(EM_DIAGRAM):   if missing( COA6 ) then do;
MPRINT(EM_DIAGRAM):   COA60 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( COA6 , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   COA60 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   COA60 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   COA60 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for DISCBUY ;
MPRINT(EM_DIAGRAM):   drop DISCBUY0 ;
MPRINT(EM_DIAGRAM):   if missing( DISCBUY ) then do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( DISCBUY , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   DISCBUY0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for MARRIED ;
MPRINT(EM_DIAGRAM):   drop MARRIED0 ;
MPRINT(EM_DIAGRAM):   if missing( MARRIED ) then do;
MPRINT(EM_DIAGRAM):   MARRIED0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( MARRIED , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   MARRIED0 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   MARRIED0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   MARRIED0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for OWNHOME ;
MPRINT(EM_DIAGRAM):   drop OWNHOME0 ;
MPRINT(EM_DIAGRAM):   if missing( OWNHOME ) then do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( OWNHOME , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   OWNHOME0 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for RETURN24 ;
MPRINT(EM_DIAGRAM):   drop RETURN240 ;
MPRINT(EM_DIAGRAM):   if missing( RETURN24 ) then do;
MPRINT(EM_DIAGRAM):   RETURN240 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm12 $ 12;
MPRINT(EM_DIAGRAM):   drop _dm12 ;
MPRINT(EM_DIAGRAM):   _dm12 = put( RETURN24 , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(_dm12,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm12 = '0' then do;
MPRINT(EM_DIAGRAM):   RETURN240 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm12 = '1' then do;
MPRINT(EM_DIAGRAM):   RETURN240 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   RETURN240 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for SEX ;
MPRINT(EM_DIAGRAM):   drop SEXF ;
MPRINT(EM_DIAGRAM):   if missing( SEX ) then do;
MPRINT(EM_DIAGRAM):   SEXF = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm1 $ 1;
MPRINT(EM_DIAGRAM):   drop _dm1 ;
MPRINT(EM_DIAGRAM):   _dm1 = put( SEX , $CHAR1. );
MPRINT(DMNORMIP):   call dmnorm(_dm1,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm1 = 'M' then do;
MPRINT(EM_DIAGRAM):   SEXF = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm1 = 'F' then do;
MPRINT(EM_DIAGRAM):   SEXF = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   SEXF = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for CLIMATE ;
MPRINT(EM_DIAGRAM):   drop CLIMATE10 CLIMATE20 ;
MPRINT(EM_DIAGRAM):   if missing( CLIMATE ) then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = .;
MPRINT(EM_DIAGRAM):   CLIMATE20 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm2 $ 2;
MPRINT(EM_DIAGRAM):   drop _dm2 ;
MPRINT(EM_DIAGRAM):   _dm2 = put( CLIMATE , $CHAR2. );
MPRINT(DMNORMIP):   call dmnorm(_dm2,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if _dm2 = '20' then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = 0;
MPRINT(EM_DIAGRAM):   CLIMATE20 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm2 = '30' then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = -1;
MPRINT(EM_DIAGRAM):   CLIMATE20 = -1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if _dm2 = '10' then do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = 1;
MPRINT(EM_DIAGRAM):   CLIMATE20 = 0;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   CLIMATE10 = .;
MPRINT(EM_DIAGRAM):   CLIMATE20 = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for LOC ;
MPRINT(EM_DIAGRAM):   drop LOCA LOCB LOCC LOCD LOCE LOCF LOCG ;
MPRINT(EM_DIAGRAM):   *** encoding is sparse, initialize to zero;
MPRINT(EM_DIAGRAM):   LOCA = 0;
MPRINT(EM_DIAGRAM):   LOCB = 0;
MPRINT(EM_DIAGRAM):   LOCC = 0;
MPRINT(EM_DIAGRAM):   LOCD = 0;
MPRINT(EM_DIAGRAM):   LOCE = 0;
MPRINT(EM_DIAGRAM):   LOCF = 0;
MPRINT(EM_DIAGRAM):   LOCG = 0;
MPRINT(EM_DIAGRAM):   if missing( LOC ) then do;
MPRINT(EM_DIAGRAM):   LOCA = .;
MPRINT(EM_DIAGRAM):   LOCB = .;
MPRINT(EM_DIAGRAM):   LOCC = .;
MPRINT(EM_DIAGRAM):   LOCD = .;
MPRINT(EM_DIAGRAM):   LOCE = .;
MPRINT(EM_DIAGRAM):   LOCF = .;
MPRINT(EM_DIAGRAM):   LOCG = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm1 $ 1;
MPRINT(EM_DIAGRAM):   drop _dm1 ;
MPRINT(EM_DIAGRAM):   _dm1 = put( LOC , $CHAR1. );
MPRINT(DMNORMIP):   call dmnorm(_dm1,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   _dm_find = 0;
MPRINT(EM_DIAGRAM):   drop _dm_find;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'D' then do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'B' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'A' then do;
MPRINT(EM_DIAGRAM):   LOCA = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'B' then do;
MPRINT(EM_DIAGRAM):   LOCB = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'C' then do;
MPRINT(EM_DIAGRAM):   LOCC = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'D' then do;
MPRINT(EM_DIAGRAM):   LOCD = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'F' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'E' then do;
MPRINT(EM_DIAGRAM):   LOCE = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'F' then do;
MPRINT(EM_DIAGRAM):   LOCF = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'G' then do;
MPRINT(EM_DIAGRAM):   LOCG = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'H' then do;
MPRINT(EM_DIAGRAM):   LOCA = -1;
MPRINT(EM_DIAGRAM):   LOCB = -1;
MPRINT(EM_DIAGRAM):   LOCC = -1;
MPRINT(EM_DIAGRAM):   LOCD = -1;
MPRINT(EM_DIAGRAM):   LOCE = -1;
MPRINT(EM_DIAGRAM):   LOCF = -1;
MPRINT(EM_DIAGRAM):   LOCG = -1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   if not _dm_find then do;
MPRINT(EM_DIAGRAM):   LOCA = .;
MPRINT(EM_DIAGRAM):   LOCB = .;
MPRINT(EM_DIAGRAM):   LOCC = .;
MPRINT(EM_DIAGRAM):   LOCD = .;
MPRINT(EM_DIAGRAM):   LOCE = .;
MPRINT(EM_DIAGRAM):   LOCF = .;
MPRINT(EM_DIAGRAM):   LOCG = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for ORGSRC ;
MPRINT(EM_DIAGRAM):   drop ORGSRCC ORGSRCD ORGSRCI ORGSRCO ORGSRCP ORGSRCR ;
MPRINT(EM_DIAGRAM):   *** encoding is sparse, initialize to zero;
MPRINT(EM_DIAGRAM):   ORGSRCC = 0;
MPRINT(EM_DIAGRAM):   ORGSRCD = 0;
MPRINT(EM_DIAGRAM):   ORGSRCI = 0;
MPRINT(EM_DIAGRAM):   ORGSRCO = 0;
MPRINT(EM_DIAGRAM):   ORGSRCP = 0;
MPRINT(EM_DIAGRAM):   ORGSRCR = 0;
MPRINT(EM_DIAGRAM):   if missing( ORGSRC ) then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = .;
MPRINT(EM_DIAGRAM):   ORGSRCD = .;
MPRINT(EM_DIAGRAM):   ORGSRCI = .;
MPRINT(EM_DIAGRAM):   ORGSRCO = .;
MPRINT(EM_DIAGRAM):   ORGSRCP = .;
MPRINT(EM_DIAGRAM):   ORGSRCR = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,1,1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   length _dm1 $ 1;
MPRINT(EM_DIAGRAM):   drop _dm1 ;
MPRINT(EM_DIAGRAM):   _dm1 = put( ORGSRC , $CHAR1. );
MPRINT(DMNORMIP):   call dmnorm(_dm1,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   _dm_find = 0;
MPRINT(EM_DIAGRAM):   drop _dm_find;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'O' then do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'D' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'C' then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'D' then do;
MPRINT(EM_DIAGRAM):   ORGSRCD = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'I' then do;
MPRINT(EM_DIAGRAM):   ORGSRCI = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'O' then do;
MPRINT(EM_DIAGRAM):   ORGSRCO = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 <= 'R' then do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'P' then do;
MPRINT(EM_DIAGRAM):   ORGSRCP = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'R' then do;
MPRINT(EM_DIAGRAM):   ORGSRCR = 1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if _dm1 = 'U' then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = -1;
MPRINT(EM_DIAGRAM):   ORGSRCD = -1;
MPRINT(EM_DIAGRAM):   ORGSRCI = -1;
MPRINT(EM_DIAGRAM):   ORGSRCO = -1;
MPRINT(EM_DIAGRAM):   ORGSRCP = -1;
MPRINT(EM_DIAGRAM):   ORGSRCR = -1;
MPRINT(EM_DIAGRAM):   _dm_find = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   if not _dm_find then do;
MPRINT(EM_DIAGRAM):   ORGSRCC = .;
MPRINT(EM_DIAGRAM):   ORGSRCD = .;
MPRINT(EM_DIAGRAM):   ORGSRCI = .;
MPRINT(EM_DIAGRAM):   ORGSRCO = .;
MPRINT(EM_DIAGRAM):   ORGSRCP = .;
MPRINT(EM_DIAGRAM):   ORGSRCR = .;
MPRINT(EM_DIAGRAM):   substr(_warn_,2,1) = 'U';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Checking missing input Interval *** *************************;
MPRINT(EM_DIAGRAM):   IF NMISS( AGE , BUY12 , BUY18 , BUY6 , FICO , INCOME , VALUE24 ) THEN DO;
MPRINT(EM_DIAGRAM):   SUBSTR(_WARN_, 1, 1) = 'M';
MPRINT(EM_DIAGRAM):   _DM_BAD = 1;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node intvl ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 0 THEN DO;
MPRINT(EM_DIAGRAM):   S_AGE = -4.41220858751264 + 0.09911431652588 * AGE ;
MPRINT(EM_DIAGRAM):   S_BUY12 = -0.47495016976613 + 2.34774502953616 * BUY12 ;
MPRINT(EM_DIAGRAM):   S_BUY18 = -0.59899695416057 + 1.75743860578732 * BUY18 ;
MPRINT(EM_DIAGRAM):   S_BUY6 = -0.35938865799343 + 2.96941165974324 * BUY6 ;
MPRINT(EM_DIAGRAM):   S_FICO = -23.7003109498374 + 0.03411600761233 * FICO ;
MPRINT(EM_DIAGRAM):   S_INCOME = -2.9309588225649 + 0.06162016678243 * INCOME ;
MPRINT(EM_DIAGRAM):   S_VALUE24 = -1.65368962520984 + 0.00645651495403 * VALUE24 ;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ELSE DO;
MPRINT(EM_DIAGRAM):   IF MISSING( AGE ) THEN S_AGE = . ;
MPRINT(EM_DIAGRAM):   ELSE S_AGE = -4.41220858751264 + 0.09911431652588 * AGE ;
MPRINT(EM_DIAGRAM):   IF MISSING( BUY12 ) THEN S_BUY12 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_BUY12 = -0.47495016976613 + 2.34774502953616 * BUY12 ;
MPRINT(EM_DIAGRAM):   IF MISSING( BUY18 ) THEN S_BUY18 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_BUY18 = -0.59899695416057 + 1.75743860578732 * BUY18 ;
MPRINT(EM_DIAGRAM):   IF MISSING( BUY6 ) THEN S_BUY6 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_BUY6 = -0.35938865799343 + 2.96941165974324 * BUY6 ;
MPRINT(EM_DIAGRAM):   IF MISSING( FICO ) THEN S_FICO = . ;
MPRINT(EM_DIAGRAM):   ELSE S_FICO = -23.7003109498374 + 0.03411600761233 * FICO ;
MPRINT(EM_DIAGRAM):   IF MISSING( INCOME ) THEN S_INCOME = . ;
MPRINT(EM_DIAGRAM):   ELSE S_INCOME = -2.9309588225649 + 0.06162016678243 * INCOME ;
MPRINT(EM_DIAGRAM):   IF MISSING( VALUE24 ) THEN S_VALUE24 = . ;
MPRINT(EM_DIAGRAM):   ELSE S_VALUE24 = -1.65368962520984 + 0.00645651495403 * VALUE24 ;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node bin ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node nom ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node H1 ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 0 THEN DO;
MPRINT(EM_DIAGRAM):   H11 = -1.63844613947577 * S_AGE + -0.0006834495316 * S_BUY12 + -1.11920941857236 * S_BUY18 + -0.15449094415096 * S_BUY6 + -0.36108421052445 * S_FICO + 0.29193651520759 * S_INCOME + -0.53974295029901 * S_VALUE24 ;
MPRINT(EM_DIAGRAM):   H12 = 2.04070186234985 * S_AGE + -0.82334081428811 * S_BUY12 + 0.91553224280882 * S_BUY18 + -0.50033050635957 * S_BUY6 + -1.43166253029579 * S_FICO + 1.53196393911802 * S_INCOME + 1.17270711955564 * S_VALUE24 ;
MPRINT(EM_DIAGRAM):   H13 = 0.84574733578473 * S_AGE + 0.18802877429238 * S_BUY12 + -1.89191139981326 * S_BUY18 + 0.20058908494166 * S_BUY6 + -0.01161876595264 * S_FICO + 1.03788205942031 * S_INCOME + -0.04924604220188 * S_VALUE24 ;
MPRINT(EM_DIAGRAM):   H11 = H11 + -0.1988644311203 * COA60 + 0.68224787732582 * DISCBUY0 + -1.53390155389653 * MARRIED0 + 2.00437791742167 * OWNHOME0 + 0.88877058553497 * RETURN240 + -0.90483360227295 * SEXF ;
MPRINT(EM_DIAGRAM):   H12 = H12 + -0.37262471971785 * COA60 + -0.2049179662907 * DISCBUY0 + 0.10126199387394 * MARRIED0 + -1.51051913605472 * OWNHOME0 + -1.67939230329831 * RETURN240 + 0.0498695322584 * SEXF ;
MPRINT(EM_DIAGRAM):   H13 = H13 + 0.86228008872216 * COA60 + 0.61114127966391 * DISCBUY0 + 0.04574756543432 * MARRIED0 + 0.55158128240389 * OWNHOME0 + 0.19412426500861 * RETURN240 + -0.56321531111583 * SEXF ;
MPRINT(EM_DIAGRAM):   H11 = H11 + 1.1818176049225 * CLIMATE10 + -1.32058220720595 * CLIMATE20 + -0.58467627942889 * LOCA + -0.68972041678241 * LOCB + 0.30774237767357 * LOCC + 1.53078886973103 * LOCD + -0.34280592357562 * LOCE + -0.83618623857709 * LOCF +
0.01349481352948 * LOCG + -1.16955338386382 * ORGSRCC + 0.2455345729593 * ORGSRCD + 1.08120148293387 * ORGSRCI + -0.88297036165384 * ORGSRCO + 1.00916264530826 * ORGSRCP + 0.9602561921295 * ORGSRCR ;
MPRINT(EM_DIAGRAM):   H12 = H12 + -0.12745978178409 * CLIMATE10 + -1.00277157738408 * CLIMATE20 + -0.98868063297518 * LOCA + -0.96820178142632 * LOCB + 2.34325778788059 * LOCC + -0.45228620744141 * LOCD + 0.33681000164501 * LOCE + -0.53346358071112 * LOCF
+ 0.07322369931179 * LOCG + 0.71346080215181 * ORGSRCC + -0.15781793379033 * ORGSRCD + -4.85198276807088 * ORGSRCI + 1.76010505508802 * ORGSRCO + 1.22048952682581 * ORGSRCP + 1.46892428056809 * ORGSRCR ;
MPRINT(EM_DIAGRAM):   H13 = H13 + 0.09097091651634 * CLIMATE10 + -0.3965639355109 * CLIMATE20 + -0.50515435042955 * LOCA + -0.6025682016322 * LOCB + -0.21236281616384 * LOCC + -0.65003155376952 * LOCD + 0.75926680476961 * LOCE + -0.60543681094647 * LOCF +
-0.26230283406764 * LOCG + -0.73511454268996 * ORGSRCC + 0.75076149399272 * ORGSRCD + 0.32730886330929 * ORGSRCI + -0.05672858974123 * ORGSRCO + -0.33079089144214 * ORGSRCP + 1.35547292991141 * ORGSRCR ;
MPRINT(EM_DIAGRAM):   H11 = 1.94012350352894 + H11 ;
MPRINT(EM_DIAGRAM):   H12 = -3.49518156519206 + H12 ;
MPRINT(EM_DIAGRAM):   H13 = 1.19970335108207 + H13 ;
MPRINT(EM_DIAGRAM):   H11 = TANH(H11 );
MPRINT(EM_DIAGRAM):   H12 = TANH(H12 );
MPRINT(EM_DIAGRAM):   H13 = TANH(H13 );
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ELSE DO;
MPRINT(EM_DIAGRAM):   H11 = .;
MPRINT(EM_DIAGRAM):   H12 = .;
MPRINT(EM_DIAGRAM):   H13 = .;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the Node RESPOND ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Generate dummy variables for RESPOND ;
MPRINT(EM_DIAGRAM):   drop RESPOND1 RESPOND0 ;
MPRINT(EM_DIAGRAM):   label F_RESPOND = 'From: RESPOND' ;
MPRINT(EM_DIAGRAM):   length F_RESPOND $ 12;
MPRINT(EM_DIAGRAM):   F_RESPOND = put( RESPOND , BEST12. );
MPRINT(DMNORMIP):   call dmnorm(F_RESPOND,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_DIAGRAM):   if missing( RESPOND ) then do;
MPRINT(EM_DIAGRAM):   RESPOND1 = .;
MPRINT(EM_DIAGRAM):   RESPOND0 = .;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   if F_RESPOND = '0' then do;
MPRINT(EM_DIAGRAM):   RESPOND1 = 0;
MPRINT(EM_DIAGRAM):   RESPOND0 = 1;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if F_RESPOND = '1' then do;
MPRINT(EM_DIAGRAM):   RESPOND1 = 1;
MPRINT(EM_DIAGRAM):   RESPOND0 = 0;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   RESPOND1 = .;
MPRINT(EM_DIAGRAM):   RESPOND0 = .;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 0 THEN DO;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = 1.24114471688656 * H11 + 0.68120616904803 * H12 + -1.0075458443965 * H13 ;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = -2.2955746741664 + P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = 0;
MPRINT(EM_DIAGRAM):   _MAX_ = MAX (P_RESPOND1 , P_RESPOND0 );
MPRINT(EM_DIAGRAM):   _SUM_ = 0.;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = EXP(P_RESPOND1 - _MAX_);
MPRINT(EM_DIAGRAM):   _SUM_ = _SUM_ + P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = EXP(P_RESPOND0 - _MAX_);
MPRINT(EM_DIAGRAM):   _SUM_ = _SUM_ + P_RESPOND0 ;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = P_RESPOND1 / _SUM_;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = P_RESPOND0 / _SUM_;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ELSE DO;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = .;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = .;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   IF _DM_BAD EQ 1 THEN DO;
MPRINT(EM_DIAGRAM):   P_RESPOND1 = 0.07431340872374;
MPRINT(EM_DIAGRAM):   P_RESPOND0 = 0.92568659127625;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   *** *****************************;
MPRINT(EM_DIAGRAM):   *** Writing the Residuals of the Node RESPOND ;
MPRINT(EM_DIAGRAM):   *** ******************************;
MPRINT(EM_DIAGRAM):   IF MISSING( RESPOND1 ) THEN R_RESPOND1 = . ;
MPRINT(EM_DIAGRAM):   ELSE R_RESPOND1 = RESPOND1 - P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   IF MISSING( RESPOND0 ) THEN R_RESPOND0 = . ;
MPRINT(EM_DIAGRAM):   ELSE R_RESPOND0 = RESPOND0 - P_RESPOND0 ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   *** Writing the I_RESPOND AND U_RESPOND ;
MPRINT(EM_DIAGRAM):   *** *************************;
MPRINT(EM_DIAGRAM):   _MAXP_ = P_RESPOND1 ;
MPRINT(EM_DIAGRAM):   I_RESPOND = "1           " ;
MPRINT(EM_DIAGRAM):   U_RESPOND = 1;
MPRINT(EM_DIAGRAM):   IF( _MAXP_ LT P_RESPOND0 ) THEN DO;
MPRINT(EM_DIAGRAM):   _MAXP_ = P_RESPOND0 ;
MPRINT(EM_DIAGRAM):   I_RESPOND = "0           " ;
MPRINT(EM_DIAGRAM):   U_RESPOND = 0;
MPRINT(EM_DIAGRAM):   END;
MPRINT(EM_DIAGRAM):   ********************************;
MPRINT(EM_DIAGRAM):   *** End Scoring Code for Neural;
MPRINT(EM_DIAGRAM):   ********************************;
MPRINT(EM_DIAGRAM):   drop S_AGE S_BUY12 S_BUY18 S_BUY6 S_FICO S_INCOME S_VALUE24 H11 H12 H13 ;
36592      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: DATA STEP 뷰가 파일 EMWS6.NEURAL_TEST에 저장되었습니다.
NOTE: 저장된 DATA STEP 뷰는 다른 운영 체제에서 실행할 수 없습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(EM_DIAGRAM):   quit;
36593      quit;
36594      filename emflow;
MPRINT(EM_DIAGRAM):   filename emflow;
NOTE: Fileref EMFLOW을(를) 삭제했습니다.
36595      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
36596      * Neural: Computing metadata for TRAIN data;
MPRINT(EM_DIAGRAM):   * Neural: Computing metadata for TRAIN data;
36597      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
 
NOTE: View EMWS6.NEURAL_TRAIN.VIEW 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * &nodeid: Computing Metadata for TRAIN data;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   filename _delta "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\CDELTA_TRAIN.sas";
MPRINT(EMADVISECOLUMNS):   proc display c=sashelp.emmeta.advisecolumns.scl;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    options validvarname=any;
MPRINT(EMADVISECOLUMNS):   proc contents data=EMWS6.Neural_TRAIN out=_tempAdvisor noprint;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):   options validvarname=V7;
MPRINT(EMADVISECOLUMNS):    data _null_;
MPRINT(EMADVISECOLUMNS):   dsid = open('EMWS6.Neural_TRAIN');
MPRINT(EMADVISECOLUMNS):   call symput('_dsidTable', strip(put(dsid, best.)));
MPRINT(EMADVISECOLUMNS):   if dsid then do;
MPRINT(EMADVISECOLUMNS):   call symput('_engineTable', attrc(dsid, 'ENGINE'));
MPRINT(EMADVISECOLUMNS):   dsid = close(dsid);
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    proc contents data=EMWS6.Neural_TRAIN out=WORK.M1KPELDZ noprint;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M1KPELDZ;
MPRINT(EMADVISECOLUMNS):   length NAME $ 64 TYPE $ 1 LABEL $ 200 FORMAT $ 36 INFORMAT $36 INDEX $ 1 INDEXTYPE $ 9;
MPRINT(EMADVISECOLUMNS):   label NAME =;
MPRINT(EMADVISECOLUMNS):   set WORK.M1KPELDZ(keep=name type length label format formatl formatd informat informl informd idxusage rename=(type=itype));
MPRINT(EMADVISECOLUMNS):   if itype = 1 then type = 'N';
MPRINT(EMADVISECOLUMNS):   else type = 'C';
MPRINT(EMADVISECOLUMNS):   if formatl > 0 then do;
MPRINT(EMADVISECOLUMNS):   if format ne '' then do;
MPRINT(EMADVISECOLUMNS):   if type='N' then format = strip(format)!!strip(put(formatl, best12.))!!'.'!!strip(put(formatd, best12.));
MPRINT(EMADVISECOLUMNS):   else format = strip(format)!!strip(put(formatl, best12.))!!'.';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else format = strip(put(formatl, best12.))!!'.'!!strip(put(formatd, best12.));
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if format ne '' then format = strip(format)!!'.';
MPRINT(EMADVISECOLUMNS):   if informl > 0 then do;
MPRINT(EMADVISECOLUMNS):   if informat ne ' ' then do;
MPRINT(EMADVISECOLUMNS):   if type='N' then informat = strip(informat)!!strip(put(informl, best12.))!!'.'!!strip(put(informd, best12.));
MPRINT(EMADVISECOLUMNS):   else informat = strip(informat)!!strip(put(informl, best12.))!!'.';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else informat = strip(put(informl, best12.))!!'.'!!strip(put(informd, best12.));
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if informat ne '' then informat = strip(informat)!!'.';
MPRINT(EMADVISECOLUMNS):   if idxusage = 'NONE' then index ="N";
MPRINT(EMADVISECOLUMNS):   else index = "Y";
MPRINT(EMADVISECOLUMNS):   indextype = idxusage;
MPRINT(EMADVISECOLUMNS):   drop idxusage itype formatl formatd informl informd;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M1KPELDZ;
MPRINT(EMADVISECOLUMNS):   length UNAME $64;
MPRINT(EMADVISECOLUMNS):   set WORK.M1KPELDZ;
MPRINT(EMADVISECOLUMNS):   UNAME = upcase(NAME);
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    proc sort data=WORK.M35G73SA NOTHREADS;
MPRINT(EMADVISECOLUMNS):   by UNAME;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M35G73SA;
MPRINT(EMADVISECOLUMNS):   drop UNAME;
MPRINT(EMADVISECOLUMNS):   set WORK.M35G73SA;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M1ZXTLLC(keep=NAME ATTR);
MPRINT(EMADVISECOLUMNS):   length ATTR $ 20;
MPRINT(EMADVISECOLUMNS):   set WORK.M35G73SA;
MPRINT(EMADVISECOLUMNS):   if level ne "INTERVAL" then do;
MPRINT(EMADVISECOLUMNS):   if order = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'ORDER';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if format ne ' ' and formattype = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'FORMATTYPE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'ROLE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if level = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'LEVEL';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if type = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'TYPE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if index = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'INDEX';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if report = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'REPORT';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):   proc sort NOTHREADS;
MPRINT(EMADVISECOLUMNS):   by attr;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M35G73SA;
MPRINT(EMADVISECOLUMNS):   length NAME $64 ROLE $ 32 LEVEL $ 10 ORDER $ 8 CREATOR $32 FORMATTYPE $ 10 FAMILY $ 10 LOWERLIMIT 8 UPPERLIMIT 8 REPORT $1 DISTRIBUTION $ 20 COMMENT $64;
MPRINT(EMADVISECOLUMNS):   length levelAssigned 8 roleAssigned 8 PRICE 8;
MPRINT(EMADVISECOLUMNS):   set WORK.M35G73SA;
MPRINT(EMADVISECOLUMNS):   if formattype = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if format ne ' ' then do;
MPRINT(EMADVISECOLUMNS):   if type = 'N' then do;
MPRINT(EMADVISECOLUMNS):   pos = indexc(format,'.1234567890');
MPRINT(EMADVISECOLUMNS):   if pos > 1 then tempfmt = substr(format,1, pos-1);
MPRINT(EMADVISECOLUMNS):   else tempfmt = ' ';
MPRINT(EMADVISECOLUMNS):   flen = length(tempfmt);
MPRINT(EMADVISECOLUMNS):   select;
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("DATE" "DAY" "DDMMYY" "DOWNAME" "JULDAY" "JULIAN" "MMDDYY" "MMDDYYD" "MMDDYYC" "MMDDYYN" "MMDDYYP" "MMDDYYS" "MONNAME" "MONTH" "MONYY" "NENGO" "QTR" "QTRR" "WEEKDATE" "WEEKDATX" "WEEKDAY" "WORDDATE" "WORDDATX"
"YEAR" "YYMMDD" "YYMON" "YYMMDDC" "YYMMDDD" "YYMMDDN" "YYMMDDP" "YYMMDDS" "EURDFDE" "NJDATE" "NLDATE" "EURDFDD" "EURDFDWN" "EURDFMN" "EURDFMY" "EURDFWK" "EURDFWKX" "EURDFWDX" "EURDFDN" "EURDFDE" )) formattype = 'DATE';
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("DATETIME" "EURDFDT" "TOD" )) formattype = "DATETIME";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("HHMM" "HOUR" "MMSS" "TIME" "TIMEAMPM" )) formattype = "TIME";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("COMMA" "COMMAX" "DOLLAR" "DOLLARX" "E" "FRACT" "NEGPAREN" "PERCENT")) formattype="QUANTITY";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("BINARY" "HEX" "IB" "OCTAL" "PD" "PIB" "PK" "RB" "SSN" "Z" "ZD")) formattype = "CODING";
MPRINT(EMADVISECOLUMNS):   otherwise do;
MPRINT(EMADVISECOLUMNS):   formattype = "USER";
MPRINT(EMADVISECOLUMNS):   if compress(tempfmt, '0123456789.', '') = '' then formattype='NUM';
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 6)='NLDATE' then formattype = "DATE";
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 6)='NLDATM' then formattype = "DATETIME";
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 4)='NLTIM' then formattype = "TIME";
MPRINT(EMADVISECOLUMNS):   else if flen >= 4 then do;
MPRINT(EMADVISECOLUMNS):   str = substr(tempfmt,1,4);
MPRINT(EMADVISECOLUMNS):   if str in ("MMYY" "YYMM" "YYQR") then formattype ="DATE";
MPRINT(EMADVISECOLUMNS):   else if str = "S370" then formattype = "CODING";
MPRINT(EMADVISECOLUMNS):   else if str = "BEST" then formattype = "NUM";
MPRINT(EMADVISECOLUMNS):   drop str;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if flen >=3 and substr(tempfmt,1,3) = "YYQ" then formatType = "DATE";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   drop flen tempfmt pos;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   formatType = "CATEGORY";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if formatType = "NUM" then do;
MPRINT(EMADVISECOLUMNS):   if index = "Y" then formatType = "DISCRETE";
MPRINT(EMADVISECOLUMNS):   else formatType = "QUANTITY";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if level = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if formatType in ("CATEGORY", "CODING", "ID") or type = "C" then level = "NOMINAL";
MPRINT(EMADVISECOLUMNS):   else level = "INTERVAL";
MPRINT(EMADVISECOLUMNS):   levelAssigned = 1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else level = upcase(level);
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   length name_prefix $8 _uname $64;
MPRINT(EMADVISECOLUMNS):   drop name_prefix _uname _freqflag;
MPRINT(EMADVISECOLUMNS):   retain _freqflag;
MPRINT(EMADVISECOLUMNS):   if LENGTH> 80 then ROLE = 'TEXT';
MPRINT(EMADVISECOLUMNS):   _uname = upcase(NAME);
MPRINT(EMADVISECOLUMNS):   select(_uname);
MPRINT(EMADVISECOLUMNS):   when('_PARTIND_') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'ID';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('_WARN_') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_SEGMENT') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('_NODE_') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('EM_CLASSTARGET') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_VALUETARGET') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_PREDICTION') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_PROBABILITY') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_EVENTPROBABILITY') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_CLASSIFICATION') ROLE = 'CLASSIFICATION';
MPRINT(EMADVISECOLUMNS):   when('EM_DECISION') ROLE = 'DECISION';
MPRINT(EMADVISECOLUMNS):   when('EM_PROFIT') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_LOSS') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_ROI') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('URI') ROLE = 'URL';
MPRINT(EMADVISECOLUMNS):   when('FILTERED') ROLE = 'TEXTLOC';
MPRINT(EMADVISECOLUMNS):   otherwise do;
MPRINT(EMADVISECOLUMNS):   if upcase(NAME) =: 'ZIP' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'REJECTED';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   COMMENT = 'Rejected by: Exceed the maximum class level of %s';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if upcase(NAME) in('FREQ', 'FREQUENCY') then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'FREQ';
MPRINT(EMADVISECOLUMNS):   if TYPE = 'C' then ROLE = 'INPUT';
MPRINT(EMADVISECOLUMNS):   else if _freqflag =1 then ROLE='REJECTED';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   name_prefix = scan(_uname, 1, '_');
MPRINT(EMADVISECOLUMNS):   if scan(_uname, 2, '_') = '' then name_prefix='';
MPRINT(EMADVISECOLUMNS):   if name_prefix in('F', 'I', 'U') then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'CLASSIFICATION';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('Q') then ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('P', 'V') then ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('R', 'RS', 'RT', 'RD', 'RDS', 'RDT', 'RA', 'RAS', 'RAT') then ROLE = 'RESIDUAL';
MPRINT(EMADVISECOLUMNS):   else if name_prefix ='D' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'DECISION';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix ='B' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('EP', 'BP', 'CP', 'EL', 'CL', 'BL', 'W', 'ROI', 'IC') then ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   array _ROLE_ (19) $32 _TEMPORARY_ ('ASSESS','CLASSIFICATION','CENSOR', 'COST', 'CROSSID', 'DECISION', 'ID','INPUT', 'LABEL', 'MISSING','PREDICT','REFERRER','REJECTED', 'RESIDUAL','SEGMENT', 'SEQUENCE','TARGET', 'TEXT', 'TIMEID');
MPRINT(EMADVISECOLUMNS):   drop _found_ i;
MPRINT(EMADVISECOLUMNS):   _found_=0;
MPRINT(EMADVISECOLUMNS):   do i=1 to 19 until(_found_=1);
MPRINT(EMADVISECOLUMNS):   if index(_uname, trim(_ROLE_{i}))=1 then do;
MPRINT(EMADVISECOLUMNS):   ROLE=_ROLE_{i};
MPRINT(EMADVISECOLUMNS):   if ROLE = 'ID' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'SEGMENT' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'TIMEID' and TYPE='N' then LEVEL = 'INTERVAL';
MPRINT(EMADVISECOLUMNS):   _found_=1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if length(_uname)>2 then do;
MPRINT(EMADVISECOLUMNS):   if substr(reverse(trim(_uname)), 1, 3) = 'DI_' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'ID';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if ROLE='FREQ' then _freqflag=1;
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'CLASSIFICATION' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   if symexist('RATEMKG_ROLE') then do;
MPRINT(EMADVISECOLUMNS):   if upcase(symget('RATEMKG_ROLE')) in('Y', 'YES') then do;
MPRINT(EMADVISECOLUMNS):   if _uname =: 'POLICY' then ROLE = 'POLICYID';
MPRINT(EMADVISECOLUMNS):   else if _uname in ('PARTITION', '_PARTIND_') then ROLE = 'PARTITION';
MPRINT(EMADVISECOLUMNS):   else if type = 'N' then do;
MPRINT(EMADVISECOLUMNS):   if _uname = 'EXPOSURE' then ROLE = 'EXPOSURE';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'YEAR' then ROLE = 'YEAR';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'WEIGHT' then ROLE = 'WEIGHT';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'OFFSET' then ROLE = 'OFFSET';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if formattype in('DATE', 'DATETIME', 'TIME') then role = 'TIMEID';
MPRINT(EMADVISECOLUMNS):   else role = 'INPUT';
MPRINT(EMADVISECOLUMNS):   roleAssigned = 1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else role = upcase(role);
MPRINT(EMADVISECOLUMNS):   if REPORT = '' then REPORT = 'N';
MPRINT(EMADVISECOLUMNS):   if symexist('dmwb_product') then do;
MPRINT(EMADVISECOLUMNS):   if upcase(symget('dmwb_product')) = 'FACTORYMINER_DATASOURCE' then do;
MPRINT(EMADVISECOLUMNS):   if ROLE ^in('INPUT', 'TARGET', 'REJECTED', 'SEGMENT', 'FREQ', 'ID', 'KEY') then ROLE='REJECTED';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M35G73SA;
MPRINT(EMADVISECOLUMNS):   set WORK.M35G73SA;
MPRINT(EMADVISECOLUMNS):   label NAME = "변수 이름" TYPE = "유형" ROLE = "역할" LEVEL= "측도 레벨" ORDER= "순서" CREATOR= "생성자" FORMATTYPE= "출력형식 유형" FAMILY= "군" DISTRIBUTION= "분포" PRICE= "가격" LOWERLIMIT= "하한" UPPERLIMIT= "상한" REPORT=
"리 포트" COMMENT= "주석" INDEX= "인덱스" INDEXTYPE= "인덱스 유형" LABEL= "레이블" LENGTH= "길이";
MPRINT(EMADVISECOLUMNS):   drop levelAssigned roleAssigned;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   proc sort data=WORK.COLUMNMETA;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * &nodeid: Merge incoming metadata;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   proc contents data=EMWS6.Part_TRAIN noprint out=_temp2(keep=NAME);
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc sort data=_temp2;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc sort data=EMWS6.Part_CMeta_TRAIN out=_temp;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_CMeta_TRAIN;
MPRINT(EM_DIAGRAM):   merge WORK.COLUMNMETA(in=_a) _temp2(in=_b) _temp(drop=FORMAT INFORMAT LENGTH INDEX INDEXTYPE in=_c) end=_eof_;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   if (^_a and _b) or (^_c and _a and _b) then delete;
MPRINT(EM_DIAGRAM):   if ^_b then CREATOR = "Neural";
MPRINT(EM_DIAGRAM):   length model $200;
MPRINT(EM_DIAGRAM):   label MODEL = "모델 노드";
MPRINT(EM_DIAGRAM):   select(upcase(name));
MPRINT(EM_DIAGRAM):   when("RESPOND") model = "Neural";
MPRINT(EM_DIAGRAM):   when('');
MPRINT(EM_DIAGRAM):   otherwise;
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Neural: Apply Delta Code;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _delta;
36942      data EMWS6.Neural_EMINFO;
MPRINT(EM_DIAGRAM):    data EMWS6.Neural_EMINFO;
36943      length TARGET KEY $32 DATA $43;
MPRINT(EM_DIAGRAM):   length TARGET KEY $32 DATA $43;
36944      input TARGET KEY DATA $;
MPRINT(EM_DIAGRAM):   input TARGET KEY DATA $;
36945      cards;
MPRINT(EM_DIAGRAM):   cards;
 
NOTE: 데이터셋 EMWS6.NEURAL_EMINFO은(는) 3개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(EM_DIAGRAM):   run;
36949      run;
36950      proc sort data = EMWS6.Neural_EMINFO NOTHREADS;
MPRINT(EM_DIAGRAM):   proc sort data = EMWS6.Neural_EMINFO NOTHREADS;
36951      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
36952      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 3개의 관측값을 데이터셋 EMWS6.NEURAL_EMINFO.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_EMINFO은(는) 3개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
36953      proc sort data = EMWS6.Ids_EMINFO OUT=WORK.SORTEDEMINFO NOTHREADS;
MPRINT(EM_DIAGRAM):    proc sort data = EMWS6.Ids_EMINFO OUT=WORK.SORTEDEMINFO NOTHREADS;
36954      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
36955      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 3개의 관측값을 데이터셋 EMWS6.IDS_EMINFO.에서 읽었습니다.
NOTE: 데이터셋 WORK.SORTEDEMINFO은(는) 3개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
36956      proc sort data = EMWS6.Neural_EMINFO OUT=WORK.TEMP_INFO NOTHREADS;
MPRINT(EM_DIAGRAM):   proc sort data = EMWS6.Neural_EMINFO OUT=WORK.TEMP_INFO NOTHREADS;
36957      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
36958      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 입력 데이터셋이 이미 정렬되어 있습니다; 출력 데이터셋에 복사되었습니다.
NOTE: 3개의 관측값을 데이터셋 EMWS6.NEURAL_EMINFO.에서 읽었습니다.
NOTE: 데이터셋 WORK.TEMP_INFO은(는) 3개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
36959      data EMWS6.Neural_EMINFO;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_EMINFO;
36960      merge WORK.SORTEDEMINFO WORK.TEMP_INFO;
MPRINT(EM_DIAGRAM):   merge WORK.SORTEDEMINFO WORK.TEMP_INFO;
36961      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
36962      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 3개의 관측값을 데이터셋 WORK.SORTEDEMINFO.에서 읽었습니다.
NOTE: 3개의 관측값을 데이터셋 WORK.TEMP_INFO.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_EMINFO은(는) 4개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
36963      proc datasets lib=work nolist;
MPRINT(EM_DIAGRAM):   proc datasets lib=work nolist;
36964      delete TEMP_INFO SORTEDEMINFO;
MPRINT(EM_DIAGRAM):   delete TEMP_INFO SORTEDEMINFO;
36965      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: WORK.TEMP_INFO(memtype=DATA)을(를) 삭제하는 중입니다.
NOTE: WORK.SORTEDEMINFO(memtype=DATA)을(를) 삭제하는 중입니다.
36966      quit;
MPRINT(EM_DIAGRAM):   quit;
 
NOTE: 프로시저 DATASETS 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
NOTE: View EMWS6.NEURAL_TRAIN.VIEW 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
NOTE: View EMWS6.NEURAL_VALIDATE.VIEW 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
NOTE: View EMWS6.NEURAL_TEST.VIEW 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 20일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "10시00분47초" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 리포트 로그";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* 리포트 로그
날짜:                2018년 11월 20일
시간:                10시00분47초
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O2K6XBZW "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS6\Neural\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O2K6XBZW new;
MPRINT(EM_DIAGRAM):   run;
36990      data EMWS6.Neural_EMOUTFIT(rename=(_NAME_=TARGET));
MPRINT(EM_DIAGRAM):    data EMWS6.Neural_EMOUTFIT(rename=(_NAME_=TARGET));
36991      set EMWS6.Neural_OUTFIT(where=(_NAME_ eq 'OVERALL'));
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_OUTFIT(where=(_NAME_ eq 'OVERALL'));
36992      label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_target_vlabel  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   label _NAME_ = "타겟";
36993      if _NAME_='OVERALL' then _NAME_='RESPOND';
MPRINT(EM_DIAGRAM):   if _NAME_='OVERALL' then _NAME_='RESPOND';
36994      drop _ITER_;
MPRINT(EM_DIAGRAM):   drop _ITER_;
36995      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS6.NEURAL_OUTFIT.에서 읽었습니다.
      WHERE _NAME_='OVERALL';
NOTE: 데이터셋 EMWS6.NEURAL_EMOUTFIT은(는) 1개의 관측값과 50개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
36996      proc sort data=EMWS6.Neural_EMOUTFIT nodupkey;
MPRINT(EM_DIAGRAM):   proc sort data=EMWS6.Neural_EMOUTFIT nodupkey;
36997      by TARGET;
MPRINT(EM_DIAGRAM):   by TARGET;
36998      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS6.NEURAL_EMOUTFIT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 0개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_EMOUTFIT은(는) 1개의 관측값과 50개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
36999      data EMWS6.Neural_EMOUTFIT;
MPRINT(EM_DIAGRAM):    data EMWS6.Neural_EMOUTFIT;
37000      set EMWS6.Neural_EMOUTFIT;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_EMOUTFIT;
37001      length TargetLabel $200;
MPRINT(EM_DIAGRAM):   length TargetLabel $200;
37002      label targetLabel = "%sysfunc(sasmsg(sashelp.dmine, meta_targetlabel_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label targetLabel = "타겟 레이블";
37003      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 변수 TargetLabel이(가) 초기화되지 않았습니다.
NOTE: 1개의 관측값을 데이터셋 EMWS6.NEURAL_EMOUTFIT.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_EMOUTFIT은(는) 1개의 관측값과 51개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
37004      proc sort data=EMWS6.Neural_EMREPORTFIT nothreads;
MPRINT(EM_DIAGRAM):    proc sort data=EMWS6.Neural_EMREPORTFIT nothreads;
37005      by TARGET;
MPRINT(EM_DIAGRAM):   by TARGET;
37006      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 21개의 관측값을 데이터셋 EMWS6.NEURAL_EMREPORTFIT.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_EMREPORTFIT은(는) 21개의 관측값과 7개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
37007      %let _EMwarndup = 0;
37008      %let _EMtargetdup =;
37009      %let _EMASEtargetdup =;
37010      data _null_;
MPRINT(EM_DIAGRAM):    data _null_;
37011      set EMWS6.Neural_EMOUTFIT;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_EMOUTFIT;
37012      if .<_ASE_<0.000001 then do;
MPRINT(EM_DIAGRAM):   if .<_ASE_<0.000001 then do;
37013      call symput('_EMwarndup', '1');
MPRINT(EM_DIAGRAM):   call symput('_EMwarndup', '1');
37014      call symput('_EMtargetdup', target);
MPRINT(EM_DIAGRAM):   call symput('_EMtargetdup', target);
37015      call symput('_EMASEtargetdup', put(_ASE_, best.));
MPRINT(EM_DIAGRAM):   call symput('_EMASEtargetdup', put(_ASE_, best.));
37016      end;
MPRINT(EM_DIAGRAM):   end;
37017      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS6.NEURAL_EMOUTFIT.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
37018      proc sort data=EMWS6.Part_CMeta_TRAIN out=WORK.SUBSETINMETA;
MPRINT(EM_DIAGRAM):    proc sort data=EMWS6.Part_CMeta_TRAIN out=WORK.SUBSETINMETA;
37019      by NAME;
MPRINT(EM_DIAGRAM):   by NAME;
37020      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 27개의 관측값을 데이터셋 EMWS6.PART_CMETA_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 WORK.SUBSETINMETA은(는) 27개의 관측값과 20개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
37021      proc sort data=EMWS6.Neural_VariableSet out=WORK.SUBSETVARSET(keep=NAME REPORT);
MPRINT(EM_DIAGRAM):   proc sort data=EMWS6.Neural_VariableSet out=WORK.SUBSETVARSET(keep=NAME REPORT);
37022      by NAME;
MPRINT(EM_DIAGRAM):   by NAME;
37023      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 25개의 관측값을 데이터셋 EMWS6.NEURAL_VARIABLESET.에서 읽었습니다.
NOTE: 데이터셋 WORK.SUBSETVARSET은(는) 25개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
37024      data WORK.ASSESS_META;
MPRINT(EM_DIAGRAM):   data WORK.ASSESS_META;
37025      merge WORK.SUBSETINMETA WORK.SUBSETVARSET;
MPRINT(EM_DIAGRAM):   merge WORK.SUBSETINMETA WORK.SUBSETVARSET;
37026      by NAME;
MPRINT(EM_DIAGRAM):   by NAME;
37027      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 27개의 관측값을 데이터셋 WORK.SUBSETINMETA.에서 읽었습니다.
NOTE: 25개의 관측값을 데이터셋 WORK.SUBSETVARSET.에서 읽었습니다.
NOTE: 데이터셋 WORK.ASSESS_META은(는) 27개의 관측값과 20개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
37028      data EM_temp_assessMeta;
MPRINT(EM_DIAGRAM):    data EM_temp_assessMeta;
37029      set EMWS6.Neural_CMeta_TRAIN;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_CMeta_TRAIN;
37030      where role in('DECISION', 'PREDICT', 'RESIDUAL', 'CLASSIFICATION', 'ASSESS', 'COST');
MPRINT(EM_DIAGRAM):   where role in('DECISION', 'PREDICT', 'RESIDUAL', 'CLASSIFICATION', 'ASSESS', 'COST');
37031      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 8개의 관측값을 데이터셋 EMWS6.NEURAL_CMETA_TRAIN.에서 읽었습니다.
      WHERE role in ('ASSESS', 'CLASSIFICATION', 'COST', 'DECISION', 'PREDICT', 'RESIDUAL');
NOTE: 데이터셋 WORK.EM_TEMP_ASSESSMETA은(는) 8개의 관측값과 21개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
37032      data EM_temp_assessdata;
MPRINT(EM_DIAGRAM):    data EM_temp_assessdata;
37033      set EMWS6.Neural_TRAIN(keep=
37034      F_RESPOND
37035      I_RESPOND
37036      P_RESPOND0
37037      P_RESPOND1
37038      R_RESPOND0
37039      R_RESPOND1
37040      U_RESPOND
37041      _WARN_
37042      RESPOND
37043      );
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_TRAIN(keep= F_RESPOND I_RESPOND P_RESPOND0 P_RESPOND1 R_RESPOND0 R_RESPOND1 U_RESPOND _WARN_ RESPOND );
37044      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: View EMWS6.NEURAL_TRAIN.VIEW 실행(총 프로세스 시간):
      실행 시간           0.12 초
      cpu 시간            0.09 초
 
NOTE: 3999개의 관측값을 데이터셋 EMWS6.PART_TRAIN.에서 읽었습니다.
NOTE: 3999개의 관측값을 데이터셋 EMWS6.NEURAL_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_TEMP_ASSESSDATA은(는) 3999개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.14 초
      cpu 시간            0.11 초
 
 
MPRINT(EM_DIAGRAM):    proc freq data=EM_temp_assessdata noprint;
MPRINT(EM_DIAGRAM):   table I_RESPOND*F_RESPOND / out = WORK.Neural_3T7QNZH nocol norow outpct;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data WORK.Neural_3T7QNZH;
MPRINT(EM_DIAGRAM):   length _TYPE_ $10 DATAROLE TARGET $32 TARGETLABEL $200 FROM INTO $32 CORRECTTEXT $40 ;
MPRINT(EM_DIAGRAM):   label _TYPE_ = "결과 유형";
MPRINT(EM_DIAGRAM):   label DATAROLE = "데이터 역할";
MPRINT(EM_DIAGRAM):   label TARGET = "타겟 변수";
MPRINT(EM_DIAGRAM):   label TARGETLABEL = "타겟 레이블";
MPRINT(EM_DIAGRAM):   label FROM = "타겟";
MPRINT(EM_DIAGRAM):   label INTO = "결과";
MPRINT(EM_DIAGRAM):   label PCT_ROW = "타겟 백분율";
MPRINT(EM_DIAGRAM):   label PCT_COL = "결과 백분율";
MPRINT(EM_DIAGRAM):   label COUNT = "빈도 개수";
MPRINT(EM_DIAGRAM):   label PERCENT = "총 백분율";
MPRINT(EM_DIAGRAM):   label CORRECTTEXT = "Correct 텍스트";
MPRINT(EM_DIAGRAM):   label CORRECT = "올바름";
MPRINT(EM_DIAGRAM):   set WORK.Neural_3T7QNZH(rename=(F_RESPOND=FROM I_RESPOND=INTO));
MPRINT(EM_DIAGRAM):   retain _TYPE_ 'PREDICTION' DATAROLE "TRAIN" TARGET "RESPOND";
MPRINT(EM_DIAGRAM):   if FROM eq INTO then do;
MPRINT(EM_DIAGRAM):   CORRECT = 0;
MPRINT(EM_DIAGRAM):   CORRECTTEXT="올바름";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   CORRECT = 1;
MPRINT(EM_DIAGRAM):   CORRECTTEXT="올바르지 않음";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data EMWS6.Neural_EMCLASSIFICATION;
MPRINT(EM_DIAGRAM):   set WORK.Neural_3T7QNZH;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data WORK.MISCREPORT;
MPRINT(EM_DIAGRAM):   set WORK.Neural_3T7QNZH;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data WORK.MISCREPORT(drop=INTO FROM _TYPE_);
MPRINT(EM_DIAGRAM):   set WORK.MISCREPORT;
MPRINT(EM_DIAGRAM):   length MISC $12;
MPRINT(EM_DIAGRAM):   if FROM='1' and INTO='1' then MISC='TRUEEVENT';
MPRINT(EM_DIAGRAM):   else if FROM='1' and INTO ne '1' then MISC='FALSENEVENT';
MPRINT(EM_DIAGRAM):   else if FROM ne '1' and INTO='1' then MISC='FALSEEVENT';
MPRINT(EM_DIAGRAM):   else if FROM ne'1' and INTO ne '1' then MISC='TRUENEVENT';
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc sort data=WORK.MISCREPORT nothreads;
MPRINT(EM_DIAGRAM):   by DATAROLE TARGET;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc summary data=WORK.MISCREPORT NWAY;
MPRINT(EM_DIAGRAM):   output out=WORK.MISCCOUNT(drop=_FREQ_ _TYPE_) SUM=COUNT;
MPRINT(EM_DIAGRAM):   CLASS MISC;
MPRINT(EM_DIAGRAM):   VAR COUNT;
MPRINT(EM_DIAGRAM):   by DATAROLE TARGET;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc transpose data=WORK.MISCCOUNT out=WORK.MISCREPORT(drop=_NAME_ _LABEL_);
MPRINT(EM_DIAGRAM):   by DATAROLE TARGET;
MPRINT(EM_DIAGRAM):   ID MISC;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data EMWS6.Neural_EMEVENTREPORT;
MPRINT(EM_DIAGRAM):   length TARGETLABEL $200;
MPRINT(EM_DIAGRAM):   label TARGETLABEL = "타겟 레이블";
MPRINT(EM_DIAGRAM):   set WORK.MISCREPORT;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data ASSESS_REPORTMETA;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_VariableSet;
MPRINT(EM_DIAGRAM):   where REPORT='Y';
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename temp catalog 'sashelp.emassmt.em_assess.source';
MPRINT(EM_DIAGRAM):   filename temp;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   set EMWS6.Ids_RESPOND_DM;
MPRINT(EM_DIAGRAM):   where _TYPE_="TARGET";
MPRINT(EM_DIAGRAM):   call symput('ASSMT_EVENT', strip(event));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):
MPRINT(EM_ASSESS):   data _ea_tmpdata;
MPRINT(EM_ASSESS):   set EM_temp_assessdata;
MPRINT(EM_ASSESS):   _tmpfreqvar_=1;
MPRINT(EM_ASSESS):   run;
MPRINT(EM_CHECKEMSETINIT):   DATA _NULL_;
MPRINT(EM_CHECKEMSETINIT):   EM_SETINIT = 'N';
MPRINT(EM_CHECKEMSETINIT):   IF SYSPROD('PRODNUM50') THEN EM_SETINIT = 'Y';
MPRINT(EM_CHECKEMSETINIT):   ELSE IF SYSPROD('PRODNUM448') THEN EM_SETINIT = 'Y';
MPRINT(EM_CHECKEMSETINIT):   ELSE IF SYSPROD('PRODNUM102') THEN EM_SETINIT = 'Y';
MPRINT(EM_CHECKEMSETINIT):   ELSE IF SYSPROD('PRODNUM103') THEN EM_SETINIT = 'Y';
MPRINT(EM_CHECKEMSETINIT):   CALL SYMPUT('EM_SETINIT', EM_SETINIT);
MPRINT(EM_CHECKEMSETINIT):   RUN;
MPRINT(EM_ASSESS):  ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ............ Reading in reporting data set;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   DATA _NULL_;
MPRINT(EM_ASSESS):   SET ASSESS_REPORTMETA END = EOF;
MPRINT(EM_ASSESS):   IF TYPE = "C" OR UPCASE (LEVEL) IN ("NOMINAL", "BINARY" , "ORDINAL") THEN DO;
MPRINT(EM_ASSESS):   IF UPCASE (NAME) NE UPCASE ("F_RESPOND") THEN DO;
MPRINT(EM_ASSESS):   NUMCTOREPORT + 1;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("REPORTC" || LEFT (PUT (NUMCTOREPORT, 5.)), NAME);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE CALL SYMPUTX ("RPRT_TRGT", "C");
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE IF TYPE = "N" THEN DO;
MPRINT(EM_ASSESS):   IF UPCASE(NAME) NE UPCASE ("F_RESPOND") THEN DO;
MPRINT(EM_ASSESS):   NUMNTOREPORT + 1;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("REPORTN" || LEFT (PUT (NUMNTOREPORT, 5.)), NAME);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE CALL SYMPUTX ("RPRT_TRGT", "N");
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   IF EOF THEN DO;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUMNTOREPORT", NUMNTOREPORT);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUMCTOREPORT", NUMCTOREPORT);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUMTOREPORT", SUM (NUMNTOREPORT, NUMCTOREPORT));
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   PROC DMDB DATA = _ea_tmpdata VAROUT = VAROUT DMDBCAT = _D CLASSOUT = _ASSMT_CLASSOUT;
MPRINT(EM_ASSESS):   CLASS F_RESPOND ;
 
MPRINT(EM_ASSESS):   VAR P_RESPOND1 _tmpfreqvar_ ;
MPRINT(EM_ASSESS):   FREQ _tmpfreqvar_;
MPRINT(EM_ASSESS):   RUN ;
MPRINT(EM_ASSESS):   QUIT;
MPRINT(EM_ASSESS):   PROC SORT DATA = _ASSMT_CLASSOUT;
MPRINT(EM_ASSESS):   BY NAME;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   DATA _auxeventname (keep = __event__) ;
MPRINT(EM_ASSESS):   * ;
MPRINT(EM_ASSESS):   * ...FLAG0_1 = ..... TARGET IS 0, 1 & EVENT = 1;
 
MPRINT(EM_ASSESS):   ;
MPRINT(EM_ASSESS):   length __event__ $ 32;
MPRINT(EM_ASSESS):   RETAIN FLAG0_1 1 NUM1 . NUM0 . __event__ "_missing_" ;
 
MPRINT(EM_ASSESS):   SET _ASSMT_CLASSOUT END = EOF;
MPRINT(EM_ASSESS):   BY NAME;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ....... LEVEL = BINARY OR NOMINAL OR ORDINAL;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
 
MPRINT(EM_ASSESS):   IF UPCASE(NAME) = UPCASE ("F_RESPOND") THEN DO;
MPRINT(EM_ASSESS):   CUMFREQ + FREQUENCY;
MPRINT(EM_ASSESS):   IF LEVEL NE "." THEN DO;
MPRINT(EM_ASSESS):   N1 + 1;
MPRINT(EM_ASSESS):   IF (NRAW NE 0 AND NRAW NE 1) OR TYPE NE "N" OR "" > " " THEN FLAG0_1 = 0;
MPRINT(EM_ASSESS):   * ;
MPRINT(EM_ASSESS):   * ......................... IF EVENT NE BLANK;
MPRINT(EM_ASSESS):   * ....................LEVEL IS CHAR VAR ;
MPRINT(EM_ASSESS):   * ;
MPRINT(EM_ASSESS):   IF UPCASE("1") = UPCASE(LEVEL) THEN DO;
MPRINT(EM_ASSESS):   NUM1 = FREQUENCY;
MPRINT(EM_ASSESS):   IF TYPE = "C" THEN do;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("EVENTVALUERAW", CRAW );
MPRINT(EM_ASSESS):   __event__ = craw;
MPRINT(EM_ASSESS):   end;
MPRINT(EM_ASSESS):   ELSE do;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("EVENTVALUERAW", NRAW );
MPRINT(EM_ASSESS):   __event__ = nraw;
MPRINT(EM_ASSESS):   end;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   IF LAST.NAME THEN DO;
 
MPRINT(EM_ASSESS):   * ;
MPRINT(EM_ASSESS):   * .............. IN NOMINAL CASE, NEED TO GROUP ALL '0' ;
MPRINT(EM_ASSESS):   *;
 
MPRINT(EM_ASSESS):   NUM0 = SUM (CUMFREQ, - NUM1);
MPRINT(EM_ASSESS):   IF NUM0 < 0 THEN NUM0 = 0;
MPRINT(EM_ASSESS):   IF NUM1 = . THEN NUM1 = 0;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUM0", NUM0 );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUM1", NUM1);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("PNUM1", NUM1 / CUMFREQ);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("PNUM0", (CUMFREQ - NUM1) / CUMFREQ);
MPRINT(EM_ASSESS):   IF TYPE = "C" THEN DO;
MPRINT(EM_ASSESS):   FLAG0_1 = 0;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("TARGETTYPE", "C" );
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE IF TYPE = "N" THEN DO;
MPRINT(EM_ASSESS):   IF "" = " " THEN DO;
MPRINT(EM_ASSESS):   IF "1" NE "1" THEN FLAG0_1 = 0;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("TARGETTYPE", "N" );
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   * ................... IF TYPE = N;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("FLAG0_1", FLAG0_1 );
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   * ..................IF LAST.NAME ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   * ...............IF LEVEL NE '.' ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   * .............. IF NAME = TARGET;
MPRINT(EM_ASSESS):   ELSE IF "" > " " AND UPCASE(NAME) = UPCASE("") THEN DO;
MPRINT(EM_ASSESS):   NUMDECISIONS + 1;
MPRINT(EM_ASSESS):   LEVEL = TRANSLATE (LEVEL, "_", "'", "_", '"');
MPRINT(EM_ASSESS):   CALL SYMPUTX ("D_LABEL" || LEFT (PUT (NUMDECISIONS, 3.)), LEVEL );
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   * ..................... ELSE IF UPCASE;
MPRINT(EM_ASSESS):   IF EOF THEN DO;
MPRINT(EM_ASSESS):   output _auxeventname;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUMOBS", CUMFREQ);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUMDECISIONS", NUMDECISIONS);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   DATA _NULL_;
MPRINT(EM_ASSESS):   SET VAROUT END = EOF;
MPRINT(EM_ASSESS):   IF UPCASE (NAME) = UPCASE ("P_RESPOND1") THEN DO;
MPRINT(EM_ASSESS):   IF N = 0 THEN DO;
MPRINT(EM_ASSESS):   PUT //// "          경고: 모든 사후확률은 결측값입니다. ";
MPRINT(EM_ASSESS):   PUT ///;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("ALLMISS", 1);
MPRINT(EM_ASSESS):   STOP;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE CALL SYMPUTX ("ALLMISS", 0);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MINPROB", MIN);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MAXPROB", MAX);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("DIFF", MAX - MIN);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NMISSPROB", NMISS);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE IF UPCASE (NAME) = UPCASE ("_tmpfreqvar_") THEN DO;
MPRINT(EM_ASSESS):   AUXMIN = MIN - INT (MIN);
MPRINT(EM_ASSESS):   AUXMAX = MAX - INT (MAX);
MPRINT(EM_ASSESS):   IF AUXMIN > 0 OR AUXMAX > 0 THEN CALL SYMPUTX ("USEWEIGHT", "Y");
MPRINT(EM_ASSESS):   ELSE CALL SYMPUTX ("USEWEIGHT", "N");
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   DATA _ANY0;
MPRINT(EM_ASSESS):   SET _ea_tmpdata (KEEP = F_RESPOND P_RESPOND1 _tmpfreqvar_ );
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ................... No Formats;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   IF LEFT ( F_RESPOND ) = "1" THEN NTARGET = 1;
MPRINT(EM_ASSESS):   ELSE NTARGET = 0;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * .............. Before proc summary of binary case;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   PROC SUMMARY DATA = _ANY0 (KEEP = P_RESPOND1 NTARGET _tmpfreqvar_ WHERE = (NTARGET > . )) NWAY MISSING;
MPRINT(EM_ASSESS):   ;
MPRINT(EM_ASSESS):   CLASS P_RESPOND1 ;
MPRINT(EM_ASSESS):   VAR NTARGET ;
MPRINT(EM_ASSESS):   FREQ _tmpfreqvar_ ;
MPRINT(EM_ASSESS):   OUTPUT OUT = ANYSUM (DROP = _TYPE_) MEAN = _MEANTARGET _MEANFREQVAR ;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   QUIT;
MPRINT(EM_ASSESS):   ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * .................... Main Data Set Processing, Binary case;
MPRINT(EM_ASSESS):   *;
 
MPRINT(EM_ASSESS):   DATA WORK._TEMPRANK (KEEP = BASECAPC BASECAP __EVENT__ BASEEVENTS BASEGAIN BASELIFT BASERESP BASERESPC BESTCAP BESTCAPC BESTGAIN BESTLIFT BESTLIFTC BESTNUMEVENTS BESTRESP BESTRESPC BIN CBASELIFT C_LIFT C_P_CAPT_RESP C_P_RESP GAIN LIFT
MAXPROB MINPROB MNPROB NUMNONRESP NUMOBS NUMRESP PERCENTILE P_CAPT_RESP P_RESP ) WORK._TEMPSCOREDIST (KEEP = BIN LOWERPROB UPPERPROB EVENTVALUE SCR_NUMEVENTS MODELSCORE SCR_NUMNONEVENTS RANGE NUMOBSINGROUP PERCOBSINGROUP C_PERCOBSINGROUP SCR_P_EVENTS
SCR_CP_EVENTS SCR_P_NONEVENTS SCR_CP_NONEVENTS SCR_MNPROB SCR_MINPROB SCR_MAXPROB ) ;
 
MPRINT(EM_ASSESS):   SET ANYSUM END = EOF;
 
MPRINT(EM_ASSESS):   IF _N_ = 1 THEN SET _AUXEVENTNAME;
 
MPRINT(EM_ASSESS):   RETAIN MINPROB1 - MINPROB20 1 MAXPROB1 - MAXPROB20 0 MNPROB1 - MNPROB20 0 NUMOBS1 - NUMOBS20 0 NUMRESP1 - NUMRESP20 0 TRUEPOS1 - TRUEPOS100 0 TRUENEG1 - TRUENEG100 0 FALSEPOS1 - FALSEPOS100 0 FALSENEG1 - FALSENEG100 0 EVENTS1 -
EVENTS100 NONEVENTS1 - NONEVENTS100 0 FIRSTIN1 - FIRSTIN100 . LASTIN1 - LASTIN100 . RESPRATE 0.0767691923 _NEVENTS 307 _NNONEVENTS 3692 TARGET "NTARGET" ;
MPRINT(EM_ASSESS):   ARRAY MINPROBS (20) MINPROB1 - MINPROB20;
MPRINT(EM_ASSESS):   ARRAY MAXPROBS (20) MAXPROB1 - MAXPROB20;
MPRINT(EM_ASSESS):   ARRAY MNPROBS (20) MNPROB1 - MNPROB20;
MPRINT(EM_ASSESS):   ARRAY NUMOBSS (20) NUMOBS1 - NUMOBS20;
MPRINT(EM_ASSESS):   ARRAY NUMRESPS (20) NUMRESP1 - NUMRESP20;
MPRINT(EM_ASSESS):   ARRAY TRUEPOSX (100) TRUEPOS1 - TRUEPOS100;
MPRINT(EM_ASSESS):   ARRAY FALSEPOSX (100) FALSEPOS1 - FALSEPOS100;
MPRINT(EM_ASSESS):   ARRAY FALSENEGX (100) FALSENEG1 - FALSENEG100;
MPRINT(EM_ASSESS):   ARRAY TRUENEGX (100) TRUENEG1 - TRUENEG100;
MPRINT(EM_ASSESS):   ARRAY _EVENTS (100) EVENTS1 - EVENTS100;
MPRINT(EM_ASSESS):   ARRAY NONEVENTS (100) NONEVENTS1 - NONEVENTS100;
MPRINT(EM_ASSESS):   ARRAY FIRSTIN (100) FIRSTIN1 - FIRSTIN100;
MPRINT(EM_ASSESS):   ARRAY LASTIN (100) LASTIN1 - LASTIN100;
MPRINT(EM_ASSESS):   RETAIN SCR_MNPROB1 - SCR_MNPROB100 0 SCR_MINPROB1 - SCR_MINPROB100 1 SCR_MAXPROB1 - SCR_MAXPROB100 0;
MPRINT(EM_ASSESS):   ARRAY SCR_MNPROBS (100) SCR_MNPROB1 - SCR_MNPROB100;
MPRINT(EM_ASSESS):   ARRAY SCR_MINPROBS (100) SCR_MINPROB1 - SCR_MINPROB100;
MPRINT(EM_ASSESS):   ARRAY SCR_MAXPROBS (100) SCR_MAXPROB1 - SCR_MAXPROB100;
MPRINT(EM_ASSESS):   DROP SCR_MINPROB1 - SCR_MINPROB100 SCR_MAXPROB1 - SCR_MAXPROB100 SCR_MNPROB1 - SCR_MNPROB100 ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ...... Area For 8 Financials ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   IF _MEANTARGET = . THEN _MEANTARGET = RESPRATE;
MPRINT(EM_ASSESS):   DROP N1 _K SUMWEIGHTS ;
MPRINT(EM_ASSESS):   SUMWEIGHTS = 1;
 
MPRINT(EM_ASSESS):   DO _K = 1 TO CEIL (_FREQ_);
MPRINT(EM_ASSESS):   IF _K = CEIL (_FREQ_) THEN DO;
MPRINT(EM_ASSESS):   IF _FREQ_ < CEIL (_FREQ_) THEN _WEIGHT = _FREQ_ - FLOOR (_FREQ_);
MPRINT(EM_ASSESS):   ELSE _WEIGHT = 1;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE _WEIGHT = 1;
MPRINT(EM_ASSESS):   N1 + _WEIGHT;
MPRINT(EM_ASSESS):   NTARGET = _MEANTARGET ;
MPRINT(EM_ASSESS):   DECILE = MIN (20, CEIL (N1 * 20 / 3999));
MPRINT(EM_ASSESS):   MINPROBS ( DECILE) = MIN (MINPROBS ( DECILE), P_RESPOND1 );
MPRINT(EM_ASSESS):   MAXPROBS ( DECILE) = MAX (MAXPROBS ( DECILE), P_RESPOND1 );
MPRINT(EM_ASSESS):   MNPROBS ( DECILE) = SUM (MNPROBS ( DECILE), P_RESPOND1 * _WEIGHT);
MPRINT(EM_ASSESS):   NUMOBSS ( DECILE) = NUMOBSS ( DECILE) + _WEIGHT;
MPRINT(EM_ASSESS):   NUMRESPS ( DECILE) = NUMRESPS ( DECILE) + _MEANTARGET * _WEIGHT;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........ outside of do loop, Area for final ROC;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   RANKDELTA = (ROUND ( _FREQ_ ) + 1) / 2;
MPRINT(EM_ASSESS):   RANK = UNTIEDRANK + RANKDELTA;
MPRINT(EM_ASSESS):   DROP RANK ;
MPRINT(EM_ASSESS):   SUMRANK1 + RANK * ROUND (_MEANTARGET * _FREQ_, .0000001);
MPRINT(EM_ASSESS):   UNTIEDRANK + ROUND (_FREQ_, .00000001);
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ............ Area For ROC Curve;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   DO _K = 1 TO 100;
MPRINT(EM_ASSESS):   IF P_RESPOND1 * 100 >= _K THEN DO;
MPRINT(EM_ASSESS):   TRUEPOSX ( _K ) + _FREQ_ * _MEANTARGET ;
MPRINT(EM_ASSESS):   FALSEPOSX ( _K ) + _FREQ_ * (1 - _MEANTARGET) ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   TRUENEGX ( _K ) + _FREQ_ * ( 1 - _MEANTARGET) ;
MPRINT(EM_ASSESS):   FALSENEGX ( _K ) + _FREQ_ * _MEANTARGET ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   SLOT = MIN (MAX (CEIL (P_RESPOND1 * 100), 1), 100) ;
MPRINT(EM_ASSESS):   DROP SLOT;
MPRINT(EM_ASSESS):   FIRSTIN ( SLOT ) = MIN ( FIRSTIN ( SLOT ), P_RESPOND1);
MPRINT(EM_ASSESS):   LASTIN ( SLOT ) = MAX ( LASTIN ( SLOT ), P_RESPOND1);
MPRINT(EM_ASSESS):   _EVENTS ( SLOT) = _EVENTS ( SLOT) + _FREQ_ * _MEANTARGET;
MPRINT(EM_ASSESS):   NONEVENTS ( SLOT) = NONEVENTS ( SLOT) + _FREQ_ * (1 - _MEANTARGET);
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........ START OF OUTDIST IN BINARY CASE MAIN DATA STEP ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   SCR_MNPROBS ( SLOT ) = SUM (SCR_MNPROBS (SLOT), P_RESPOND1 * _FREQ_ );
MPRINT(EM_ASSESS):   SCR_MINPROBS ( SLOT ) = MIN (SCR_MINPROBS (SLOT), P_RESPOND1 );
MPRINT(EM_ASSESS):   SCR_MAXPROBS ( SLOT ) = MAX (SCR_MAXPROBS (SLOT), P_RESPOND1 );
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........ End of Outdist in Binary case main DATA STEP ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   IF EOF THEN DO;
MPRINT(EM_ASSESS):   PUT //;
MPRINT(EM_ASSESS):   DO K = 1 TO 20;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   LENGTH EVENTVALUE $ 32;
MPRINT(EM_ASSESS):   RETAIN EVENTVALUE "1" ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ......... Start of EOF area of BINARY processing of main data set ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SUMRANK1", SUMRANK1);
MPRINT(EM_ASSESS):   LENGTH DATAROLE $ 10;
MPRINT(EM_ASSESS):   RETAIN DATAROLE "TRAIN" ;
MPRINT(EM_ASSESS):   RETAIN OVLMIN 0.0053553697 OVLMAX 0.50938873 ;
MPRINT(EM_ASSESS):   DROP OVLMIN OVLMAX ;
MPRINT(EM_ASSESS):   C_NUMOBS = 0;
MPRINT(EM_ASSESS):   C_NUM_RESP = 0;
MPRINT(EM_ASSESS):   C_NUM_NONRESP = 0;
MPRINT(EM_ASSESS):   C_P_RESP = 0;
MPRINT(EM_ASSESS):   P_CAPT_RESP = 0;
MPRINT(EM_ASSESS):   C_P_CAPT_RESP = 0;
MPRINT(EM_ASSESS):   PREVIOUSPROFIT = 0;
MPRINT(EM_ASSESS):   MAXPROFIT = 0;
MPRINT(EM_ASSESS):   _KS_BIN_ = 0;
MPRINT(EM_ASSESS):   DROP _KS_BIN_;
MPRINT(EM_ASSESS):   AVGNUMRESP = _NEVENTS / 20;
MPRINT(EM_ASSESS):   BASERESP = 100 * RESPRATE;
MPRINT(EM_ASSESS):   BASERESPC = BASERESP;
MPRINT(EM_ASSESS):   BASECAP = 100 / 20;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........................Start OF Gainschart = Outranks Area;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   _KS_BIN_PROB = 0;
MPRINT(EM_ASSESS):   DO GROUP = 20 TO 1 BY -1;
 
MPRINT(EM_ASSESS):   BASECAPC + BASECAP;
MPRINT(EM_ASSESS):   PERCENTILE = GROUP * (100 / 20);
MPRINT(EM_ASSESS):   MINPROB = MINPROBS ( GROUP);
MPRINT(EM_ASSESS):   MAXPROB = MAXPROBS ( GROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MINPROB" || LEFT ( PUT (GROUP, 3.)), MINPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MAXPROB" || LEFT ( PUT (GROUP, 3.)), MAXPROB);
MPRINT(EM_ASSESS):   NUMOBS = NUMOBSS ( GROUP);
MPRINT(EM_ASSESS):   IF NUMOBS > 0 THEN MNPROB = MNPROBS ( GROUP) / NUMOBS;
MPRINT(EM_ASSESS):   ELSE MNPROB = .;
MPRINT(EM_ASSESS):   C_NUMOBS = SUM (NUMOBS, C_NUMOBS);
MPRINT(EM_ASSESS):   NUMRESP = NUMRESPS ( GROUP);
MPRINT(EM_ASSESS):   NUMNONRESP = NUMOBS - NUMRESP;
MPRINT(EM_ASSESS):   C_AVGNUM_RESP + AVGNUMRESP;
MPRINT(EM_ASSESS):   IF C_NUMOBS <= _NEVENTS THEN DO;
MPRINT(EM_ASSESS):   BESTNUMEVENTS = NUMOBS;
MPRINT(EM_ASSESS):   BESTCAPC = C_NUMOBS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   BASEEVENTS = _NEVENTS / 20;
MPRINT(EM_ASSESS):   BASENONEVENTS = 0;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   FLAG + 1;
MPRINT(EM_ASSESS):   DROP FLAG;
MPRINT(EM_ASSESS):   BESTNUMEVENTS = _NEVENTS - C_NUMOBS + NUMOBS;
MPRINT(EM_ASSESS):   IF FLAG > 1 THEN BESTNUMEVENTS = 0;
MPRINT(EM_ASSESS):   BESTCAPC = 100;
MPRINT(EM_ASSESS):   IF C_NUMOBS - _NEVENTS <= NUMOBS THEN DO;
MPRINT(EM_ASSESS):   BASEEVENTS = C_NUMOBS - _NEVENTS;
MPRINT(EM_ASSESS):   BASENONEVENTS = NUMOBS - C_NUMOBS + _NEVENTS;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   BASEEVENTS = 0;
MPRINT(EM_ASSESS):   BASENONEVENTS = NUMOBS;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   BESTCAP = BESTNUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   IF C_NUMOBS <= _NEVENTS THEN DO;
MPRINT(EM_ASSESS):   BESTLIFT = ((_NEVENTS+_NNONEVENTS) / 20) /AVGNUMRESP;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   BESTLIFT = BESTNUMEVENTS / AVGNUMRESP;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   C_BESTNUMEVENTS + BESTNUMEVENTS;
MPRINT(EM_ASSESS):   DROP C_BESTNUMEVENTS;
MPRINT(EM_ASSESS):   IF C_NUMOBS > 0 THEN BESTLIFTC = C_BESTNUMEVENTS / (_NEVENTS / 3999 * C_NUMOBS);
MPRINT(EM_ASSESS):   ELSE BESTLIFTC = .;
MPRINT(EM_ASSESS):   IF NUMOBS > 0 THEN DO;
MPRINT(EM_ASSESS):   BESTRESP = BESTNUMEVENTS * 100 / NUMOBS;
MPRINT(EM_ASSESS):   P_RESP = NUMRESP * 100 / NUMOBS;
MPRINT(EM_ASSESS):   P_NONRESP = NUMNONRESP * 100 / NUMOBS;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   BESTRESP = .;
MPRINT(EM_ASSESS):   P_RESP = .;
MPRINT(EM_ASSESS):   P_NONRESP = .;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   IF C_NUMOBS > 0 THEN DO;
MPRINT(EM_ASSESS):   BESTRESPC = C_BESTNUMEVENTS * 100 / C_NUMOBS;
MPRINT(EM_ASSESS):   BESTGAIN = MAX (0, ((C_BESTNUMEVENTS / C_NUMOBS ) / ( AVGNUMRESP / (3999/20)) - 1) * 100);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   BESTRESPC = .;
MPRINT(EM_ASSESS):   BESTGAIN = .;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   IF NUMNONRESP > 0 THEN ODDS = NUMRESP / NUMNONRESP;
MPRINT(EM_ASSESS):   ELSE ODDS = .;
MPRINT(EM_ASSESS):   C_NUM_RESP = SUM (C_NUM_RESP , NUMRESP );
MPRINT(EM_ASSESS):   C_NUM_NONRESP = SUM (C_NUM_NONRESP, NUMNONRESP );
MPRINT(EM_ASSESS):   IF C_NUM_NONRESP > 0 THEN C_ODDS = C_NUM_RESP / C_NUM_NONRESP;
MPRINT(EM_ASSESS):   ELSE C_ODDS = .;
MPRINT(EM_ASSESS):   IF C_NUMOBS > 0 THEN DO;
MPRINT(EM_ASSESS):   C_P_RESP = C_NUM_RESP * 100 / C_NUMOBS;
MPRINT(EM_ASSESS):   GAIN = ABS(100 * (((C_NUM_RESP / C_NUMOBS ) / (_NEVENTS / 3999)) - 1));
MPRINT(EM_ASSESS):   BASEGAIN = 100 * (( (C_AVGNUM_RESP /((20-GROUP+1)* 3999/20) ) / ( AVGNUMRESP / (3999/20))) - 1);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   GAIN = .;
MPRINT(EM_ASSESS):   BASEGAIN = .;
MPRINT(EM_ASSESS):   C_P_RESP = .;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   IF BASEGAIN <= 0 THEN BASEGAIN = 0;
MPRINT(EM_ASSESS):   P_CAPT_RESP = NUMRESP * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   P_CAPT_NONRESP = NUMNONRESP * 100 / ( 3999 - _NEVENTS);
MPRINT(EM_ASSESS):   C_P_CAPT_RESP = C_NUM_RESP * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   C_P_CAPT_NONRESP = C_NUM_NONRESP * 100 / ( 3999 - _NEVENTS);
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * Area For Binned KS in Outranks area;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   _DIFFERENCE = C_P_CAPT_RESP - C_P_CAPT_NONRESP ;
MPRINT(EM_ASSESS):   IF _KS_BIN_ < _DIFFERENCE THEN DO;
MPRINT(EM_ASSESS):   _KS_BIN_ = _DIFFERENCE;
MPRINT(EM_ASSESS):   _KS_BIN_PROB = MINPROB + (MAXPROB - MINPROB) / 2 ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   LIFT = P_RESP * .01 / RESPRATE ;
MPRINT(EM_ASSESS):   C_LIFT = C_P_RESP * .01 / RESPRATE;
MPRINT(EM_ASSESS):   IF NUMOBS > 0 THEN DO;
MPRINT(EM_ASSESS):   BASELIFT = AVGNUMRESP / ( RESPRATE * 3999/20 );
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE BASELIFT = .;
MPRINT(EM_ASSESS):   IF C_NUMOBS > 0 THEN CBASELIFT = C_AVGNUM_RESP / (RESPRATE * ((20-GROUP+1)* 3999/20));
MPRINT(EM_ASSESS):   ELSE CBASELIFT = .;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........ WITHIN DO LOOP FOR OUTRANKS;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   BIN = 20 + 1 - GROUP;
MPRINT(EM_ASSESS):   PERCENTILE = BIN * (100 / 20);
MPRINT(EM_ASSESS):   B_C_P_RESP = PERCENTILE;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPRANK ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........................ END OF GAINSCHART = OUTRANKS AREA;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MAXPROFITGROUP" , MAXPROFITGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MAXPROFIT" , MAXPROFIT );
MPRINT(EM_ASSESS):   KS_ABSDIFF = 0 ;
MPRINT(EM_ASSESS):   MINPRECTPR = 9999;
MPRINT(EM_ASSESS):   Y0 = 1 - RESPRATE;
MPRINT(EM_ASSESS):   Y1 = RESPRATE;
MPRINT(EM_ASSESS):   MAXMUTUAL = 0;
MPRINT(EM_ASSESS):   DROP MAXMUTUAL KSPROB Y0 Y1 KS_ABSDIFF MINPRECTPR;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * .....................About to start Processing Outroc ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........................... Finished Processing Outroc ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * .............. Outdist ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   BIN = 20 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS96 - EVENTS100 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS96 - NONEVENTS100);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB96 - SCR_MNPROB100) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB96 - SCR_MINPROB100) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB96 - SCR_MAXPROB100) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 20;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 19 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS91 - EVENTS95 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS91 - NONEVENTS95);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB91 - SCR_MNPROB95) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB91 - SCR_MINPROB95) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB91 - SCR_MAXPROB95) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 19;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 18 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS86 - EVENTS90 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS86 - NONEVENTS90);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB86 - SCR_MNPROB90) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB86 - SCR_MINPROB90) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB86 - SCR_MAXPROB90) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 18;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 17 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS81 - EVENTS85 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS81 - NONEVENTS85);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB81 - SCR_MNPROB85) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB81 - SCR_MINPROB85) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB81 - SCR_MAXPROB85) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 17;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 16 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS76 - EVENTS80 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS76 - NONEVENTS80);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB76 - SCR_MNPROB80) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB76 - SCR_MINPROB80) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB76 - SCR_MAXPROB80) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 16;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 15 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS71 - EVENTS75 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS71 - NONEVENTS75);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB71 - SCR_MNPROB75) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB71 - SCR_MINPROB75) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB71 - SCR_MAXPROB75) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 15;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 14 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS66 - EVENTS70 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS66 - NONEVENTS70);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB66 - SCR_MNPROB70) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB66 - SCR_MINPROB70) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB66 - SCR_MAXPROB70) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 14;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 13 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS61 - EVENTS65 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS61 - NONEVENTS65);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB61 - SCR_MNPROB65) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB61 - SCR_MINPROB65) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB61 - SCR_MAXPROB65) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 13;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 12 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS56 - EVENTS60 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS56 - NONEVENTS60);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB56 - SCR_MNPROB60) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB56 - SCR_MINPROB60) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB56 - SCR_MAXPROB60) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 12;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 11 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS51 - EVENTS55 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS51 - NONEVENTS55);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB51 - SCR_MNPROB55) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB51 - SCR_MINPROB55) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB51 - SCR_MAXPROB55) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 11;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 10 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS46 - EVENTS50 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS46 - NONEVENTS50);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB46 - SCR_MNPROB50) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB46 - SCR_MINPROB50) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB46 - SCR_MAXPROB50) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 10;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 9 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS41 - EVENTS45 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS41 - NONEVENTS45);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB41 - SCR_MNPROB45) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB41 - SCR_MINPROB45) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB41 - SCR_MAXPROB45) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 9;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 8 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS36 - EVENTS40 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS36 - NONEVENTS40);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB36 - SCR_MNPROB40) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB36 - SCR_MINPROB40) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB36 - SCR_MAXPROB40) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 8;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 7 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS31 - EVENTS35 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS31 - NONEVENTS35);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB31 - SCR_MNPROB35) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB31 - SCR_MINPROB35) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB31 - SCR_MAXPROB35) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 7;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 6 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS26 - EVENTS30 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS26 - NONEVENTS30);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB26 - SCR_MNPROB30) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB26 - SCR_MINPROB30) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB26 - SCR_MAXPROB30) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 6;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 5 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS21 - EVENTS25 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS21 - NONEVENTS25);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB21 - SCR_MNPROB25) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB21 - SCR_MINPROB25) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB21 - SCR_MAXPROB25) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 5;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 4 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS16 - EVENTS20 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS16 - NONEVENTS20);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB16 - SCR_MNPROB20) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB16 - SCR_MINPROB20) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB16 - SCR_MAXPROB20) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 4;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 3 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS11 - EVENTS15 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS11 - NONEVENTS15);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB11 - SCR_MNPROB15) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB11 - SCR_MINPROB15) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB11 - SCR_MAXPROB15) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 3;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 2 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS6 - EVENTS10 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS6 - NONEVENTS10);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB6 - SCR_MNPROB10) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB6 - SCR_MINPROB10) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB6 - SCR_MAXPROB10) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 2;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 1 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS1 - EVENTS5 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS1 - NONEVENTS5);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB1 - SCR_MNPROB5) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB1 - SCR_MINPROB5) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB1 - SCR_MAXPROB5) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3999;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 1;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("KSPROB" , PUT (KSPROB, 5.3 ) );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("_KS_BIN_PROB" , _KS_BIN_PROB );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("_KS_BIN_" , _KS_BIN_ / 100 );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("KSDIFF" , KS_ABSDIFF );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("PRECTPR" , PRECTPR );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MAXMUTUALPROB" , MAXMUTUALPROB);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   LABEL __EVENT__ = "이벤트" DECILE = "깊이" BIN = "범주" NUMOBS = "관측치 수" ;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * RUN for large data set;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   PROC DATASETS NOLIST;
MPRINT(EM_ASSESS):   DELETE _AUXEVENTNAME;
MPRINT(EM_ASSESS):   QUIT;
 
MPRINT(EM_ASSESS):   OPTION NOCENTER LS = 95;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * Report Vars Area.;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ...........Start OF Outdist Modification;
MPRINT(EM_ASSESS):   *;
 
MPRINT(EM_ASSESS):   PROC DATASETS NOLIST LIB = WORK;
MPRINT(EM_ASSESS):   MODIFY _TEMPSCOREDIST;
MPRINT(EM_ASSESS):   RENAME MODELSCORE = SCORE UPPERPROB = UPPOSTERIOR SCR_CP_EVENTS =
CUMULATIVEPERCENTAGEOFEVENTS SCR_CP_NONEVENTS = CUMULATIVEPERCENTAGEOFNONEVENTS EVENTVALUE =
EVENT LOWERPROB = LOWPOSTERIOR NUMOBSINGROUP = N PERCOBSINGROUP = PERCENTAGE SCR_MINPROB =
_MINP_ SCR_MAXPROB = _MAXP_ SCR_MNPROB = _MEANP_ RANGE = P_LABEL C_PERCOBSINGROUP =
CUMULATIVEPERCENTAGE SCR_NUMEVENTS = NUMBEROFEVENTS SCR_NUMNONEVENTS = NUMBEROFNONEVENTS
SCR_P_EVENTS = PERCENTAGEOFEVENTS SCR_P_NONEVENTS = PERCENTAGEOFNONEVENTS ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * .................... OUTDIST MODIFICATION LABEL AREA;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   LABEL BIN = "범주" N = "관측치 수" P_LABEL = "사후확률 범위" EVENT =
"이벤트" LOWPOSTERIOR = "사후확률 하한" PERCENTAGEOFEVENTS = "이벤트 백분율"
CUMULATIVEPERCENTAGEOFNONEVENTS = "누적 비이벤트 백분율" CUMULATIVEPERCENTAGE = "누적 백분율"
PERCENTAGEOFEVENTS = "이벤트 백분율" PERCENTAGEOFNONEVENTS = "비이벤트 백분율"
CUMULATIVEPERCENTAGEOFEVENTS = "누적 이벤트 백분율" UPPOSTERIOR = "사후확률 상한"
NUMBEROFEVENTS = "이벤트 수" PERCENTAGE = "백분율" NUMBEROFNONEVENTS = "비이벤트 수" _MEANP_ =
"평균 사후확률" _MINP_ = "최소 사후확률" _MAXP_ = "최대 사후확률" SCORE = "모델 스코어" ;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   QUIT;
MPRINT(EM_ASSESS):   DATA WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   SET WORK._TEMPSCOREDIST (WHERE = (_MEANP_ > .));
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........... END OF OUTDIST MODIFICATION;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ...........Start of OUTRANKS Modification;
MPRINT(EM_ASSESS):   *;
 
MPRINT(EM_ASSESS):   PROC DATASETS NOLIST LIB = WORK;
MPRINT(EM_ASSESS):   MODIFY _TEMPRANK;
MPRINT(EM_ASSESS):   RENAME __EVENT__ = EVENT P_RESP = RESP C_P_CAPT_RESP = CAPC P_CAPT_RESP =
CAP NUMNONRESP = NUMNEVENT NUMRESP = NUMEVENT BASEEVENTS = BASENUMBEROFEVENTS BESTNUMEVENTS =
BESTNUMBEROFEVENTS MAXPROB = _MAXP_ MINPROB = _MINP_ CBASELIFT = BASELIFTC C_LIFT = LIFTC
MNPROB = _MEANP_ PERCENTILE = DECILE NUMOBS = N NUMEVENT = NUMBEROFEVENTS C_P_RESP = RESPC ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ................. OUTRANKS;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   LABEL _MAXP_ = "최대 사후확률" _MINP_ = "최소 사후확률" _MEANP_ = "평균
사후확률" BASECAP = "기준 반응검출률" BASECAPC = "기준 누적 반응검출률" BASENUMBEROFEVENTS =
"기준 이벤트 수" BASEGAIN = "기준 이득" BASELIFT = "기준 향상도" BASELIFTC = "기준 누적
향상도" BASERESP = "기준 반응률" BASERESPC = "기준 누적반응률" BASELIFTC = "기준 누적 향상도"
BESTCAP = "최적 반응검출률" BESTCAPC = "최적 누적 반응검출률" BESTGAIN = "최적 이득" BESTRESP
= "최적 반응률" BESTRESPC = "최적 누적반응률" BESTLIFT = "최적 향상도" BESTLIFTC = "최적 누적
향상도" BESTNUMBEROFEVENTS = "최적 이벤트 수" CAP = "반응검출률" CAPC = "누적 반응검출률"
DECILE = "깊이" GAIN = "이득" LIFT = "향상도" LIFTC = "누적 향상도" NUMNEVENT = "비이벤트 수"
N = "관측치 수" EVENT = "이벤트" RESPC = "누적반응률" NUMBEROFEVENTS = "이벤트 수" RESP =
"반응률" ;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   QUIT;
MPRINT(EM_ASSESS):   DATA WORK._TEMPRANK;
MPRINT(EM_ASSESS):   SET WORK._TEMPRANK (WHERE = (_MEANP_ > .));
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   proc datasets lib=work nolist;
MPRINT(EM_ASSESS):   delete _ea_tmpdata;
MPRINT(EM_ASSESS):   run;
MPRINT(EM_ASSESS):   quit;
MPRINT(EM_ASSESS):  ;
MPRINT(EM_ASSESS):   OPTION ERRORS = 20;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):    data WORK._TEMPRANK;
MPRINT(EM_DIAGRAM):   length target $32 TARGETLABEL $200 dataRole $20;
MPRINT(EM_DIAGRAM):   label TARGETLABEL = "타겟 레이블";
MPRINT(EM_DIAGRAM):   set WORK._TEMPRANK;
MPRINT(EM_DIAGRAM):   retain target "RESPOND";
MPRINT(EM_DIAGRAM):   retain dataRole "TRAIN";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_EMRANK;
MPRINT(EM_DIAGRAM):   set WORK._TEMPRANK;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data WORK._TEMPSCOREDIST;
MPRINT(EM_DIAGRAM):   length target $32 TARGETLABEL $200 dataRole $20;
MPRINT(EM_DIAGRAM):   label TARGETLABEL = "타겟 레이블";
MPRINT(EM_DIAGRAM):   set WORK._TEMPSCOREDIST;
MPRINT(EM_DIAGRAM):   retain target "RESPOND";
MPRINT(EM_DIAGRAM):   retain dataRole "TRAIN";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_EMSCOREDIST;
MPRINT(EM_DIAGRAM):   set WORK._TEMPSCOREDIST;
MPRINT(EM_DIAGRAM):   run;
41325      data EM_temp_assessMeta;
MPRINT(EM_DIAGRAM):    data EM_temp_assessMeta;
41326      set EMWS6.Neural_CMeta_TRAIN;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_CMeta_TRAIN;
41327      where role in('DECISION', 'PREDICT', 'RESIDUAL', 'CLASSIFICATION', 'ASSESS', 'COST')
41327    ! ;
MPRINT(EM_DIAGRAM):   where role in('DECISION', 'PREDICT', 'RESIDUAL', 'CLASSIFICATION',
'ASSESS', 'COST');
41328      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 8개의 관측값을 데이터셋 EMWS6.NEURAL_CMETA_TRAIN.에서 읽었습니다.
      WHERE role in ('ASSESS', 'CLASSIFICATION', 'COST', 'DECISION', 'PREDICT', 'RESIDUAL');
NOTE: 데이터셋 WORK.EM_TEMP_ASSESSMETA은(는) 8개의 관측값과 21개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
41329      data EM_temp_assessdata;
MPRINT(EM_DIAGRAM):    data EM_temp_assessdata;
41330      set EMWS6.Neural_VALIDATE(keep=
41331      F_RESPOND
41332      I_RESPOND
41333      P_RESPOND0
41334      P_RESPOND1
41335      R_RESPOND0
41336      R_RESPOND1
41337      U_RESPOND
41338      _WARN_
41339      RESPOND
41340      );
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_VALIDATE(keep= F_RESPOND I_RESPOND P_RESPOND0
P_RESPOND1 R_RESPOND0 R_RESPOND1 U_RESPOND _WARN_ RESPOND );
41341      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: View EMWS6.NEURAL_VALIDATE.VIEW 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
NOTE: 3000개의 관측값을 데이터셋 EMWS6.PART_VALIDATE.에서 읽었습니다.
NOTE: 3000개의 관측값을 데이터셋 EMWS6.NEURAL_VALIDATE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_TEMP_ASSESSDATA은(는) 3000개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
 
 
MPRINT(EM_DIAGRAM):    proc freq data=EM_temp_assessdata noprint;
MPRINT(EM_DIAGRAM):   table I_RESPOND*F_RESPOND / out = WORK.Neural_1S717LL nocol norow outpct;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data WORK.Neural_1S717LL;
MPRINT(EM_DIAGRAM):   length _TYPE_ $10 DATAROLE TARGET $32 TARGETLABEL $200 FROM INTO $32
CORRECTTEXT $40 ;
MPRINT(EM_DIAGRAM):   label _TYPE_ = "결과 유형";
MPRINT(EM_DIAGRAM):   label DATAROLE = "데이터 역할";
MPRINT(EM_DIAGRAM):   label TARGET = "타겟 변수";
MPRINT(EM_DIAGRAM):   label TARGETLABEL = "타겟 레이블";
MPRINT(EM_DIAGRAM):   label FROM = "타겟";
MPRINT(EM_DIAGRAM):   label INTO = "결과";
MPRINT(EM_DIAGRAM):   label PCT_ROW = "타겟 백분율";
MPRINT(EM_DIAGRAM):   label PCT_COL = "결과 백분율";
MPRINT(EM_DIAGRAM):   label COUNT = "빈도 개수";
MPRINT(EM_DIAGRAM):   label PERCENT = "총 백분율";
MPRINT(EM_DIAGRAM):   label CORRECTTEXT = "Correct 텍스트";
MPRINT(EM_DIAGRAM):   label CORRECT = "올바름";
MPRINT(EM_DIAGRAM):   set WORK.Neural_1S717LL(rename=(F_RESPOND=FROM I_RESPOND=INTO));
MPRINT(EM_DIAGRAM):   retain _TYPE_ 'PREDICTION' DATAROLE "VALIDATE" TARGET "RESPOND";
MPRINT(EM_DIAGRAM):   if FROM eq INTO then do;
MPRINT(EM_DIAGRAM):   CORRECT = 0;
MPRINT(EM_DIAGRAM):   CORRECTTEXT="올바름";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else do;
MPRINT(EM_DIAGRAM):   CORRECT = 1;
MPRINT(EM_DIAGRAM):   CORRECTTEXT="올바르지 않음";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data EMWS6.Neural_EMCLASSIFICATION;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_EMCLASSIFICATION WORK.Neural_1S717LL;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data WORK.MISCREPORT;
MPRINT(EM_DIAGRAM):   set WORK.Neural_1S717LL;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data WORK.MISCREPORT(drop=INTO FROM _TYPE_);
MPRINT(EM_DIAGRAM):   set WORK.MISCREPORT;
MPRINT(EM_DIAGRAM):   length MISC $12;
MPRINT(EM_DIAGRAM):   if FROM='1' and INTO='1' then MISC='TRUEEVENT';
MPRINT(EM_DIAGRAM):   else if FROM='1' and INTO ne '1' then MISC='FALSENEVENT';
MPRINT(EM_DIAGRAM):   else if FROM ne '1' and INTO='1' then MISC='FALSEEVENT';
MPRINT(EM_DIAGRAM):   else if FROM ne'1' and INTO ne '1' then MISC='TRUENEVENT';
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc sort data=WORK.MISCREPORT nothreads;
MPRINT(EM_DIAGRAM):   by DATAROLE TARGET;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc summary data=WORK.MISCREPORT NWAY;
MPRINT(EM_DIAGRAM):   output out=WORK.MISCCOUNT(drop=_FREQ_ _TYPE_) SUM=COUNT;
MPRINT(EM_DIAGRAM):   CLASS MISC;
MPRINT(EM_DIAGRAM):   VAR COUNT;
MPRINT(EM_DIAGRAM):   by DATAROLE TARGET;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc transpose data=WORK.MISCCOUNT out=WORK.MISCREPORT(drop=_NAME_
_LABEL_);
MPRINT(EM_DIAGRAM):   by DATAROLE TARGET;
MPRINT(EM_DIAGRAM):   ID MISC;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data EMWS6.Neural_EMEVENTREPORT;
MPRINT(EM_DIAGRAM):   length TARGETLABEL $200;
MPRINT(EM_DIAGRAM):   label TARGETLABEL = "타겟 레이블";
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_EMEVENTREPORT WORK.MISCREPORT;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data ASSESS_REPORTMETA;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_VariableSet;
MPRINT(EM_DIAGRAM):   where REPORT='Y';
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename temp catalog 'sashelp.emassmt.em_assess.source';
MPRINT(EM_DIAGRAM):   filename temp;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   set EMWS6.Ids_RESPOND_DM;
MPRINT(EM_DIAGRAM):   where _TYPE_="TARGET";
MPRINT(EM_DIAGRAM):   call symput('ASSMT_EVENT', strip(event));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):
MPRINT(EM_ASSESS):   data _ea_tmpdata;
MPRINT(EM_ASSESS):   set EM_temp_assessdata;
MPRINT(EM_ASSESS):   _tmpfreqvar_=1;
MPRINT(EM_ASSESS):   run;
MPRINT(EM_CHECKEMSETINIT):   DATA _NULL_;
MPRINT(EM_CHECKEMSETINIT):   EM_SETINIT = 'N';
MPRINT(EM_CHECKEMSETINIT):   IF SYSPROD('PRODNUM50') THEN EM_SETINIT = 'Y';
MPRINT(EM_CHECKEMSETINIT):   ELSE IF SYSPROD('PRODNUM448') THEN EM_SETINIT = 'Y';
MPRINT(EM_CHECKEMSETINIT):   ELSE IF SYSPROD('PRODNUM102') THEN EM_SETINIT = 'Y';
MPRINT(EM_CHECKEMSETINIT):   ELSE IF SYSPROD('PRODNUM103') THEN EM_SETINIT = 'Y';
MPRINT(EM_CHECKEMSETINIT):   CALL SYMPUT('EM_SETINIT', EM_SETINIT);
MPRINT(EM_CHECKEMSETINIT):   RUN;
MPRINT(EM_ASSESS):  ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ............ Reading in reporting data set;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   DATA _NULL_;
MPRINT(EM_ASSESS):   SET ASSESS_REPORTMETA END = EOF;
MPRINT(EM_ASSESS):   IF TYPE = "C" OR UPCASE (LEVEL) IN ("NOMINAL", "BINARY" , "ORDINAL") THEN
DO;
MPRINT(EM_ASSESS):   IF UPCASE (NAME) NE UPCASE ("F_RESPOND") THEN DO;
MPRINT(EM_ASSESS):   NUMCTOREPORT + 1;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("REPORTC" || LEFT (PUT (NUMCTOREPORT, 5.)), NAME);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE CALL SYMPUTX ("RPRT_TRGT", "C");
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE IF TYPE = "N" THEN DO;
MPRINT(EM_ASSESS):   IF UPCASE(NAME) NE UPCASE ("F_RESPOND") THEN DO;
MPRINT(EM_ASSESS):   NUMNTOREPORT + 1;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("REPORTN" || LEFT (PUT (NUMNTOREPORT, 5.)), NAME);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE CALL SYMPUTX ("RPRT_TRGT", "N");
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   IF EOF THEN DO;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUMNTOREPORT", NUMNTOREPORT);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUMCTOREPORT", NUMCTOREPORT);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUMTOREPORT", SUM (NUMNTOREPORT, NUMCTOREPORT));
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   PROC DMDB DATA = _ea_tmpdata VAROUT = VAROUT DMDBCAT = _D CLASSOUT =
_ASSMT_CLASSOUT;
MPRINT(EM_ASSESS):   CLASS F_RESPOND ;
 
MPRINT(EM_ASSESS):   VAR P_RESPOND1 _tmpfreqvar_ ;
MPRINT(EM_ASSESS):   FREQ _tmpfreqvar_;
MPRINT(EM_ASSESS):   RUN ;
MPRINT(EM_ASSESS):   QUIT;
MPRINT(EM_ASSESS):   PROC SORT DATA = _ASSMT_CLASSOUT;
MPRINT(EM_ASSESS):   BY NAME;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   DATA _auxeventname (keep = __event__) ;
MPRINT(EM_ASSESS):   * ;
MPRINT(EM_ASSESS):   * ...FLAG0_1 = ..... TARGET IS 0, 1 & EVENT = 1;
 
MPRINT(EM_ASSESS):   ;
MPRINT(EM_ASSESS):   length __event__ $ 32;
MPRINT(EM_ASSESS):   RETAIN FLAG0_1 1 NUM1 . NUM0 . __event__ "_missing_" ;
 
MPRINT(EM_ASSESS):   SET _ASSMT_CLASSOUT END = EOF;
MPRINT(EM_ASSESS):   BY NAME;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ....... LEVEL = BINARY OR NOMINAL OR ORDINAL;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
 
MPRINT(EM_ASSESS):   IF UPCASE(NAME) = UPCASE ("F_RESPOND") THEN DO;
MPRINT(EM_ASSESS):   CUMFREQ + FREQUENCY;
MPRINT(EM_ASSESS):   IF LEVEL NE "." THEN DO;
MPRINT(EM_ASSESS):   N1 + 1;
MPRINT(EM_ASSESS):   IF (NRAW NE 0 AND NRAW NE 1) OR TYPE NE "N" OR "" > " " THEN FLAG0_1 = 0;
MPRINT(EM_ASSESS):   * ;
MPRINT(EM_ASSESS):   * ......................... IF EVENT NE BLANK;
MPRINT(EM_ASSESS):   * ....................LEVEL IS CHAR VAR ;
MPRINT(EM_ASSESS):   * ;
MPRINT(EM_ASSESS):   IF UPCASE("1") = UPCASE(LEVEL) THEN DO;
MPRINT(EM_ASSESS):   NUM1 = FREQUENCY;
MPRINT(EM_ASSESS):   IF TYPE = "C" THEN do;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("EVENTVALUERAW", CRAW );
MPRINT(EM_ASSESS):   __event__ = craw;
MPRINT(EM_ASSESS):   end;
MPRINT(EM_ASSESS):   ELSE do;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("EVENTVALUERAW", NRAW );
MPRINT(EM_ASSESS):   __event__ = nraw;
MPRINT(EM_ASSESS):   end;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   IF LAST.NAME THEN DO;
 
MPRINT(EM_ASSESS):   * ;
MPRINT(EM_ASSESS):   * .............. IN NOMINAL CASE, NEED TO GROUP ALL '0' ;
MPRINT(EM_ASSESS):   *;
 
MPRINT(EM_ASSESS):   NUM0 = SUM (CUMFREQ, - NUM1);
MPRINT(EM_ASSESS):   IF NUM0 < 0 THEN NUM0 = 0;
MPRINT(EM_ASSESS):   IF NUM1 = . THEN NUM1 = 0;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUM0", NUM0 );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUM1", NUM1);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("PNUM1", NUM1 / CUMFREQ);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("PNUM0", (CUMFREQ - NUM1) / CUMFREQ);
MPRINT(EM_ASSESS):   IF TYPE = "C" THEN DO;
MPRINT(EM_ASSESS):   FLAG0_1 = 0;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("TARGETTYPE", "C" );
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE IF TYPE = "N" THEN DO;
MPRINT(EM_ASSESS):   IF "" = " " THEN DO;
MPRINT(EM_ASSESS):   IF "1" NE "1" THEN FLAG0_1 = 0;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("TARGETTYPE", "N" );
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   * ................... IF TYPE = N;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("FLAG0_1", FLAG0_1 );
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   * ..................IF LAST.NAME ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   * ...............IF LEVEL NE '.' ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   * .............. IF NAME = TARGET;
MPRINT(EM_ASSESS):   ELSE IF "" > " " AND UPCASE(NAME) = UPCASE("") THEN DO;
MPRINT(EM_ASSESS):   NUMDECISIONS + 1;
MPRINT(EM_ASSESS):   LEVEL = TRANSLATE (LEVEL, "_", "'", "_", '"');
MPRINT(EM_ASSESS):   CALL SYMPUTX ("D_LABEL" || LEFT (PUT (NUMDECISIONS, 3.)), LEVEL );
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   * ..................... ELSE IF UPCASE;
MPRINT(EM_ASSESS):   IF EOF THEN DO;
MPRINT(EM_ASSESS):   output _auxeventname;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUMOBS", CUMFREQ);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NUMDECISIONS", NUMDECISIONS);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   DATA _NULL_;
MPRINT(EM_ASSESS):   SET VAROUT END = EOF;
MPRINT(EM_ASSESS):   IF UPCASE (NAME) = UPCASE ("P_RESPOND1") THEN DO;
MPRINT(EM_ASSESS):   IF N = 0 THEN DO;
MPRINT(EM_ASSESS):   PUT //// "          경고: 모든 사후확률은 결측값입니다. ";
MPRINT(EM_ASSESS):   PUT ///;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("ALLMISS", 1);
MPRINT(EM_ASSESS):   STOP;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE CALL SYMPUTX ("ALLMISS", 0);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MINPROB", MIN);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MAXPROB", MAX);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("DIFF", MAX - MIN);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("NMISSPROB", NMISS);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE IF UPCASE (NAME) = UPCASE ("_tmpfreqvar_") THEN DO;
MPRINT(EM_ASSESS):   AUXMIN = MIN - INT (MIN);
MPRINT(EM_ASSESS):   AUXMAX = MAX - INT (MAX);
MPRINT(EM_ASSESS):   IF AUXMIN > 0 OR AUXMAX > 0 THEN CALL SYMPUTX ("USEWEIGHT", "Y");
MPRINT(EM_ASSESS):   ELSE CALL SYMPUTX ("USEWEIGHT", "N");
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   DATA _ANY0;
MPRINT(EM_ASSESS):   SET _ea_tmpdata (KEEP = F_RESPOND P_RESPOND1 _tmpfreqvar_ );
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ................... No Formats;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   IF LEFT ( F_RESPOND ) = "1" THEN NTARGET = 1;
MPRINT(EM_ASSESS):   ELSE NTARGET = 0;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * .............. Before proc summary of binary case;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   PROC SUMMARY DATA = _ANY0 (KEEP = P_RESPOND1 NTARGET _tmpfreqvar_ WHERE =
(NTARGET > . )) NWAY MISSING;
MPRINT(EM_ASSESS):   ;
MPRINT(EM_ASSESS):   CLASS P_RESPOND1 ;
MPRINT(EM_ASSESS):   VAR NTARGET ;
MPRINT(EM_ASSESS):   FREQ _tmpfreqvar_ ;
MPRINT(EM_ASSESS):   OUTPUT OUT = ANYSUM (DROP = _TYPE_) MEAN = _MEANTARGET _MEANFREQVAR ;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   QUIT;
MPRINT(EM_ASSESS):   ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * .................... Main Data Set Processing, Binary case;
MPRINT(EM_ASSESS):   *;
 
MPRINT(EM_ASSESS):   DATA WORK._TEMPRANK (KEEP = BASECAPC BASECAP __EVENT__ BASEEVENTS
BASEGAIN BASELIFT BASERESP BASERESPC BESTCAP BESTCAPC BESTGAIN BESTLIFT BESTLIFTC
BESTNUMEVENTS BESTRESP BESTRESPC BIN CBASELIFT C_LIFT C_P_CAPT_RESP C_P_RESP GAIN LIFT MAXPROB
MINPROB MNPROB NUMNONRESP NUMOBS NUMRESP PERCENTILE P_CAPT_RESP P_RESP ) WORK._TEMPSCOREDIST
(KEEP = BIN LOWERPROB UPPERPROB EVENTVALUE SCR_NUMEVENTS MODELSCORE SCR_NUMNONEVENTS RANGE
NUMOBSINGROUP PERCOBSINGROUP C_PERCOBSINGROUP SCR_P_EVENTS SCR_CP_EVENTS SCR_P_NONEVENTS
SCR_CP_NONEVENTS SCR_MNPROB SCR_MINPROB SCR_MAXPROB ) ;
 
MPRINT(EM_ASSESS):   SET ANYSUM END = EOF;
 
MPRINT(EM_ASSESS):   IF _N_ = 1 THEN SET _AUXEVENTNAME;
 
MPRINT(EM_ASSESS):   RETAIN MINPROB1 - MINPROB20 1 MAXPROB1 - MAXPROB20 0 MNPROB1 - MNPROB20 0
NUMOBS1 - NUMOBS20 0 NUMRESP1 - NUMRESP20 0 TRUEPOS1 - TRUEPOS100 0 TRUENEG1 - TRUENEG100 0
FALSEPOS1 - FALSEPOS100 0 FALSENEG1 - FALSENEG100 0 EVENTS1 - EVENTS100 NONEVENTS1 -
NONEVENTS100 0 FIRSTIN1 - FIRSTIN100 . LASTIN1 - LASTIN100 . RESPRATE 0.0766666667 _NEVENTS
230 _NNONEVENTS 2770 TARGET "NTARGET" ;
MPRINT(EM_ASSESS):   ARRAY MINPROBS (20) MINPROB1 - MINPROB20;
MPRINT(EM_ASSESS):   ARRAY MAXPROBS (20) MAXPROB1 - MAXPROB20;
MPRINT(EM_ASSESS):   ARRAY MNPROBS (20) MNPROB1 - MNPROB20;
MPRINT(EM_ASSESS):   ARRAY NUMOBSS (20) NUMOBS1 - NUMOBS20;
MPRINT(EM_ASSESS):   ARRAY NUMRESPS (20) NUMRESP1 - NUMRESP20;
MPRINT(EM_ASSESS):   ARRAY TRUEPOSX (100) TRUEPOS1 - TRUEPOS100;
MPRINT(EM_ASSESS):   ARRAY FALSEPOSX (100) FALSEPOS1 - FALSEPOS100;
MPRINT(EM_ASSESS):   ARRAY FALSENEGX (100) FALSENEG1 - FALSENEG100;
MPRINT(EM_ASSESS):   ARRAY TRUENEGX (100) TRUENEG1 - TRUENEG100;
MPRINT(EM_ASSESS):   ARRAY _EVENTS (100) EVENTS1 - EVENTS100;
MPRINT(EM_ASSESS):   ARRAY NONEVENTS (100) NONEVENTS1 - NONEVENTS100;
MPRINT(EM_ASSESS):   ARRAY FIRSTIN (100) FIRSTIN1 - FIRSTIN100;
MPRINT(EM_ASSESS):   ARRAY LASTIN (100) LASTIN1 - LASTIN100;
MPRINT(EM_ASSESS):   RETAIN SCR_MNPROB1 - SCR_MNPROB100 0 SCR_MINPROB1 - SCR_MINPROB100 1
SCR_MAXPROB1 - SCR_MAXPROB100 0;
MPRINT(EM_ASSESS):   ARRAY SCR_MNPROBS (100) SCR_MNPROB1 - SCR_MNPROB100;
MPRINT(EM_ASSESS):   ARRAY SCR_MINPROBS (100) SCR_MINPROB1 - SCR_MINPROB100;
MPRINT(EM_ASSESS):   ARRAY SCR_MAXPROBS (100) SCR_MAXPROB1 - SCR_MAXPROB100;
MPRINT(EM_ASSESS):   DROP SCR_MINPROB1 - SCR_MINPROB100 SCR_MAXPROB1 - SCR_MAXPROB100
SCR_MNPROB1 - SCR_MNPROB100 ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ...... Area For 8 Financials ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   IF _MEANTARGET = . THEN _MEANTARGET = RESPRATE;
MPRINT(EM_ASSESS):   DROP N1 _K SUMWEIGHTS ;
MPRINT(EM_ASSESS):   SUMWEIGHTS = 1;
 
MPRINT(EM_ASSESS):   DO _K = 1 TO CEIL (_FREQ_);
MPRINT(EM_ASSESS):   IF _K = CEIL (_FREQ_) THEN DO;
MPRINT(EM_ASSESS):   IF _FREQ_ < CEIL (_FREQ_) THEN _WEIGHT = _FREQ_ - FLOOR (_FREQ_);
MPRINT(EM_ASSESS):   ELSE _WEIGHT = 1;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE _WEIGHT = 1;
MPRINT(EM_ASSESS):   N1 + _WEIGHT;
MPRINT(EM_ASSESS):   NTARGET = _MEANTARGET ;
MPRINT(EM_ASSESS):   DECILE = MIN (20, CEIL (N1 * 20 / 3000));
MPRINT(EM_ASSESS):   MINPROBS ( DECILE) = MIN (MINPROBS ( DECILE), P_RESPOND1 );
MPRINT(EM_ASSESS):   MAXPROBS ( DECILE) = MAX (MAXPROBS ( DECILE), P_RESPOND1 );
MPRINT(EM_ASSESS):   MNPROBS ( DECILE) = SUM (MNPROBS ( DECILE), P_RESPOND1 * _WEIGHT);
MPRINT(EM_ASSESS):   NUMOBSS ( DECILE) = NUMOBSS ( DECILE) + _WEIGHT;
MPRINT(EM_ASSESS):   NUMRESPS ( DECILE) = NUMRESPS ( DECILE) + _MEANTARGET * _WEIGHT;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........ outside of do loop, Area for final ROC;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   RANKDELTA = (ROUND ( _FREQ_ ) + 1) / 2;
MPRINT(EM_ASSESS):   RANK = UNTIEDRANK + RANKDELTA;
MPRINT(EM_ASSESS):   DROP RANK ;
MPRINT(EM_ASSESS):   SUMRANK1 + RANK * ROUND (_MEANTARGET * _FREQ_, .0000001);
MPRINT(EM_ASSESS):   UNTIEDRANK + ROUND (_FREQ_, .00000001);
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ............ Area For ROC Curve;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   DO _K = 1 TO 100;
MPRINT(EM_ASSESS):   IF P_RESPOND1 * 100 >= _K THEN DO;
MPRINT(EM_ASSESS):   TRUEPOSX ( _K ) + _FREQ_ * _MEANTARGET ;
MPRINT(EM_ASSESS):   FALSEPOSX ( _K ) + _FREQ_ * (1 - _MEANTARGET) ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   TRUENEGX ( _K ) + _FREQ_ * ( 1 - _MEANTARGET) ;
MPRINT(EM_ASSESS):   FALSENEGX ( _K ) + _FREQ_ * _MEANTARGET ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   SLOT = MIN (MAX (CEIL (P_RESPOND1 * 100), 1), 100) ;
MPRINT(EM_ASSESS):   DROP SLOT;
MPRINT(EM_ASSESS):   FIRSTIN ( SLOT ) = MIN ( FIRSTIN ( SLOT ), P_RESPOND1);
MPRINT(EM_ASSESS):   LASTIN ( SLOT ) = MAX ( LASTIN ( SLOT ), P_RESPOND1);
MPRINT(EM_ASSESS):   _EVENTS ( SLOT) = _EVENTS ( SLOT) + _FREQ_ * _MEANTARGET;
MPRINT(EM_ASSESS):   NONEVENTS ( SLOT) = NONEVENTS ( SLOT) + _FREQ_ * (1 - _MEANTARGET);
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........ START OF OUTDIST IN BINARY CASE MAIN DATA STEP ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   SCR_MNPROBS ( SLOT ) = SUM (SCR_MNPROBS (SLOT), P_RESPOND1 * _FREQ_ );
MPRINT(EM_ASSESS):   SCR_MINPROBS ( SLOT ) = MIN (SCR_MINPROBS (SLOT), P_RESPOND1 );
MPRINT(EM_ASSESS):   SCR_MAXPROBS ( SLOT ) = MAX (SCR_MAXPROBS (SLOT), P_RESPOND1 );
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........ End of Outdist in Binary case main DATA STEP ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   IF EOF THEN DO;
MPRINT(EM_ASSESS):   PUT //;
MPRINT(EM_ASSESS):   DO K = 1 TO 20;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   LENGTH EVENTVALUE $ 32;
MPRINT(EM_ASSESS):   RETAIN EVENTVALUE "1" ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ......... Start of EOF area of BINARY processing of main data set ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SUMRANK1", SUMRANK1);
MPRINT(EM_ASSESS):   LENGTH DATAROLE $ 10;
MPRINT(EM_ASSESS):   RETAIN DATAROLE "VALIDATE" ;
MPRINT(EM_ASSESS):   RETAIN OVLMIN 0.005370582 OVLMAX 0.5121622144 ;
MPRINT(EM_ASSESS):   DROP OVLMIN OVLMAX ;
MPRINT(EM_ASSESS):   C_NUMOBS = 0;
MPRINT(EM_ASSESS):   C_NUM_RESP = 0;
MPRINT(EM_ASSESS):   C_NUM_NONRESP = 0;
MPRINT(EM_ASSESS):   C_P_RESP = 0;
MPRINT(EM_ASSESS):   P_CAPT_RESP = 0;
MPRINT(EM_ASSESS):   C_P_CAPT_RESP = 0;
MPRINT(EM_ASSESS):   PREVIOUSPROFIT = 0;
MPRINT(EM_ASSESS):   MAXPROFIT = 0;
MPRINT(EM_ASSESS):   _KS_BIN_ = 0;
MPRINT(EM_ASSESS):   DROP _KS_BIN_;
MPRINT(EM_ASSESS):   AVGNUMRESP = _NEVENTS / 20;
MPRINT(EM_ASSESS):   BASERESP = 100 * RESPRATE;
MPRINT(EM_ASSESS):   BASERESPC = BASERESP;
MPRINT(EM_ASSESS):   BASECAP = 100 / 20;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........................Start OF Gainschart = Outranks Area;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   _KS_BIN_PROB = 0;
MPRINT(EM_ASSESS):   DO GROUP = 20 TO 1 BY -1;
 
MPRINT(EM_ASSESS):   BASECAPC + BASECAP;
MPRINT(EM_ASSESS):   PERCENTILE = GROUP * (100 / 20);
MPRINT(EM_ASSESS):   MINPROB = MINPROBS ( GROUP);
MPRINT(EM_ASSESS):   MAXPROB = MAXPROBS ( GROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MINPROB" || LEFT ( PUT (GROUP, 3.)), MINPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MAXPROB" || LEFT ( PUT (GROUP, 3.)), MAXPROB);
MPRINT(EM_ASSESS):   NUMOBS = NUMOBSS ( GROUP);
MPRINT(EM_ASSESS):   IF NUMOBS > 0 THEN MNPROB = MNPROBS ( GROUP) / NUMOBS;
MPRINT(EM_ASSESS):   ELSE MNPROB = .;
MPRINT(EM_ASSESS):   C_NUMOBS = SUM (NUMOBS, C_NUMOBS);
MPRINT(EM_ASSESS):   NUMRESP = NUMRESPS ( GROUP);
MPRINT(EM_ASSESS):   NUMNONRESP = NUMOBS - NUMRESP;
MPRINT(EM_ASSESS):   C_AVGNUM_RESP + AVGNUMRESP;
MPRINT(EM_ASSESS):   IF C_NUMOBS <= _NEVENTS THEN DO;
MPRINT(EM_ASSESS):   BESTNUMEVENTS = NUMOBS;
MPRINT(EM_ASSESS):   BESTCAPC = C_NUMOBS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   BASEEVENTS = _NEVENTS / 20;
MPRINT(EM_ASSESS):   BASENONEVENTS = 0;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   FLAG + 1;
MPRINT(EM_ASSESS):   DROP FLAG;
MPRINT(EM_ASSESS):   BESTNUMEVENTS = _NEVENTS - C_NUMOBS + NUMOBS;
MPRINT(EM_ASSESS):   IF FLAG > 1 THEN BESTNUMEVENTS = 0;
MPRINT(EM_ASSESS):   BESTCAPC = 100;
MPRINT(EM_ASSESS):   IF C_NUMOBS - _NEVENTS <= NUMOBS THEN DO;
MPRINT(EM_ASSESS):   BASEEVENTS = C_NUMOBS - _NEVENTS;
MPRINT(EM_ASSESS):   BASENONEVENTS = NUMOBS - C_NUMOBS + _NEVENTS;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   BASEEVENTS = 0;
MPRINT(EM_ASSESS):   BASENONEVENTS = NUMOBS;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   BESTCAP = BESTNUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   IF C_NUMOBS <= _NEVENTS THEN DO;
MPRINT(EM_ASSESS):   BESTLIFT = ((_NEVENTS+_NNONEVENTS) / 20) /AVGNUMRESP;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   BESTLIFT = BESTNUMEVENTS / AVGNUMRESP;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   C_BESTNUMEVENTS + BESTNUMEVENTS;
MPRINT(EM_ASSESS):   DROP C_BESTNUMEVENTS;
MPRINT(EM_ASSESS):   IF C_NUMOBS > 0 THEN BESTLIFTC = C_BESTNUMEVENTS / (_NEVENTS / 3000 *
C_NUMOBS);
MPRINT(EM_ASSESS):   ELSE BESTLIFTC = .;
MPRINT(EM_ASSESS):   IF NUMOBS > 0 THEN DO;
MPRINT(EM_ASSESS):   BESTRESP = BESTNUMEVENTS * 100 / NUMOBS;
MPRINT(EM_ASSESS):   P_RESP = NUMRESP * 100 / NUMOBS;
MPRINT(EM_ASSESS):   P_NONRESP = NUMNONRESP * 100 / NUMOBS;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   BESTRESP = .;
MPRINT(EM_ASSESS):   P_RESP = .;
MPRINT(EM_ASSESS):   P_NONRESP = .;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   IF C_NUMOBS > 0 THEN DO;
MPRINT(EM_ASSESS):   BESTRESPC = C_BESTNUMEVENTS * 100 / C_NUMOBS;
MPRINT(EM_ASSESS):   BESTGAIN = MAX (0, ((C_BESTNUMEVENTS / C_NUMOBS ) / ( AVGNUMRESP /
(3000/20)) - 1) * 100);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   BESTRESPC = .;
MPRINT(EM_ASSESS):   BESTGAIN = .;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   IF NUMNONRESP > 0 THEN ODDS = NUMRESP / NUMNONRESP;
MPRINT(EM_ASSESS):   ELSE ODDS = .;
MPRINT(EM_ASSESS):   C_NUM_RESP = SUM (C_NUM_RESP , NUMRESP );
MPRINT(EM_ASSESS):   C_NUM_NONRESP = SUM (C_NUM_NONRESP, NUMNONRESP );
MPRINT(EM_ASSESS):   IF C_NUM_NONRESP > 0 THEN C_ODDS = C_NUM_RESP / C_NUM_NONRESP;
MPRINT(EM_ASSESS):   ELSE C_ODDS = .;
MPRINT(EM_ASSESS):   IF C_NUMOBS > 0 THEN DO;
MPRINT(EM_ASSESS):   C_P_RESP = C_NUM_RESP * 100 / C_NUMOBS;
MPRINT(EM_ASSESS):   GAIN = ABS(100 * (((C_NUM_RESP / C_NUMOBS ) / (_NEVENTS / 3000)) - 1));
MPRINT(EM_ASSESS):   BASEGAIN = 100 * (( (C_AVGNUM_RESP /((20-GROUP+1)* 3000/20) ) / (
AVGNUMRESP / (3000/20))) - 1);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE DO;
MPRINT(EM_ASSESS):   GAIN = .;
MPRINT(EM_ASSESS):   BASEGAIN = .;
MPRINT(EM_ASSESS):   C_P_RESP = .;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   IF BASEGAIN <= 0 THEN BASEGAIN = 0;
MPRINT(EM_ASSESS):   P_CAPT_RESP = NUMRESP * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   P_CAPT_NONRESP = NUMNONRESP * 100 / ( 3000 - _NEVENTS);
MPRINT(EM_ASSESS):   C_P_CAPT_RESP = C_NUM_RESP * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   C_P_CAPT_NONRESP = C_NUM_NONRESP * 100 / ( 3000 - _NEVENTS);
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * Area For Binned KS in Outranks area;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   _DIFFERENCE = C_P_CAPT_RESP - C_P_CAPT_NONRESP ;
MPRINT(EM_ASSESS):   IF _KS_BIN_ < _DIFFERENCE THEN DO;
MPRINT(EM_ASSESS):   _KS_BIN_ = _DIFFERENCE;
MPRINT(EM_ASSESS):   _KS_BIN_PROB = MINPROB + (MAXPROB - MINPROB) / 2 ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   LIFT = P_RESP * .01 / RESPRATE ;
MPRINT(EM_ASSESS):   C_LIFT = C_P_RESP * .01 / RESPRATE;
MPRINT(EM_ASSESS):   IF NUMOBS > 0 THEN DO;
MPRINT(EM_ASSESS):   BASELIFT = AVGNUMRESP / ( RESPRATE * 3000/20 );
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   ELSE BASELIFT = .;
MPRINT(EM_ASSESS):   IF C_NUMOBS > 0 THEN CBASELIFT = C_AVGNUM_RESP / (RESPRATE *
((20-GROUP+1)* 3000/20));
MPRINT(EM_ASSESS):   ELSE CBASELIFT = .;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........ WITHIN DO LOOP FOR OUTRANKS;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   BIN = 20 + 1 - GROUP;
MPRINT(EM_ASSESS):   PERCENTILE = BIN * (100 / 20);
MPRINT(EM_ASSESS):   B_C_P_RESP = PERCENTILE;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPRANK ;
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........................ END OF GAINSCHART = OUTRANKS AREA;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MAXPROFITGROUP" , MAXPROFITGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MAXPROFIT" , MAXPROFIT );
MPRINT(EM_ASSESS):   KS_ABSDIFF = 0 ;
MPRINT(EM_ASSESS):   MINPRECTPR = 9999;
MPRINT(EM_ASSESS):   Y0 = 1 - RESPRATE;
MPRINT(EM_ASSESS):   Y1 = RESPRATE;
MPRINT(EM_ASSESS):   MAXMUTUAL = 0;
MPRINT(EM_ASSESS):   DROP MAXMUTUAL KSPROB Y0 Y1 KS_ABSDIFF MINPRECTPR;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * .....................About to start Processing Outroc ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........................... Finished Processing Outroc ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * .............. Outdist ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   BIN = 20 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS96 - EVENTS100 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS96 - NONEVENTS100);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB96 -
SCR_MNPROB100) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB96 - SCR_MINPROB100) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB96 - SCR_MAXPROB100) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
SAS 시스템
 
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 20;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 19 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS91 - EVENTS95 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS91 - NONEVENTS95);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB91 -
SCR_MNPROB95) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB91 - SCR_MINPROB95) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB91 - SCR_MAXPROB95) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 19;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 18 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS86 - EVENTS90 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS86 - NONEVENTS90);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB86 -
SCR_MNPROB90) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB86 - SCR_MINPROB90) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB86 - SCR_MAXPROB90) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 18;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 17 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS81 - EVENTS85 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS81 - NONEVENTS85);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB81 -
SCR_MNPROB85) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB81 - SCR_MINPROB85) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB81 - SCR_MAXPROB85) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 17;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 16 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS76 - EVENTS80 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS76 - NONEVENTS80);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB76 -
SCR_MNPROB80) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB76 - SCR_MINPROB80) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB76 - SCR_MAXPROB80) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 16;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 15 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS71 - EVENTS75 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS71 - NONEVENTS75);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB71 -
SCR_MNPROB75) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB71 - SCR_MINPROB75) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB71 - SCR_MAXPROB75) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 15;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 14 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS66 - EVENTS70 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS66 - NONEVENTS70);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB66 -
SCR_MNPROB70) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB66 - SCR_MINPROB70) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB66 - SCR_MAXPROB70) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 14;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 13 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS61 - EVENTS65 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS61 - NONEVENTS65);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB61 -
SCR_MNPROB65) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB61 - SCR_MINPROB65) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB61 - SCR_MAXPROB65) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 13;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 12 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS56 - EVENTS60 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS56 - NONEVENTS60);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB56 -
SCR_MNPROB60) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB56 - SCR_MINPROB60) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB56 - SCR_MAXPROB60) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 12;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 11 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS51 - EVENTS55 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS51 - NONEVENTS55);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB51 -
SCR_MNPROB55) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB51 - SCR_MINPROB55) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB51 - SCR_MAXPROB55) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 11;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 10 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS46 - EVENTS50 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS46 - NONEVENTS50);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB46 -
SCR_MNPROB50) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB46 - SCR_MINPROB50) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB46 - SCR_MAXPROB50) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 10;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 9 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS41 - EVENTS45 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS41 - NONEVENTS45);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB41 -
SCR_MNPROB45) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB41 - SCR_MINPROB45) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB41 - SCR_MAXPROB45) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 9;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 8 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS36 - EVENTS40 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS36 - NONEVENTS40);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB36 -
SCR_MNPROB40) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB36 - SCR_MINPROB40) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB36 - SCR_MAXPROB40) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 8;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 7 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS31 - EVENTS35 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS31 - NONEVENTS35);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB31 -
SCR_MNPROB35) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB31 - SCR_MINPROB35) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB31 - SCR_MAXPROB35) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 7;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 6 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS26 - EVENTS30 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS26 - NONEVENTS30);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB26 -
SCR_MNPROB30) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB26 - SCR_MINPROB30) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB26 - SCR_MAXPROB30) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 6;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 5 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS21 - EVENTS25 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS21 - NONEVENTS25);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB21 -
SCR_MNPROB25) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB21 - SCR_MINPROB25) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB21 - SCR_MAXPROB25) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 5;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 4 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS16 - EVENTS20 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS16 - NONEVENTS20);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB16 -
SCR_MNPROB20) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB16 - SCR_MINPROB20) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB16 - SCR_MAXPROB20) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 4;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 3 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS11 - EVENTS15 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS11 - NONEVENTS15);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB11 -
SCR_MNPROB15) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB11 - SCR_MINPROB15) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB11 - SCR_MAXPROB15) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 3;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 2 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS6 - EVENTS10 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS6 - NONEVENTS10);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB6 -
SCR_MNPROB10) / NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB6 - SCR_MINPROB10) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB6 - SCR_MAXPROB10) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 2;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   BIN = 1 ;
MPRINT(EM_ASSESS):   LOWERPROB = (BIN - 1) / 20;
MPRINT(EM_ASSESS):   UPPERPROB = LOWERPROB + (1 / 20);
MPRINT(EM_ASSESS):   MODELSCORE = LOWERPROB + (1 / 20) / 2;
MPRINT(EM_ASSESS):   RANGE = COMPRESS (PUT (LOWERPROB, 4.2) || "-" || PUT (UPPERPROB, 4.2));
MPRINT(EM_ASSESS):   SCR_NUMEVENTS = SUM ( OF EVENTS1 - EVENTS5 );
MPRINT(EM_ASSESS):   SCR_P_EVENTS = SCR_NUMEVENTS * 100 / _NEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_EVENTS = SUM (SCR_P_EVENTS, SCR_CP_EVENTS);
MPRINT(EM_ASSESS):   SCR_NUMNONEVENTS = SUM ( OF NONEVENTS1 - NONEVENTS5);
MPRINT(EM_ASSESS):   NUMOBSINGROUP = SUM (SCR_NUMEVENTS, SCR_NUMNONEVENTS);
MPRINT(EM_ASSESS):   IF NUMOBSINGROUP > 0 THEN SCR_MNPROB = SUM (OF SCR_MNPROB1 - SCR_MNPROB5)
/ NUMOBSINGROUP;
MPRINT(EM_ASSESS):   ELSE SCR_MNPROB = .;
MPRINT(EM_ASSESS):   SCR_MINPROB = MIN (OF SCR_MINPROB1 - SCR_MINPROB5) ;
MPRINT(EM_ASSESS):   SCR_MAXPROB = MAX (OF SCR_MAXPROB1 - SCR_MAXPROB5) ;
MPRINT(EM_ASSESS):   IF SCR_MINPROB = 1 THEN SCR_MINPROB = .;
MPRINT(EM_ASSESS):   IF SCR_MAXPROB = 0 THEN SCR_MAXPROB = .;
MPRINT(EM_ASSESS):   SCR_P_NONEVENTS = SCR_NUMNONEVENTS * 100 / _NNONEVENTS;
MPRINT(EM_ASSESS):   SCR_CP_NONEVENTS = SUM (SCR_P_NONEVENTS, SCR_CP_NONEVENTS);
MPRINT(EM_ASSESS):   PERCOBSINGROUP = NUMOBSINGROUP * 100 / 3000;
MPRINT(EM_ASSESS):   C_PERCOBSINGROUP = SUM (C_PERCOBSINGROUP, PERCOBSINGROUP);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MINPROB" || LEFT (PUT (BIN, 3.)), LOWERPROB);
MPRINT(EM_ASSESS):   CALL SYMPUTX ("SCR_MAXPROB" || LEFT (PUT (BIN, 3.)), UPPERPROB);
MPRINT(EM_ASSESS):   BIN = 20 + 1 - 1;
MPRINT(EM_ASSESS):   OUTPUT WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   CALL SYMPUTX ("KSPROB" , PUT (KSPROB, 5.3 ) );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("_KS_BIN_PROB" , _KS_BIN_PROB );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("_KS_BIN_" , _KS_BIN_ / 100 );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("KSDIFF" , KS_ABSDIFF );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("PRECTPR" , PRECTPR );
MPRINT(EM_ASSESS):   CALL SYMPUTX ("MAXMUTUALPROB" , MAXMUTUALPROB);
MPRINT(EM_ASSESS):   END;
MPRINT(EM_ASSESS):   LABEL __EVENT__ = "이벤트" DECILE = "깊이" BIN = "범주" NUMOBS = "관측치
수" ;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * RUN for large data set;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   PROC DATASETS NOLIST;
MPRINT(EM_ASSESS):   DELETE _AUXEVENTNAME;
MPRINT(EM_ASSESS):   QUIT;
 
MPRINT(EM_ASSESS):   OPTION NOCENTER LS = 95;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * Report Vars Area.;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ...........Start OF Outdist Modification;
MPRINT(EM_ASSESS):   *;
 
MPRINT(EM_ASSESS):   PROC DATASETS NOLIST LIB = WORK;
MPRINT(EM_ASSESS):   MODIFY _TEMPSCOREDIST;
MPRINT(EM_ASSESS):   RENAME MODELSCORE = SCORE UPPERPROB = UPPOSTERIOR SCR_CP_EVENTS =
CUMULATIVEPERCENTAGEOFEVENTS SCR_CP_NONEVENTS = CUMULATIVEPERCENTAGEOFNONEVENTS EVENTVALUE =
EVENT LOWERPROB = LOWPOSTERIOR NUMOBSINGROUP = N PERCOBSINGROUP = PERCENTAGE SCR_MINPROB =
_MINP_ SCR_MAXPROB = _MAXP_ SCR_MNPROB = _MEANP_ RANGE = P_LABEL C_PERCOBSINGROUP =
CUMULATIVEPERCENTAGE SCR_NUMEVENTS = NUMBEROFEVENTS SCR_NUMNONEVENTS = NUMBEROFNONEVENTS
SCR_P_EVENTS = PERCENTAGEOFEVENTS SCR_P_NONEVENTS = PERCENTAGEOFNONEVENTS ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * .................... OUTDIST MODIFICATION LABEL AREA;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   LABEL BIN = "범주" N = "관측치 수" P_LABEL = "사후확률 범위" EVENT =
"이벤트" LOWPOSTERIOR = "사후확률 하한" PERCENTAGEOFEVENTS = "이벤트 백분율"
CUMULATIVEPERCENTAGEOFNONEVENTS = "누적 비이벤트 백분율" CUMULATIVEPERCENTAGE = "누적 백분율"
PERCENTAGEOFEVENTS = "이벤트 백분율" PERCENTAGEOFNONEVENTS = "비이벤트 백분율"
CUMULATIVEPERCENTAGEOFEVENTS = "누적 이벤트 백분율" UPPOSTERIOR = "사후확률 상한"
NUMBEROFEVENTS = "이벤트 수" PERCENTAGE = "백분율" NUMBEROFNONEVENTS = "비이벤트 수" _MEANP_ =
"평균 사후확률" _MINP_ = "최소 사후확률" _MAXP_ = "최대 사후확률" SCORE = "모델 스코어" ;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   QUIT;
MPRINT(EM_ASSESS):   DATA WORK._TEMPSCOREDIST;
MPRINT(EM_ASSESS):   SET WORK._TEMPSCOREDIST (WHERE = (_MEANP_ > .));
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ........... END OF OUTDIST MODIFICATION;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ...........Start of OUTRANKS Modification;
MPRINT(EM_ASSESS):   *;
 
MPRINT(EM_ASSESS):   PROC DATASETS NOLIST LIB = WORK;
MPRINT(EM_ASSESS):   MODIFY _TEMPRANK;
MPRINT(EM_ASSESS):   RENAME __EVENT__ = EVENT P_RESP = RESP C_P_CAPT_RESP = CAPC P_CAPT_RESP =
CAP NUMNONRESP = NUMNEVENT NUMRESP = NUMEVENT BASEEVENTS = BASENUMBEROFEVENTS BESTNUMEVENTS =
BESTNUMBEROFEVENTS MAXPROB = _MAXP_ MINPROB = _MINP_ CBASELIFT = BASELIFTC C_LIFT = LIFTC
MNPROB = _MEANP_ PERCENTILE = DECILE NUMOBS = N NUMEVENT = NUMBEROFEVENTS C_P_RESP = RESPC ;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   * ................. OUTRANKS;
MPRINT(EM_ASSESS):   *;
MPRINT(EM_ASSESS):   LABEL _MAXP_ = "최대 사후확률" _MINP_ = "최소 사후확률" _MEANP_ = "평균
사후확률" BASECAP = "기준 반응검출률" BASECAPC = "기준 누적 반응검출률" BASENUMBEROFEVENTS =
"기준 이벤트 수" BASEGAIN = "기준 이득" BASELIFT = "기준 향상도" BASELIFTC = "기준 누적
향상도" BASERESP = "기준 반응률" BASERESPC = "기준 누적반응률" BASELIFTC = "기준 누적 향상도"
BESTCAP = "최적 반응검출률" BESTCAPC = "최적 누적 반응검출률" BESTGAIN = "최적 이득" BESTRESP
= "최적 반응률" BESTRESPC = "최적 누적반응률" BESTLIFT = "최적 향상도" BESTLIFTC = "최적 누적
향상도" BESTNUMBEROFEVENTS = "최적 이벤트 수" CAP = "반응검출률" CAPC = "누적 반응검출률"
DECILE = "깊이" GAIN = "이득" LIFT = "향상도" LIFTC = "누적 향상도" NUMNEVENT = "비이벤트 수"
N = "관측치 수" EVENT = "이벤트" RESPC = "누적반응률" NUMBEROFEVENTS = "이벤트 수" RESP =
"반응률" ;
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   QUIT;
MPRINT(EM_ASSESS):   DATA WORK._TEMPRANK;
MPRINT(EM_ASSESS):   SET WORK._TEMPRANK (WHERE = (_MEANP_ > .));
MPRINT(EM_ASSESS):   RUN;
MPRINT(EM_ASSESS):   proc datasets lib=work nolist;
MPRINT(EM_ASSESS):   delete _ea_tmpdata;
MPRINT(EM_ASSESS):   run;
MPRINT(EM_ASSESS):   quit;
MPRINT(EM_ASSESS):  ;
MPRINT(EM_ASSESS):   OPTION ERRORS = 20;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):    data WORK._TEMPRANK;
MPRINT(EM_DIAGRAM):   length target $32 TARGETLABEL $200 dataRole $20;
MPRINT(EM_DIAGRAM):   label TARGETLABEL = "타겟 레이블";
MPRINT(EM_DIAGRAM):   set WORK._TEMPRANK;
MPRINT(EM_DIAGRAM):   retain target "RESPOND";
MPRINT(EM_DIAGRAM):   retain dataRole "VALIDATE";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_EMRANK;
MPRINT(EM_DIAGRAM):   length target $32;
MPRINT(EM_DIAGRAM):   length TARGETLABEL $200;
MPRINT(EM_DIAGRAM):   length dataRole $20;
MPRINT(EM_DIAGRAM):   length EVENT $32;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_EMRANK WORK._TEMPRANK;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data WORK._TEMPSCOREDIST;
MPRINT(EM_DIAGRAM):   length target $32 TARGETLABEL $200 dataRole $20;
MPRINT(EM_DIAGRAM):   label TARGETLABEL = "타겟 레이블";
MPRINT(EM_DIAGRAM):   set WORK._TEMPSCOREDIST;
MPRINT(EM_DIAGRAM):   retain target "RESPOND";
MPRINT(EM_DIAGRAM):   retain dataRole "VALIDATE";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_EMSCOREDIST;
MPRINT(EM_DIAGRAM):   length target $32;
MPRINT(EM_DIAGRAM):   length TARGETLABEL $200;
MPRINT(EM_DIAGRAM):   length dataRole $20;
MPRINT(EM_DIAGRAM):   length EVENT $32;
MPRINT(EM_DIAGRAM):   length P_LABEL $9;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_EMSCOREDIST WORK._TEMPSCOREDIST;
MPRINT(EM_DIAGRAM):   run;
45631      %let _cn = %sysfunc(getoption(CENTER));
45632      options nocenter;
MPRINT(EM_DIAGRAM):    options nocenter;
45633      proc print data=EMWS6.Neural_EMREPORTFIT noobs label;
MPRINT(EM_DIAGRAM):   proc print data=EMWS6.Neural_EMREPORTFIT noobs label;
45634      var STAT LABEL TRAIN
45635      VALIDATE
45636      TEST
45637      ;
MPRINT(EM_DIAGRAM):   var STAT LABEL TRAIN VALIDATE TEST ;
45638      by TARGET TARGETLABEL;
MPRINT(EM_DIAGRAM):   by TARGET TARGETLABEL;
45639      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
45640      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_fitstat_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "적합통계량";
MPRINT(EM_DIAGRAM):   run;
45641      run;
 
NOTE: 21개의 관측값을 데이터셋 EMWS6.NEURAL_EMREPORTFIT.에서 읽었습니다.
NOTE: 출력 결과 (프로시저: PRINT, 페이지: 14)
NOTE: 프로시저 PRINT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
45642      title10;
MPRINT(EM_DIAGRAM):   title10;
45643      options &_cn;
MPRINT(EM_DIAGRAM):   options NOCENTER;
45644      proc sort data=EMWS6.Neural_EMCLASSIFICATION nothreads;
MPRINT(EM_DIAGRAM):    proc sort data=EMWS6.Neural_EMCLASSIFICATION nothreads;
45645      by DATAROLE TARGET TARGETLABEL;
MPRINT(EM_DIAGRAM):   by DATAROLE TARGET TARGETLABEL;
45646      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 6개의 관측값을 데이터셋 EMWS6.NEURAL_EMCLASSIFICATION.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_EMCLASSIFICATION은(는) 6개의 관측값과 12개의 변수를 가지고
      있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
45647      %let _cn = %sysfunc(getoption(CENTER));
45648      options nocenter;
MPRINT(EM_DIAGRAM):   options nocenter;
45649      proc print data=EMWS6.Neural_EMCLASSIFICATION noobs label;
MPRINT(EM_DIAGRAM):   proc print data=EMWS6.Neural_EMCLASSIFICATION noobs label;
45650      var from into pct_row pct_col count percent
45651      ;
MPRINT(EM_DIAGRAM):   var from into pct_row pct_col count percent ;
45652      by DATAROLE TARGET TARGETLABEL;
MPRINT(EM_DIAGRAM):   by DATAROLE TARGET TARGETLABEL;
45653      label FROM = "%sysfunc(sasmsg(sashelp.dmine, rpt_target_vlabel ,     NOQUOTE))";
MPRINT(EM_DIAGRAM):   label FROM = "타겟";
45654      label INTO = "%sysfunc(sasmsg(sashelp.dmine, rpt_outcome_vlabel ,    NOQUOTE))";
MPRINT(EM_DIAGRAM):   label INTO = "결과";
45655      label PCT_ROW = "%sysfunc(sasmsg(sashelp.dmine, rpt_targetpct_vlabel ,  NOQUOTE))";
MPRINT(EM_DIAGRAM):   label PCT_ROW = "타겟 백분율";
45656      label PCT_COL = "%sysfunc(sasmsg(sashelp.dmine, rpt_outcomepct_vlabel , NOQUOTE))";
MPRINT(EM_DIAGRAM):   label PCT_COL = "결과 백분율";
45657      label COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel ,      NOQUOTE))";
MPRINT(EM_DIAGRAM):   label COUNT = "빈도 개수";
45658      label PERCENT = "%sysfunc(sasmsg(sashelp.dmine, rpt_totalpct_vlabel ,   NOQUOTE))";
MPRINT(EM_DIAGRAM):   label PERCENT = "총 백분율";
45659      where _TYPE_='PREDICTION';
MPRINT(EM_DIAGRAM):   where _TYPE_='PREDICTION';
45660      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
45661      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_classification_title    , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "분류 테이블";
MPRINT(EM_DIAGRAM):   run;
45662      run;
 
NOTE: 6개의 관측값을 데이터셋 EMWS6.NEURAL_EMCLASSIFICATION.에서 읽었습니다.
      WHERE _TYPE_='PREDICTION';
NOTE: 출력 결과 (프로시저: PRINT, 페이지: 15)
NOTE: 프로시저 PRINT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
45663      title9;
MPRINT(EM_DIAGRAM):   title9;
45664      title10;
MPRINT(EM_DIAGRAM):   title10;
45665      options &_cn;
MPRINT(EM_DIAGRAM):   options NOCENTER;
45666      %let _cn = %sysfunc(getoption(CENTER));
45667      options nocenter;
MPRINT(EM_DIAGRAM):    options nocenter;
45668      data EMWS6.Neural_EMEVENTREPORT;
MPRINT(EM_DIAGRAM):   data EMWS6.Neural_EMEVENTREPORT;
45669      length DATAROLE TARGET $32 TARGETLABEL $200 FALSENEVENT TRUENEVENT FALSEEVENT
45669    ! TRUEEVENT 8;
MPRINT(EM_DIAGRAM):   length DATAROLE TARGET $32 TARGETLABEL $200 FALSENEVENT TRUENEVENT
FALSEEVENT TRUEEVENT 8;
45670      label DATAROLE = "%sysfunc(sasmsg(sashelp.dmine, rpt_datarole_vlabel ,    NOQUOTE))"
45670    !  TARGET = "%sysfunc(sasmsg(sashelp.dmine, rpt_target_vlabel ,      NOQUOTE))"
45670    ! TARGETLABEL = "%sysfunc(sasmsg(sashelp.dmine, meta_targetlabel_vlabel, NOQUOTE))"
45670    ! FALSEEVENT
45671      = "%sysfunc(sasmsg(sashelp.dmine, rpt_falseevent_vlabel ,  NOQUOTE))" FALSENEVENT =
45671    ! "%sysfunc(sasmsg(sashelp.dmine, rpt_falsenevent_vlabel , NOQUOTE))" TRUEEVENT =
45671    ! "%sysfunc(sasmsg(sashelp.dmine, rpt_trueevent_vlabel ,   NOQUOTE))" TRUENEVENT =
45672         "%sysfunc(sasmsg(sashelp.dmine, rpt_truenevent_vlabel ,  NOQUOTE))";
MPRINT(EM_DIAGRAM):   label DATAROLE = "데이터 역할" TARGET = "타겟" TARGETLABEL = "타겟
레이블" FALSEEVENT = "False Positive" FALSENEVENT = "False Negative" TRUEEVENT = "True
Positive" TRUENEVENT = "True Negative";
45673      FALSEEVENT=0;
MPRINT(EM_DIAGRAM):   FALSEEVENT=0;
45674      FALSENEVENT=0;
MPRINT(EM_DIAGRAM):   FALSENEVENT=0;
45675      TRUEEVENT=0;
MPRINT(EM_DIAGRAM):   TRUEEVENT=0;
45676      TRUENEVENT=0;
MPRINT(EM_DIAGRAM):   TRUENEVENT=0;
45677      set EMWS6.Neural_EMEVENTREPORT;
MPRINT(EM_DIAGRAM):   set EMWS6.Neural_EMEVENTREPORT;
45678      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 2개의 관측값을 데이터셋 EMWS6.NEURAL_EMEVENTREPORT.에서 읽었습니다.
NOTE: 데이터셋 EMWS6.NEURAL_EMEVENTREPORT은(는) 2개의 관측값과 7개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
 
45679      proc print data=EMWS6.Neural_EMEVENTREPORT noobs label;
MPRINT(EM_DIAGRAM):   proc print data=EMWS6.Neural_EMEVENTREPORT noobs label;
45680      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
45681      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_eventtable_title    , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "이벤트 분류 테이블";
MPRINT(EM_DIAGRAM):   by notsorted DATAROLE notsorted TARGET notsorted TARGETLABEL;
MPRINT(EM_DIAGRAM):   run;
45682      by notsorted DATAROLE notsorted TARGET notsorted TARGETLABEL;
45683      run;
 
NOTE: 2개의 관측값을 데이터셋 EMWS6.NEURAL_EMEVENTREPORT.에서 읽었습니다.
NOTE: 출력 결과 (프로시저: PRINT, 페이지: 16)
NOTE: 프로시저 PRINT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
45684      title10;
MPRINT(EM_DIAGRAM):   title10;
45685      options &_cn;
MPRINT(EM_DIAGRAM):   options NOCENTER;
45686      proc datasets library=EMWS6 nolist;
MPRINT(EM_DIAGRAM):    proc datasets library=EMWS6 nolist;
45687      modify Neural_EMRANK;
MPRINT(EM_DIAGRAM):   modify Neural_EMRANK;
MPRINT(EM_DIAGRAM):   label target = "타겟 변수";
45688      label target = "%sysfunc(sasmsg(sashelp.dmine, rpt_targetvar_vlabel ,   NOQUOTE))";
MPRINT(EM_DIAGRAM):   label datarole = "데이터 역할";
45689      label datarole = "%sysfunc(sasmsg(sashelp.dmine, rpt_datarole_vlabel ,    NOQUOTE))"
45689    ! ;
MPRINT(EM_DIAGRAM):   run;
45690      run;
 
NOTE: EMWS6.NEURAL_EMRANK.DATA에 대한 MODIFY에 성공했습니다.
45691      quit;
MPRINT(EM_DIAGRAM):   quit;
 
NOTE: 프로시저 DATASETS 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
45692      %let _cn = %sysfunc(getoption(CENTER));
45693      options nocenter;
MPRINT(EM_DIAGRAM):    options nocenter;
45694      proc print data=EMWS6.Neural_EMRANK label noobs;
MPRINT(EM_DIAGRAM):   proc print data=EMWS6.Neural_EMRANK label noobs;
45695      var
45696      decile gain lift liftc resp respc N _meanP_;
MPRINT(EM_DIAGRAM):   var decile gain lift liftc resp respc N _meanP_;
45697      by
45698      notsorted DATAROLE
45699      notsorted TARGET
45700      notsorted TARGETLABEL
45701      ;
MPRINT(EM_DIAGRAM):   by notsorted DATAROLE notsorted TARGET notsorted TARGETLABEL ;
45702      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
45703      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_scoreranking_title , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "평가 스코어 순위";
MPRINT(EM_DIAGRAM):   run;
45704      run;
 
NOTE: 40개의 관측값을 데이터셋 EMWS6.NEURAL_EMRANK.에서 읽었습니다.
NOTE: 출력 결과 (프로시저: PRINT, 페이지: 17)
NOTE: 프로시저 PRINT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
45705      title10;
MPRINT(EM_DIAGRAM):   title10;
45706      options &_cn;
MPRINT(EM_DIAGRAM):   options NOCENTER;
45707      proc datasets library=EMWS6 nolist;
MPRINT(EM_DIAGRAM):    proc datasets library=EMWS6 nolist;
45708      modify Neural_EMSCOREDIST;
MPRINT(EM_DIAGRAM):   modify Neural_EMSCOREDIST;
MPRINT(EM_DIAGRAM):   label target = "타겟 변수";
45709      label target = "%sysfunc(sasmsg(sashelp.dmine, rpt_targetvar_vlabel ,
45709    ! NOQUOTE))";
MPRINT(EM_DIAGRAM):   label datarole = "데이터 역할";
45710      label datarole = "%sysfunc(sasmsg(sashelp.dmine, rpt_datarole_vlabel ,    NOQUOTE))"
45710    ! ;
MPRINT(EM_DIAGRAM):   run;
45711      run;
 
NOTE: EMWS6.NEURAL_EMSCOREDIST.DATA에 대한 MODIFY에 성공했습니다.
45712      quit;
MPRINT(EM_DIAGRAM):   quit;
 
NOTE: 프로시저 DATASETS 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(EM_DIAGRAM):    options nocenter;
MPRINT(EM_DIAGRAM):   proc print data=EMWS6.Neural_EMSCOREDIST label noobs;
MPRINT(EM_DIAGRAM):   var p_label numberOfEvents numberOfNonEvents _meanp_ percentage;
MPRINT(EM_DIAGRAM):   by notsorted DATAROLE notsorted TARGET notsorted TARGETLABEL ;
MPRINT(EM_DIAGRAM):   where TARGET in( "RESPOND" );
MPRINT(EM_DIAGRAM):   title9 ' ';
MPRINT(EM_DIAGRAM):   title10 "평가 스코어 분포";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   title10;
MPRINT(EM_DIAGRAM):   options NOCENTER;
MPRINT(EM_DIAGRAM):   proc printto;
MPRINT(EM_DIAGRAM):   run;
