*------------------------------------------------------------*
사용자:                Administrator
날짜:                2018년 11월 17일
시간:                17시43분38초
사이트:                10503192
플랫폼:            X64_10HOME
관리 릴리스: 9.04.01M4P110916
EM 버전:          14.2
* 
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 17일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "17시43분23초" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 분석 로그";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* 분석 로그
날짜:                2018년 11월 17일
시간:                17시43분23초
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O0_R7DXR "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O0_R7DXR new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 17일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "17시43분23초" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "사용자:                Administrator";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "사이트:                10503192";
MPRINT(EM_DIAGRAM):   put "플랫폼:            X64_10HOME";
MPRINT(EM_DIAGRAM):   put "관리 릴리스: 9.04.01M4P110916";
MPRINT(EM_DIAGRAM):   put "EM 버전:          14.2";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 17일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "17시43분23초" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "사용자:                Administrator";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 분석 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 스코어 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 리포트 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
23371      proc freq data=EMWS5.TextCluster3_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS5.TextCluster3_VariableSet noprint;
23372      table ROLE*LEVEL/out=WORK.TextCluster3META;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.TextCluster3META;
23373      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_VARIABLESET.에서 읽었습니다.
NOTE: 데이터셋 WORK.TEXTCLUSTER3META은(는) 1개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 FREQ 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
 
 
23374      proc print data=WORK.TextCluster3META label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.TextCluster3META label noobs;
23375      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
23376      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "역할" LEVEL = "측도 레벨" COUNT = "빈도 개수";
23377      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
23378      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "변수 요약";
MPRINT(EM_DIAGRAM):   run;
23379      run;
 
NOTE: 1개의 관측값을 데이터셋 WORK.TEXTCLUSTER3META.에서 읽었습니다.
NOTE: 출력 결과 (프로시저: PRINT, 페이지: 1)
NOTE: 프로시저 PRINT 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.04 초
 
 
23380      title10;
MPRINT(EM_DIAGRAM):   title10;
23381      %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextCluster3: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextCluster3: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'DataMining2018';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'Beekman';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   set EMWS5.TextTopic_EMINFO;
MPRINT(EM_DIAGRAM):   where key in('HPDMSAMPLE', 'IDSTABLE');
MPRINT(EM_DIAGRAM):   if key = 'HPDMSAMPLE' then call symput('_ForceGrid', '1');
MPRINT(EM_DIAGRAM):   else call symput('_IDS_TABLE', DATA);
MPRINT(EM_DIAGRAM):   run;
MPRINT(HPDM_PERFORMANCE):  ;
PERFORMANCE  DETAILS
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
23695      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
23696      * TextCluster3: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * TextCluster3: Generation of macros and macro variables;
23697      * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
23698      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
 
23699      %let EMEXCEPTIONSTRING=;
23700      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
23701      * TRAIN: TextCluster3;
MPRINT(EM_DIAGRAM):   * TRAIN: TextCluster3;
23702      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
23703      %let EM_ACTION = TRAIN;
23704      %let syscc = 0;
23705      %macro main();
23706
23707         %if %upcase(&EM_ACTION) eq CREATE %then %do;
23708            filename temp catalog 'sashelp.emtxtext.cluster_create.source';
23709            %include temp;
23710            %create();
23711         %end;
23712         %if %upcase(&EM_ACTION) eq TRAIN %then %do;
23713            filename temp catalog 'sashelp.emtxtext.cluster_train.source';
23714            %include temp;
23715            %train();
23716         %end;
23717         %if %upcase(&EM_ACTION) eq REPORT %then %do;
23718            filename temp catalog 'sashelp.emtxtext.cluster_report.source';
23719            %include temp;
23720            %report();
23721         %end;
23722         %if %upcase(&EM_ACTION) eq SCORE %then %do;
23723            filename temp catalog 'sashelp.emtxtext.cluster_score.source';
23724            %include temp;
23725            %score();
23726         %end;
23727      %mend main;
23728
23729      %main();
MPRINT(EM_DIAGRAM):
MPRINT(MAIN):   filename temp catalog 'sashelp.emtxtext.cluster_train.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.CLUSTER_TRAIN.SOURCE입니다.
23730     +%macro train();
23731     +
23732     +    %global last_parse_node last_filter_node last_prescore_node server_err
23733     +      parsevar EM_SASMSG;
23734     +    %if ^%symexist(tm_debug) %then %let tm_debug=0;
23735     +    %let EM_SASMSG=TMINE;
23736     +    %let syscc=0;
23737     +
23738     +    filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
23739     +    %include temp;
23740     +    filename temp catalog 'sashelp.emtxtext.tm_cluster.source';
23741     +    %include temp;
23742     +    filename temp catalog 'sashelp.emtxtext.tm_apply_tmutil.source';
23743     +    %include temp;
23744     +    filename temp catalog 'sashelp.emtxtext.tm_svd_do_samp.source';
23745     +    %include temp;
23746     +    filename temp;
23747     +
23748     +    %tm_get_last_filter(eminfo=&EM_IMPORT_DATA_EMINFO,em_lib=&em_lib,
23749     +                        em_variableset=&em_data_variableset);
23750     +    %if &EMEXCEPTIONSTRING ne %then %goto end_cluster_train;
23751     +    %let lastparsenode=&last_parse_node;
23752     +    %let lastfilternode=&last_filter_node;
23753     +    %let lastprescore=&last_prescore_node;
23754     +    %if &lastfilternode=&lastparsenode %then %do;
23755     +        %let EMEXCEPTIONSTRING = EMTOOL.NOFILTERNODE;
23756     +        %goto end_cluster_train;
23757     +    %end;
23758     +
23759     +    /*populate last tm node dataset so tm_get_last_filter is not called in score*/
23760     +    %em_getname(key=last_tm_nodes, type=data);
23761     +    data &em_user_last_tm_nodes;
23762     +        set &EM_IMPORT_DATA_EMINFO;
23763     +    run;
23764     +
23765     +
23766     +    %em_getname(key=tmconfig, type=data);
23767     +    %em_getname(key=terms, type=data);
23768     +    %em_getname(key=docs, type=data);
23769     +    %em_getname(key=clusters, type=data);
23770     +    %em_getname(key=graph_table, type=data);
23771     +    %em_getname(key=svd_u, type=data);
23772     +    %em_getname(key=tmconfig, type=data);
23773     +    %em_getname(key=svd_s, type=data);
23774     +    %em_getname(key=emoutstat, type=data);
23775     +    %em_getname(key=hierds, type=data);
23776     +
23777     +
23778     +
23779     +    /* get target variable info */
23780     +    %let targetvar = ;
23781     +    data _null_;
23782     +       set &em_data_variableset(where=(ROLE='TARGET' and USE in('Y' 'D')
23783     +                                       and LEVEL ne 'INTERVAL'));
23784     +       if _N_=1 then call symput('targetvar', strip(NAME));
23785     +    run;
23786     +
23787     +
23788     +
23789     +    /* set up terms strings and initial config table */
23790     +    proc sql noprint;
23791     +      create table &EM_USER_tmconfig as
23792     +         select *
23793     +         from &EM_LIB..&last_filter_node._tmconfig;
23794     +    quit;
23795     +
23796     +
23797     +    proc sql noprint;
23798     +       select  cellwgt into: _cellweight
23799     +       from &em_user_tmconfig;
23800     +       select termwgt into: _termwgt
23801     +       from &em_user_tmconfig;
23802     +    quit;
23803     +
23804     +    data _keepdocs (keep=_DOCUMENT_ %if &targetvar ne %then &targetvar; );
23805     +        set &EM_IMPORT_DATA;
23806     +    run;
23807     +
23808     +    %tm_apply_tmutil(data=&EM_LIB..&last_filter_node._tmout,
23809     +                       terms=&EM_LIB..&last_filter_node._terms,
23810     +                       docs=&EM_IMPORT_DATA,
23811     +                       keepdocs=_keepdocs,
23812     +                       reduceF=2,
23813     +                       termweight=&_termwgt,
23814     +                       cellweight=&_cellweight,
23815     +                       outdata=_outtmutil_,
23816     +                       outterms=_newkey,
23817     +                       outweights=_weights,
23818     +                       targetvar=&targetvar,
23819     +                       memloc=_tmmem);
23820     +
23821     +                       /* get the svd dimensions on the documents */
23822     +    %tm_svd_do_samp(data=_outtmutil_,docs=_keepdocs, maxK=&em_property_maxK, res=&em_property_resolution,cellwgt=&_cellweight,in_global=_weights,
23823     +                     rowVar=_termnum_,colVar=_document_,entryVar=_count_,u=&EM_USER_SVD_U,v=_svdv,s=&EM_USER_svd_S,
23824     +                     colpro=_svdcolpro,rowpro=_svdrowpro, normcol=normcol, normrow=normrow,prefix=&EM_NODEID);
23825     +
23826     +    %if(&syscc >4 ) %then %do;
23827     +        %goto end_cluster_train;
23828     +    %end;
23829     +
23830     +    proc sql noprint;
23831     +       create table &EM_USER_TERMS(drop=index) as
23832     +       select a.*,b.*
23833     +       from &EM_LIB..&last_filter_node._terms a left join _svdrowpro b
23834     +       on a.key = b.index;
23835     +    quit;
23836     +
23837     +    %tm_cluster(data=&EM_LIB..&last_filter_node._tmout,
23838     +        terms=&EM_LIB..&last_filter_node._terms,
23839     +        docs=&EM_IMPORT_DATA,
23840     +        svdColPro=_svdcolpro,
23841     +        maxNumTerms=&em_property_ndescterms,
23842     +        numClus=&em_property_nclusters,
23843     +        numType=&em_property_exactormaximum,
23844     +        algorithm=&em_property_algorithm,
23845     +        outdocs=&EM_USER_DOCS,
23846     +        outclusters=&EM_USER_CLUSTERS,
23847     +        hierds=&EM_USER_HIERDS,
23848     +        emoutstat=&EM_USER_emoutstat,
23849     +        prefixstring= &EM_NODEID);
23850     +
23851     +    %if &emexceptionstring ne %then %goto end_cluster_train;
23852     +
23853     +    %if &em_property_algorithm=2.0 %then %do;
23854     +
23855     +        data &em_user_hierds(drop=plus);
23856     +            set &em_user_hierds;
23857     +            plus='';
23858     +            if substr(CLUS_DESC, 1, 1) = "+" then plus="+ ";
23859     +            graphdesc=_CLUSTER_ || ': ' || plus || scan(CLUS_DESC, 1);
23860     +        run;
23861     +    %end;
23862     +
23863     +
23864     +    * add the info to EMINFO to forward on to other nodes ;
23865     +   data &EM_DATA_EMINFO;
23866     +      length TARGET KEY $32 DATA $43;
23867     +
23868     +      key="LastTMNode";
23869     +      data="&EM_NODEID";
23870     +      output;
23871     +
23872     +      key="LastTMNodeType";
23873     +      data="TextCluster";
23874     +      output;
23875     +
23876     +      key="LastTextCluster";
23877     +      data="&EM_NODEID";
23878     +      output;
23879     +
23880     +      key="PRESCORECODE";
23881     +      data="&EM_NODEID";
23882     +      output;
23883     +   run;
23884     +
23885     +    proc sql noprint;
23886     +        select count(*) into :svdkeep
23887     +            from &em_user_svd_s
23888     +            where keep=1;
23889     +        select count(*) into :cluscnt
23890     +            from &em_user_clusters;
23891     +    quit;
23892     +   data &EM_USER_tmconfig;
23893     +         set &EM_USER_TMCONFIG;
23894     +         clus_alg = "&em_property_algorithm";
23895     +         maxsvd = &em_property_maxk;
23896     +         svdkeep=&svdkeep;
23897     +         last_prescore = "&last_prescore_node";
23898     +      run;
23899     +
23900     +    %em_metachange(name=&EM_NODEID._CLUSTER_, role=SEGMENT, level=NOMINAL);
23901     +    %do i=1 %to &svdkeep;
23902     +         %em_metachange(name=&EM_NODEID._SVD&i, role=INPUT, level=INTERVAL);
23903     +    %end;
23904     +    %do i=1 %to &cluscnt;
23905     +         %em_metachange(name=&EM_NODEID._PROB&i, role=REJECTED);
23906     +    %end;
23907     +
23908     +%end_cluster_train:
23909     +    filename temp;
23910     +    %if &tm_debug =0 %then %do;
23911     +        proc sql noprint;
23912     +              drop table _svdcolpro;
23913     +              drop table _svdrowpro;
23914     +              drop table _newkey ;
23915     +              drop table _keepdocs ;
23916     +        quit;
23917     +    %end;
23918     +
23919     +%mend train;
23920     +
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_GET_LAST_FILTER.SOURCE입니다.
23921     +/* ****************************************************************
23922     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
23923     + *
23924     + * Name:             tm_get_last_filter.sas
23925     + * Product:          SAS Text Miner
23926     + * Language:         Sas
23927     + * Script:
23928     + *
23929     + * Usage:
23930     + *
23931     + * Purpose:  macro to get the last filter node and the last parse node in the
23932     + *   diagram that corresponds to the current parse variable.  If there is no filter
23933     + *   node, the filter node is set to the last parse node.
23934     + *
23935     + *
23936     + *
23937     + * History:
23938     + * 14Aug09 Initial Coding
23939     + *
23940     + * Notes:
23941     + *    Returns an error in the following cases:
23942     + *      1. There is no preceding parse node.
23943     + *      2. There is no parse node with the current parse variable.
23944     + *
23945     + * Last Modified By:
23946     + * Last Modified On: Wed Sep 23 15:35:04 2009
23947     + *
23948     + * End
23949     + * ************************************************************** */
23950     +%macro tm_get_last_filter(eminfo=,em_lib=, em_variableset=);
23951     +   %let last_parse_node=;
23952     +   %let last_filter_node=;
23953     +   %let last_prescore_node=;
23954     +   %let server_err=;
23955     +   %let EMEXCEPTIONSTRING=;
23956     +   %let syscc=0;
23957     +
23958     +    /* verify that setinit for SAS Text Miner is currently active */
23959     +    %if %sysfunc(sysprod(PRODNUM107)) ne 1 %then %do;
23960     +       %let EMEXCEPTIONSTRING = EMTOOL.NOTMLICENSE;
23961     +        %goto end_macro;
23962     +        %end;
23963     +
23964     +
23965     +    * find last filter or text parse node if no filter node. ;
23966     +   %if %sysfunc(exist(&eminfo)) %then %do;
23967     +      proc sql noprint;
23968     +      select data into :last_parse_node from &eminfo where key="LastTextParsing";
23969     +         select data into :last_filter_node from &eminfo where key="LastTextFilter";
23970     +         select data into :last_prescore_node from &eminfo where kupcase(key)="PRESCORECODE";
23971     +      quit;
23972     +
23973     +   %end;
23974     +
23975     +   %if &last_parse_node= %then %do;
23976     +      %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGNODE;
23977     +      %goto end_macro;
23978     +      %end;
23979     +
23980     +   %else %if &last_filter_node= %then %let last_filter_node = %ktrim(&last_parse_node);
23981     +   %else %let last_filter_node = %ktrim(&last_filter_node);
23982     +   %let last_parse_node = %ktrim(&last_parse_node);
23983     +
23984     +   * Check to make sure parse variable is present and still exists;
23985     +   %let parsevar = ;
23986     +   proc sql noprint;
23987     +    select parsevar into :parsevar
23988     +    from &em_lib..&last_filter_node._tmconfig;
23989     +    quit;
23990     +
23991     +    *check for dropped parsevar on input dataset;
23992     +       %let parsevarOK= ;
23993     +       %let parsevarN=%kupcase(%ktrim(&parsevar));
23994     +       data _null_;
23995     +         set &em_variableset(where=(kupcase(NAME)="&parsevarN" and USE in('Y' 'D')));
23996     +         if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
23997     +         run;
23998     +       %if(&parsevarOK eq ) %then %do;
23999     +          %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGVAR;
24000     +          %goto end_macro;
24001     +          %end;
24002     +%end_macro:
24003     +
24004     +%mend tm_get_last_filter;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_cluster.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_CLUSTER.SOURCE입니다.
24006     +   /* ****************************************************************
24007     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
24008     + *
24009     + * Name:             tm_cluster.sas
24010     + * Support:          rualbr Russell Albright
24011     + * Product:
24012     + * Language:         Sas
24013     + * Script:
24014     + *
24015     + * Usage:
24017     + !Inputs into %tm_train_cluster
24018     + * doc = doc datset from a tm node
24019     + * data =  out datset from a tm node
24020     + * terms = terms dataset from  tm node
24021     + * svdcolpro = column projections data set
24022     + * cellweight setting
24023     + * termweight setting
24024     + * maxSvddim = Maximum number of dimension to calculate
24025     + * svdres= <HIGH, MED, or LOW>
24026     + * maxNumTerms - maximum number of term to use for descriptive terms
24027     + * numClus = number of clusters to use
24028     + * numType=<MAXIMUM or EXACT> Max means that <= maximum will actually be used.
24029     + * threads = the number of threads you would like emclus to use
24032     + !Outputs from %tm_train_cluster
24033     + * outdocs - a doc table with the cluster restults on it.
24034     + * outclusters- an output cluster table with the descriptive terms on it (future story)
24035     + *
24036     + * Example call
24037     + *
24038     + *%tm_cluster(data=tmn.text_out_t,
24039     + *             terms=tmn.terms,
24040     + *             docs=testdata._train,
24041     + *             svdcolpro=tmn._svdcolpro,
24042     + *             maxNumTerms=5,
24043     + *             numClus=40,
24044     + *             numType=MAXIMUM,
24045     + *             outdocs=docsresult,
24046     + *             hierds=_hierds,
24047     + *             emoutstat=_emoutstat,
24048     + *             outclusters= clusterResult);
24049     + *
24050     + *
24051     + * Purpose: Perform the clustering on out,term, doc from parse or filter node
24052     + *
24053     + * History:
24054     + *
24055     + *
24056     + * Notes:
24057     + *
24058     + * Last Modified By:
24059     + * Last Modified On: Thu Jan 08 17:22:43 2009
24060     + *
24061     + * End
24062     + * ************************************************************** */
24064     +%macro tm_cluster(data=,
24065     +                     terms=,
24066     +                     docs=,
24067     +                     svdColPro=,
24068     +                     maxNumTerms=,
24069     +                     numClus=,
24070     +                     numType=MAXIMUM,
24071     +                     algorithm=,
24072     +                     outdocs=,
24073     +                     hierds=_hierds,
24074     +                     emoutstat=_emoutstat,
24075     +                     outclusters=,
24076     +                     prefixString=,
24077     +                     threads=);
24080     +    %local _cleanedout ;
24081     +    %local _numRepDocs;
24082     +    %global systmutil;
24083     +    %let systmutil = ;
24084     +    %if ^%symexist(tm_debug) %then %let tm_debug=0;
24086     +    filename temp catalog 'sashelp.emtext.tmgetncl.source';
24087     +    %include temp;
24088     +    filename temp catalog 'sashelp.emtext.tmfast.source';
24089     +    %include temp;
24091     +    filename temp catalog 'sashelp.emtext.tmemclus.source';
24092     +    %include temp;
24094     +    filename temp catalog 'sashelp.emtext.tmpred.source';
24095     +    %include temp;
24097     +    filename temp catalog 'sashelp.emtext.tmsort.source';
24098     +    %include temp;
24100     +    %let tmdata=&data;
24101     +    %let tmterms=&terms;
24102     +    %let tmdocs=&docs;
24103     +    %let emexceptionstring=;
24106     +    /* check some basic size requirements to proceed.*/
24107     +    proc sql noprint;
24108     +       select count(*) into: numTerms
24109     +       from &terms a
24110     +       where a.numdocs>=2 and _ispar in('+',' ')
24111     +       ;
24112     +       select count (*) into: numdocs
24113     +       from &docs a;
24114     +    quit;
24116     +    %if (&numterms < 10)  OR (&numdocs< 8) %then %do;
24117     +        %let emexceptionstring=EMTOOL.INSUFFICIENTDATA;
24118     +        %goto end_train_cluster;
24119     +    %end;
24121     +    /* Get number of kept svd variables */
24122     +    %let pid = %sysfunc(open(&svdcolpro));
24123     +    %let svdkeep=%eval(%sysfunc(attrn(&pid,nvars))-1);
24124     +    %let rc = %sysfunc(close(&pid));
24127     +   /************************ Find clusters *************************************/
24129     +   %if %upcase(&numType) = MAXIMUM %then %do;   /* numClus = MAXIMUM */
24131     +      /* Call tmgetncl to find the recommended number of clusters. */
24133     +      %tmGetNcl(data=&svdcolpro,
24134     +               maxclusters=&numClus,
24135     +               vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep),
24136     +               tempDS=_clusTemp1,
24137     +               clusDS=_clusTemp,
24138     +               threads=
24139     +            );
24141     +      /* error returned in above macro */
24142     +      %if (&syscc >4 ) %then %do;
24143     +         %let emexceptionstring= &SYSERRORTEXT;
24144     +         %goto end_train_cluster;
24145     +      %end;
24147     +      /* Store the recommended number into a macro variable. */
24149     +      proc sql noprint;
24150     +         select max(nclus) into: numClus
24151     +         from _clusTemp
24152     +         ;
24153     +      quit;
24156     +      %if not (&numClus > 1) %then %do;
24157     +        %let numClus = 2;
24158     +      %end;
24161     +       %if &tm_debug =0  %then %do;
24162     +          proc sql nowarn noprint;
24163     +              drop table _clustemp;
24164     +              drop table _clustemp1;
24165     +           quit;
24166     +       %end;
24168     +   %end;  /* &numtype = MAXIMUM */
24170     +   %else  %do;
24171     +       %let numClus = %left(&numClus);/*&numtype=EXACT*/
24172     +   %end;
24174     +    proc sql noprint;
24175     +        select count(*) into: nobs
24176     +        from &svdcolpro;
24177     +    quit;
24179     +   %if %left(&algorithm)=2.0 %then %do; /* Hierarchical clustering */
24180     +        filename temp catalog 'sashelp.emtxtext.tmgethclus.source';
24181     +        %include temp;
24183     +        filename temp catalog 'sashelp.emtext.tmhclus.source';
24184     +        %include temp;
24185     +        filename temp catalog 'sashelp.emtext.tmtree.source';
24186     +        %include temp;
24188     +        %if &nobs < &numClus and  %upcase(&numType) = EXACT %then %do;
24189     +            %let emexceptionstring=EMTOOL.TOOFEWOBSTOCLUS;
24190     +            %goto end_train_cluster;
24191     +        %end;
24193     +        %tmgethclus(outtree=_outtree,
24194     +                    idvar=index,
24195     +                    inDS=&svdcolpro,
24196     +                    outDS=&outdocs,
24197     +                    fastOut=_fastclusstat,
24198     +                    textClusDS=_clusstat,
24199     +                    vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep),
24200     +                    nobs=&nobs,
24201     +                    nclus=&numClus,
24202     +                    hierds=&hierds,
24203     +                    svdkeep=&svdkeep,
24204     +                    prefix=&prefixString);
24205     +        %if &EMEXCEPTIONSTRING ne %then %goto end_train_cluster;
24207     +        data _clusstat;
24208     +            set _clusstat(rename=(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep.=_mean1-_mean&svdkeep.));
24209     +        run;
24211     +        data _clustermean;
24212     +          set _clusstat(keep=_cluster_ _mean1-_mean&svdkeep. rename=(_cluster_=cluster));
24213     +        run;
24215     +        proc sql noprint;
24216     +            drop table _outtree;
24217     +        quit;
24218     +   %end;
24219     +   %else %do; /* Expectation-maximization */
24220     +       /* Call %anl_tmfast to create cluster stat data set that will be used as an input for %anl_tmemclus. */
24221     +          %tmFast(data=&svdcolpro,
24222     +             clusters=&numClus,
24223     +             outstat=_fastclusstat,
24224     +             outseed=,
24225     +                id=,
24226     +             out=,
24227     +             vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep)
24228     +             );
24229     +          run;
24231     +          /* If some of the clusters are too small (frequency less than 5) and &g_numClusFlag=MAXIMUM, */
24232     +          /* reassign value for &cluster macro var from WORK.&s_reportID._fastclusstat data set. */
24234     +       %if %upcase(&numType) = MAXIMUM %then
24235     +       %do;   /* &ClusType = MAXIMUM */
24237     +          proc sql noprint;
24238     +             select max(CLUSTER) into :numClus
24239     +             from _fastclusstat
24240     +             where upcase(_TYPE_)='SEED'
24241     +             ;
24242     +          quit;
24244     +          %let numClus = %left(&numClus);
24246     +       %end;  /* &ClusType = MAXIMUM */
24247     +       %else %do; /* &ClusType = EXACT */
24248     +          %if &nobs < &numClus %then %do;
24249     +            %let emexceptionstring=EMTOOL.TOOFEWOBSTOCLUS;
24250     +            %goto end_train_cluster;
24251     +          %end;
24252     +       %end;
24254     +       %tmEMClus(data=&svdcolpro,
24255     +                role=TRAIN,
24256     +                clusters=&numClus,
24257     +                seed=_fastclusstat,
24258     +                outstat=&emoutstat,
24259     +                out=_tmutildoc,
24260     +                vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep),
24261     +                cov=,
24262     +                iter=5,
24263     +                secclus=,
24264     +                seciter=,
24265     +                min=,
24266     +                method=,
24267     +                eps=.1,
24268     +                init=FASTCLUS,
24269     +                print=NONE,
24270     +                p=,
24271     +                outliers=,
24272     +                decvar=0,
24273     +                initstd=,
24274     +                dist=,
24275     +                secstd=,
24276     +                nobs=,
24277     +                threads=&threads.
24278     +             );
24279     +       run;
24282     +       /* Run %anl_tmpred macro to assign documents to clusters with the largest posterior probability */
24283     +       /* and to calculate cluster frequency. */
24285     +       %tmPred (inds=_tmutildoc,
24286     +                outds=&outdocs,
24287     +              clusters=&numClus,
24288     +              type=max,
24289     +              freqds=_clusstat,
24290     +              compress=1
24291     +              );
24292     +        data &outdocs;
24293     +           set &outdocs;
24294     +           rename prob1-prob&numClus = &prefixString._prob1-&prefixString._prob&numclus;
24295     +        run;
24299     +       /* Transpose the output data set to contain cluster ID and cluster frequency. */
24301     +        data _clusstat;
24302     +            array c(&numClus) _c1-_c&numClus;
24303     +            set _clusstat;
24304     +            /*keep _CLUSTER_ Freq;*/
24305     +            totalobs=0;
24306     +            do _CLUSTER_ = 1 to &numClus;
24307     +                Freq = c(_CLUSTER_);
24308     +                totalobs=totalobs+c(_CLUSTER_);
24309     +                output;
24310     +            end;
24311     +            call symput ('totNumDocs', totalobs);
24312     +        run;
24314     +       %if &totNumDocs = 0 %then
24315     +       %do;   /*&totNumDocs = 0 */
24316     +           goto end_train_cluster;
24317     +       %end; /*&totNumDocs = 0 */
24319     +       /* Calculate cluster percentage. */
24320     +       data _clusstat;
24321     +          set _clusstat;
24322     +          Percent = Freq/&totNumDocs;
24323     +       run;
24325     +       data _clustermean(rename=(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep. = _mean1-_mean&svdkeep.));
24326     +          set &emoutstat(keep=cluster _TYPE_ &prefixstring._SVD1 - &prefixstring._SVD&svdkeep.);
24327     +          if _TYPE_ = "MEAN";
24328     +            keep cluster &prefixstring._SVD1 - &prefixstring._SVD&svdkeep. ;
24329     +      run;
24330     +  %end;
24332     +      proc sql;
24333     +      create table _meandocs(drop=cluster) as
24334     +      select a.*, b.*
24335     +      from &outdocs a left join _clustermean b
24336     +      on a._cluster_=b.cluster
24337     +      ;
24338     +      quit;
24339     +       /*calulate residual for each doc */
24340     +      data _rmscalc;
24341     +          merge _meandocs(in=inhere) _clusstat;
24342     +          array _means(&svdkeep) _mean1-_mean&svdkeep.;
24343     +          array _svds(&svdkeep) &prefixstring._SVD1 - &prefixstring._SVD&svdkeep.;
24344     +          by _cluster_;
24345     +          error=0;
24346     +          do i = 1 to &svdkeep;
24347     +             error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
24348     +          end;
24349     +         /*error=sqrt(error);*/
24350     +          drop i;
24351     +       run;
24352     +    /*calc standardized residual for clusters*/
24353     +       proc summary data=_rmscalc nway;
24354     +          class _cluster_;
24355     +          var error;
24356     +          output out=_meanerr mean=meane sum=sume;
24357     +       run;
24359     +       data _rmsse;
24360     +          set _meanerr;
24361     +          /* original code divides by number of svd dims*/
24362     +          if _freq_ gt 1 then do;
24363     +              _rmsstd_=sqrt(sume/((_freq_-1)*(&svdkeep.)));
24364     +          end;
24365     +          else do;
24366     +              _rmsstd_=0;
24367     +          end;
24368     +          keep _cluster_  _rmsstd_;
24369     +       run;
24372     +       proc sql;
24373     +           create table _clusstat2(drop=cluster) as
24374     +           select a.*,b.*
24375     +           from _clustermean a left join _rmsse b
24376     +           on a.cluster=b._cluster_;
24378     +           create table &outclusters as
24379     +           select  a.*, b.freq, b.percent
24380     +           from _clusstat2(keep=_cluster_ %str(_mean1-_mean&svdkeep) _rmsstd_) a right join _clusstat b
24381     +           on a._cluster_=b._cluster_
24382     +           where b.freq>0 ;
24383     +       quit;
24386     +    filename temp catalog 'sashelp.emtext.tmterm1.source';
24387     +    %include temp / nosource2;
24389     +   /****************** Find descriptive terms for clusters ***************************/
24392     +   /* Add _term_ variable to WORK._terms data set to prepare it as an
24393     +   /* input to %tmterm1 macro. The variable is added from &EM_LIB..&last_filter_node._terms data set. */
24395     +   proc sort data=&tmterms out=_terms_;
24396     +        by key _ispar;
24397     +   run;
24399     +   data _terms_;
24400     +       set _terms_;
24401     +       by key _ispar;
24402     +       if first.key then
24403     +          output;
24404     +       else;
24405     +   run;
24407     +    /* Concatenate + to terms */
24408     +    data _terms_;
24409     +        set _terms_;
24410     +        if _ispar='+' then
24411     +            Term=_ispar || ' ' || term;
24412     +    run;
24414     +   %tmsort(data=&tmdata,
24415     +         out=_tmout_,
24416     +         by=_termnum_,
24417     +            options=,
24418     +         threads=threads);
24421     +   data _tmout_;
24422     +      merge _tmout_ (in=_A_)
24423     +            _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
24424     +      by _termnum_;
24425     +      if _A_;
24426     +   run;
24428     +   /* Create _segmnt_ variable in WORK._docs data set to prepare it to be an */
24429     +   /* input to %tmterm1 macro. Set it equal to _cluster_ variable. */
24431     +   %if &algorithm=2.0 %then %do;
24432     +        data _docs_;
24433     +            set &outdocs (rename=(index=_document_) keep=index _cluster_ _finalcluster_);
24434     +            _SEGMNT_=_finalcluster_;
24435     +        run;
24436     +        proc sql noprint;
24437     +            select max(_cluster_) into :numclus from &outclusters;
24438     +        quit;
24439     +   %end;
24440     +   %else %do;
24441     +       data _docs_;
24442     +        set &outdocs (rename=(index=_document_) keep=index _cluster_);
24443     +         _SEGMNT_=_cluster_;;
24444     +       run;
24446     +   %end;
24448     +   /* Run %tmterm1 macro to determine descriptive terms for clusters. */
24449     +   %tmterm1(DSN_TPARS=_tmout_,
24450     +        DSN_CLUS=_docs_,
24451     +        DSN_DESC=_desc_,
24452     +        N_DESC_TERMS=&maxnumterms,
24453     +        N_CLUS=&numclus,
24454     +        top_freq=%eval(&maxnumterms*2),
24455     +        key=);
24457     +    /* Add cluster descriptive terms to clusters table. */
24458     +   %tmsort(data=&outclusters,
24459     +         out=&outclusters,
24460     +         by=_cluster_,
24461     +            options=,
24462     +         threads=threads);
24464     +   %tmsort(data=_desc_,
24465     +         out=_desc_,
24466     +         by=_cluster_,
24467     +            options=,
24468     +         threads=threads);
24470     +   data _desc_;
24471     +      merge &outclusters _desc_;
24472     +      by _cluster_;
24473     +   run;
24475     +   %tmsort(data=_desc_,
24476     +         out=&outclusters,
24477     +         by=_cluster_,
24478     +            options=,
24479     +         threads=threads);
24481     +   %if &algorithm=2.0 %then %do;
24483     +        %tmsort(data=&HIERDS,
24484     +         out=&HIERDS,
24485     +         by=_cluster_,
24486     +            options=,
24487     +         threads=threads);
24489     +        data &HIERds;
24490     +            merge &outCLUSTERS &HIERds (keep=_cluster_ parent level in=P);
24491     +            by _cluster_;
24492     +            clust=_cluster_;
24493     +            drop _cluster_;
24494     +            if P;
24495     +        run;
24497     +        %let empty=1;
24499     +        /* Be sure that all parent clusters are on outclusters ds */
24500     +        proc sql noprint;
24501     +            create table &outclusters as
24502     +                select a._cluster_, b.* from &hierds (rename=(clust=_CLUSTER_)) a
24503     +                left join &outclusters b
24504     +                on a._cluster_=b._cluster_;
24505     +        quit;
24507     +        %do %while (&empty);
24508     +            proc sql noprint;
24509     +                update &outclusters set freq=
24510     +                    (select sum(freq) from &HIERDS
24511     +                    where parent=_cluster_), percent=
24512     +                    (select sum(percent) from &HIERDS
24513     +                    where parent=_cluster_)
24514     +                    where freq=. and _cluster_ not in
24515     +                    (select parent from &hierds where freq=.);
24516     +                select count(*) into :empty from &outclusters
24517     +                    where freq=.;
24518     +                update &hierds set freq=(select freq from &outclusters where _cluster_=clust);
24519     +            quit;
24520     +            data &HIERds;
24521     +                merge &OUTCLUSTERS &HIERds (
24522     +                    rename=(clust=_cluster_) keep=clust parent level in=P);
24523     +                by _cluster_;
24524     +                clust=_cluster_;
24525     +                drop _cluster_;
24526     +                if P;
24527     +            run;
24528     +        %end;
24530     +        data &hierds;
24531     +            set &hierds(rename=(CLUST=_CLUSTER_) keep=clust FREQ CLUS_DESC PARENT level);
24532     +        run;
24533     +        data &outclusters;
24534     +            set &outclusters;
24535     +            if _rmsstd_ ne .;
24536     +        run;
24538     +        data &outdocs;
24539     +            set &outdocs (drop=_FINALCLUSTER_ _SUBCLUSTER_);
24540     +            label _CLUSTER_=Cluster ID;
24541     +        run;
24543     +    %end;
24545     +   %end_train_cluster:
24547     +       filename temp;
24549     +       %if &tm_debug =0  %then %do;
24550     +          proc sql nowarn noprint;
24551     +              drop table _clusstat;
24552     +              drop table _clusstat2;
24553     +              drop table _fastclusstat;
24554     +              drop table _clustermean;
24555     +              drop table _meandocs;
24556     +              drop table _rmscalc;
24557     +              drop table _rmsse;
24558     +              drop table _meanerr;
24559     +              drop table _tmutildoc;
24560     +              drop table _desc_;
24561     +              drop table _terms_;
24562     +              drop table _docs_;
24563     +              drop table _tmout_;
24564     +           quit;
24565     +       %end;
24568     +%mend;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_apply_tmutil.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_APPLY_TMUTIL.SOURCE입니다.
24570     + /*****************************************************************
24571     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
24572     + *
24573     + * Name:             tm_apply_tmutil.sas
24574     + * Support:          rualbr Russell Albright
24575     + * Product:
24576     + * Language:         Sas
24577     + * Script:
24578     + *
24579     + * Usage:
24580     + *
24581     + * data= out data set from tgparse
24582     + * terms= terms from tgparse
24583     + * offsets=  addoffset data set form tgparse
24584     + * docs=  data set of document id's and potentially target, not required unless target weighting is used.
24585     + * keepdocs= list of docs to keep. This is a subset of the original docs data set. Not required.
24586     + * reduceF=defaults to log(n) if not specified, eliminates terms if not in at least that many docs
24587     + *     use reduceF=1 to retain all terms.
24588     + * termweight= none, entropy, mi,
24589     + * cellweight= none, log, bin,
24590     + * synnum= Input synonym data set of _termnum_, parent ID pairs
24591     + * synchar= Input synonym data set of term,termrole, parent, parentrole. This data set will
24592     + * get converted to synnym format by the macro tm_convert_syns.
24593     + * targetvar= name of variable on doc dataset contining targetvar.
24594     + * outdata= output out dataset with no more children on this dataset
24595     + * outterms= output terms dataset with dup terms eliminated
24596     + * outweights= weight vector for the terms
24597     + * outoffsets= subsetted outtable with childterms replaced with parents
24598     + * applyweight = , indicates if the weight settings are to be applied to the output OUT table. 0 no, 1 yes.
24599     + * memloc= string for tmutil to use to store its memory pointer. Normally the default can just be used.
24600     + * keeponly=Y  If set to Y (default), then only kept terms are output in terms table.
24601     + *
24602     + * Purpose: Massage the out and key from docparse so that they can bes used
24603     + * in data mining applications.
24604     + *
24605     + * History:
24606     + *
24607     + * Notes:
24608     + *
24609     + * Last Modified By:
24610     + * Last Modified On: Tue Mar 05 16:32:57 2013
24611     + *
24612     + * End
24613     + * ************************************************************** */
24616     +%macro tm_apply_tmutil(data=, terms=,docs=,offsets=,keepdocs=,termweight=none,
24617     +                            cellweight=none,reduceF=,outdata=,outterms=,outweights=,
24618     +                            outoffsets=, synnum=,synchar=, targetvar=, applyweight = 0,
24619     +                            memloc=tmutil_loc,keeponly=Y,repOnly=N);
24620     +     %local keepdocs tempF reduceF synnum  terms  paraExist sentExist;
24623     +    %let EMEXCEPTIONSTRING=;
24624     +    %let syscc=0;
24625     +    %let systmutil=0;
24629     +    /* Find terms to drop */
24630     +        %if &keepdocs ne %then %do;
24631     +          proc sql noprint;
24632     +                create view _keepdata as
24633     +                select * from &data where _DOCUMENT_ in
24634     +                (select _DOCUMENT_ from &keepdocs);
24635     +          quit;
24636     +        %end;
24637     +          %else %do;
24639     +             proc sql noprint;
24640     +                 create view _keepdata as
24641     +                 select * from &data;
24642     +             quit;
24644     +           %let keepdocs=&docs;
24645     +        %end;
24648     +    /* set default on reduceF*/
24649     +         %if &reduceF = %then %do;
24650     +            proc sql noprint;
24651     +           select count(*) into :numdocs from &docs;
24652     +        quit;
24653     +        %let tempF = %sysfunc(log10(%eval(&numdocs+1)));
24654     +        %let reduceF= %sysfunc(floor(&tempF));
24655     +         %end;
24658     +    /* find synnum if synchar supplied */
24660     +    %if &synchar ne %then %do;
24661     +            filename temp catalog 'sashelp.emtxtext.tm_convert_syns.source';
24662     +            %include temp;
24663     +            %tm_convert_syns(insyns= &synchar, outsyns=_myOutsyns ,
24664     +                         interms=&terms,
24665     +                          outterms=newterms );
24666     +                %let numsyns=0;
24667     +                proc sql;
24668     +                   select count(*) into: numsyns
24669     +                   from _myOutsyns;
24670     +                quit;
24671     +                %if &numsyns >0 %then %do;
24672     +                   %Let synnum=_myOutsyns;
24673     +                   %let terms=newterms;
24674     +                %end;
24675     +    %end;
24676     +    /* get the out and key in the proper format*/
24677     +    proc tmutil data=_keepdata key= &terms doc=&keepdocs
24678     +        %if &targetvar ne %then target=&targetvar;
24679     +        ;
24680     +        control init memloc="&memloc";
24681     +            %if &synnum ne %then syn syndata=&synnum force;
24682     +         ;
24683     +    run;
24684     +    %if &syscc >4 %then %goto end_tm_apply_tmutil;
24685     +    %if &reduceF>1 %then %do;
24686     +           proc tmutil;
24687     +           control memloc="&memloc";
24688     +               select reduceF=&reduceF;
24689     +        run;
24690     +   %end;
24691     +    %if &syscc >4 %then %goto end_tm_apply_tmutil;
24693     +     proc tmutil;
24694     +        control memloc="&memloc" release;
24695     +        weight termwgt=&termweight cellwgt=&cellweight;
24696     +            output key=_termstmutil  keyformat=default
24697     +               %if &keeponly eq Y %then keeponly;
24698     +               %if &applyweight  eq 0 %then unweighted ;
24699     +               out=&outdata;
24700     +    run;
24701     +    %if &syscc >4 %then %goto end_tm_apply_tmutil;
24703     +    proc sql noprint;
24704     +           create table _distinctterms as
24705     +           select distinct key,term, role, attribute
24706     +           from &terms;
24708     +       create table &outterms as
24709     +       select  b.term, b.role,b.attribute ,a.*
24710     +       from _termstmutil a left join  _distinctterms b
24711     +       on a.key=b.key;
24712     +       ;
24713     +       %if &outweights ne %then %do;
24714     +          create table &outweights as
24715     +          select distinct a.key as index, a.weight as gwgt
24716     +          from &outterms(where=(_ispar in('+',' '))) a inner join
24717     +                         _distinctterms b
24718     +          on a.key =b.key;
24719     +       %end;
24721     +     quit;
24722     +     %if &offsets ne and &outoffsets ne %then %do;
24724     +        %let paraExist=0; %let sentExist=0;
24725     +        data _null_;
24726     +          dsid=open("&offsets");
24727     +          para=varnum(dsid,'_paragraph_');
24728     +          sent=varnum(dsid,'_sentence_');
24729     +          if para ge 1 then call symput('paraExist',1);
24730     +          if sent ge 1 then call symput('sentExist',1);
24731     +          run;
24734     +        proc sql noprint;
24735     +        create table &outoffsets as
24736     +           select  a._document_,
24737     +              %if &paraExist=1 %then a._paragraph_, ;
24738     +              %if &sentExist=1 %then a._sentence_,;
24739     +              a._offset_, a._length_, b.parent_id as _termnum_
24740     +                 from &offsets a, _termstmutil (where=(_ispar ne "+" and keep="Y")) b
24741     +                 where a._termnum_ = b.key;
24742     +              quit;
24743     +       %end;
24747     +     %end_tm_apply_tmutil:
24749     +     %if ^%symexist(tm_debug) %then %let tm_debug=0;
24750     +       %if &tm_debug =0  %then %do;
24751     +          proc sql noprint;
24752     +            drop table _termstmutil;
24753     +            drop table _distinctterms;
24754     +            drop view _keepdata;
24755     +            %if &synchar ne and &synnum ne  %then drop table &synnum; ;
24756     +         quit;
24757     +     %end;
24758     +     %if &syscc >4 and &systmutil > 4 %then %do;
24759     +           %let EMEXCEPTIONSTRING = EMTOOL.TMUTIL,&systmutil;
24760     +           %put emexceptionstring= "&EMEXCEPTIONSTRING";
24761     +           %let syscc=0;
24762     +     %end;
24764     +%mend;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_svd_do_samp.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_SVD_DO_SAMP.SOURCE입니다.
24766     +   /* ****************************************************************
24767     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
24768     + *
24769     + * Name:             tm_svd_do_samp.sas
24770     + * Product:
24771     + * Language:         Sas
24772     + * Script:
24773     + *
24774     + * Usage:
24775     + *
24776     + * data=out dataset containing only repreentative terms
24777     + * maxK= max number of dimensions to use to computer svd
24778     + * res=<high, med, low> guidenceon what number of dims to choose
24779     + * cellwgt= <none, log, binary>
24780     + * in_global= dataset with index, weight variables
24781     + * rowVar= name of the variable representing row(term)
24782     + * colVar= name of the variable representing col
24783     + * entryVar=count for row,col
24784     + * u= name of output u matrix
24785     + * v= name of output v matrix
24786     + * s= name of output s matrix
24787     + * colpro=dataset to hold projections for terms
24788     + * rowpro= datset to hold projections for docs
24789     + * normcol=<normcol> extra option to add to normalize docs
24790     + * normrow=<normrow> extra option to add to normalize terms
24791     + * docs =<document data set of ids that are being analyzed.
24792     +*      docs needs to be input explicit since some docs may have not terms
24793     + *
24794     + * Purpose: macro to run svd and compute projections, first without mpling
24795     + * and then with sampling onon.
24796     + *
24797     + * History:
24798     + *
24799     + * Notes:
24800     + *
24801     + * Last Modified By:
24802     + * Last Modified On: Thu Jan 08 17:22:43 2009
24803     + *
24804     + * End
24805     + * ************************************************************** */
24806     +%macro tm_svd_do_samp(data=,docs=,maxK=,res=,cellwgt=,in_global=,
24807     +                     rowVar=,colVar=,entryVar=,u=,v=,s=,
24808     +                     colpro=,rowpro=,normcol=, normrow=,prefix=SVD);
24810     +   %local svdkeep;
24811     +   %let syscc=0;
24812     +   proc sort data=&data; by _termnum_; run;
24814     +   proc spsvd data=&data max_k = &maxK res = &res
24815     +       local = &cellWgt global =none in_global = &in_global;
24816     +       row _termnum_;
24817     +       col _document_;
24818     +       entry _count_;
24819     +       output  u = &U v = &V s = &s;
24820     +   run;
24822     +   /*try sampling if out of memory occurred*/
24823     +   %if(&syscc eq 1111) %then %do;
24824     +      %let syscc=0; /*reset syscc*/
24825     +      proc spsvd data = &data max_k = &maxK res = &res
24826     +          local = &cellWgt global = none in_global = &in_global ;
24827     +          row &rowVar;
24828     +          col &colVar;
24829     +          entry &entryVar;
24830     +          output u = &U v = &V s = &s;
24831     +          sample allow;
24832     +      run;
24833     +   %end;
24834     +    %if &syscc > 4 %then %do;
24835     +       %let EMEXCEPTIONSTRING = EMTOOL.SPSVDERROR;
24836     +       %goto end_svd_do_samp;
24837     +    %end;
24840     +   /* if resolution is used, the matrix U/V must be truncated to the set number of dim.*/
24841     +   proc sql noprint;
24842     +       select count(*) into: svdkeep
24843     +       from &s
24844     +       where keep=1;
24845     +    quit;
24847     +    %let svdkeep=%left(&svdkeep);
24848     +    data &U;
24849     +    set &U(keep= index col1-col&svdkeep);
24850     +    run;
24852     +    data &V;
24853     +    set &V(keep= index col1-col&svdkeep);
24854     +    run;
24855     +    %if &colpro ne %then %do;
24856     +       /* when sampling weights may have wrong dimensions*/
24857     +       proc sql noprint;
24858     +          create table new_global as
24859     +             select a.*
24860     +             from &in_global a, &U b
24861     +             where a.index = b.index;
24862     +       quit;
24865     +        proc sort data=&data; by &colVar; run;
24866     +        proc spsvd data=&data IN_U=&U
24867     +            local = &cellWgt global = none in_global = new_global ;
24868     +            row &rowVar;
24869     +            col &colVar;
24870     +            entry &entryVar;
24871     +            output colpro=&colpro bigpro normcol prefix="&prefix._SVD";
24872     +        run;
24874     +        proc sort data=&docs(keep=_document_)  out=_docids;
24875     +        by _document_;
24876     +        run;
24878     +        data &colpro;
24879     +           merge &colpro _docids(rename=(_document_=index));
24880     +        by index;
24881     +        run;
24884     +        data &colpro;
24885     +          set  &colpro;
24886     +          array svd_array &prefix._SVD1 - &prefix._SVD&SVDKEEP;
24887     +          do i = 1 to dim(svd_array);
24888     +             if svd_array(i)=. then svd_array(i)=0;
24889     +          end;
24890     +          drop i;
24891     +        run;
24892     +    %end;
24894     +    %if &syscc > 4 %then %do;
24895     +       %let EMEXCEPTIONSTRING = EMTOOL.SPSVDERROR;
24896     +       %goto end_svd_do_samp;
24897     +    %end;
24899     +    %if &rowpro ne %then %do;
24900     +        proc sort data=&data; by &rowVar; run;
24901     +        /* when sampling weights may have wrong dimensions*/
24902     +       proc sql;
24903     +          create table new_global as
24904     +             select a.*
24905     +             from &in_global a, &U b
24906     +             where a.index = b.index;
24907     +       quit;
24909     +        proc spsvd data=&data IN_V=&V
24910     +            local = &cellWgt global = none in_global = new_global ;
24911     +            row &rowVar; col &colVar; entry &entryVar;
24912     +            output wordPro = &rowpro bigpro normrow prefix="&prefix._SVD";
24913     +        run;
24914     +    %end;
24916     +    %if &syscc > 4 %then %do;
24917     +       %let EMEXCEPTIONSTRING = EMTOOL.SPSVDERROR;
24918     +       %goto end_svd_do_samp;
24919     +    %end;
24921     +   %end_svd_do_samp:
24923     +%mend;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   filename temp;
NOTE: Fileref TEMP을(를) 삭제했습니다.
MPRINT(TM_GET_LAST_FILTER):   * find last filter or text parse node if no filter node. ;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select data into :last_parse_node from EMWS5.TextTopic_EMINFO where key="LastTextParsing";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_filter_node from EMWS5.TextTopic_EMINFO where key="LastTextFilter";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_prescore_node from EMWS5.TextTopic_EMINFO where kupcase(key)="PRESCORECODE";
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_GET_LAST_FILTER):   * Check to make sure parse variable is present and still exists;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select parsevar into :parsevar from EMWS5.TextFilter_tmconfig;
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_GET_LAST_FILTER):   *check for dropped parsevar on input dataset;
MPRINT(TM_GET_LAST_FILTER):   data _null_;
MPRINT(TM_GET_LAST_FILTER):   set EMWS5.TextCluster3_VariableSet(where=(kupcase(NAME)="REVIEW" and USE in('Y' 'D')));
MPRINT(TM_GET_LAST_FILTER):   if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
MPRINT(TM_GET_LAST_FILTER):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_VARIABLESET.에서 읽었습니다.
      WHERE (KUPCASE(NAME)='REVIEW') and USE in ('D', 'Y');
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data EMWS5.TextCluster3_last_tm_nodes;
MPRINT(TRAIN):   set EMWS5.TextTopic_EMINFO;
MPRINT(TRAIN):   run;
 
NOTE: 8개의 관측값을 데이터셋 EMWS5.TEXTTOPIC_EMINFO.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_LAST_TM_NODES은(는) 8개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   set EMWS5.TextCluster3_VariableSet(where=(ROLE='TARGET' and USE in('Y' 'D') and LEVEL ne 'INTERVAL'));
MPRINT(TRAIN):   if _N_=1 then call symput('targetvar', strip(NAME));
MPRINT(TRAIN):   run;
 
NOTE: 0개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_VARIABLESET.에서 읽었습니다.
      WHERE (ROLE='TARGET') and USE in ('D', 'Y') and (LEVEL not = 'INTERVAL');
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   create table EMWS5.TextCluster3_tmconfig as select * from EMWS5.TextFilter_tmconfig;
NOTE: Table EMWS5.TEXTCLUSTER3_TMCONFIG created, with 1 rows and 30 columns.
 
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select cellwgt into: _cellweight from EMWS5.TextCluster3_tmconfig;
MPRINT(TRAIN):   select termwgt into: _termwgt from EMWS5.TextCluster3_tmconfig;
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):   data _keepdocs (keep=_DOCUMENT_ );
MPRINT(TRAIN):   set EMWS5.TextTopic_TRAIN;
MPRINT(TRAIN):   run;
 
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTTOPIC_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 WORK._KEEPDOCS은(는) 500개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_APPLY_TMUTIL):   proc sql noprint;
MPRINT(TM_APPLY_TMUTIL):   create view _keepdata as select * from EMWS5.TextFilter_tmout where _DOCUMENT_ in (select _DOCUMENT_ from _keepdocs);
NOTE: SQL view WORK._KEEPDATA has been defined.
MPRINT(TM_APPLY_TMUTIL):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_APPLY_TMUTIL):   proc tmutil data=_keepdata key= EMWS5.TextFilter_terms doc=_keepdocs ;
MPRINT(TM_APPLY_TMUTIL):   control init memloc="_tmmem";
MPRINT(TM_APPLY_TMUTIL):   ;
MPRINT(TM_APPLY_TMUTIL):   run;
 
WARNING:  The input DOC data set contained documents numbered larger than those on the input DATA data set.
NOTE: 3584개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TMOUT.에서 읽었습니다.
NOTE: 499개의 관측값을 데이터셋 WORK._KEEPDOCS.에서 읽었습니다.
NOTE: 3584개의 관측값을 데이터셋 WORK._KEEPDATA.에서 읽었습니다.
NOTE: 2184개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TERMS_DATA.에서 읽었습니다.
      WHERE KEEP='Y';
NOTE: 1870개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TERM_STRINGS.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._KEEPDOCS.에서 읽었습니다.
NOTE: 프로시저 TMUTIL 실행(총 프로세스 시간):
      실행 시간           0.36 초
      cpu 시간            0.18 초
 
 
MPRINT(TM_APPLY_TMUTIL):   proc tmutil;
MPRINT(TM_APPLY_TMUTIL):   control memloc="_tmmem";
MPRINT(TM_APPLY_TMUTIL):   select reduceF=2;
MPRINT(TM_APPLY_TMUTIL):   run;
 
NOTE: 프로시저 TMUTIL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_APPLY_TMUTIL):   proc tmutil;
MPRINT(TM_APPLY_TMUTIL):   control memloc="_tmmem" release;
MPRINT(TM_APPLY_TMUTIL):   weight termwgt=ENTROPY cellwgt=LOG;
MPRINT(TM_APPLY_TMUTIL):   output key=_termstmutil keyformat=default keeponly unweighted out=_outtmutil_;
MPRINT(TM_APPLY_TMUTIL):   run;
 
NOTE: 데이터셋 WORK._TERMSTMUTIL은(는) 706개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: 데이터셋 WORK._OUTTMUTIL_은(는) 2483개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 TMUTIL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_APPLY_TMUTIL):   proc sql noprint;
MPRINT(TM_APPLY_TMUTIL):   create table _distinctterms as select distinct key,term, role, attribute from EMWS5.TextFilter_terms;
NOTE: Table WORK._DISTINCTTERMS created, with 1869 rows and 4 columns.
 
MPRINT(TM_APPLY_TMUTIL):   create table _newkey as select b.term, b.role,b.attribute ,a.* from _termstmutil a left join _distinctterms b on a.key=b.key;
NOTE: Table WORK._NEWKEY created, with 706 rows and 11 columns.
 
MPRINT(TM_APPLY_TMUTIL):   ;
MPRINT(TM_APPLY_TMUTIL):   create table _weights as select distinct a.key as index, a.weight as gwgt from _newkey(where=(_ispar in('+',' '))) a inner join _distinctterms b on a.key =b.key;
NOTE: Table WORK._WEIGHTS created, with 469 rows and 2 columns.
 
MPRINT(TM_APPLY_TMUTIL):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.15 초
      cpu 시간            0.09 초
 
 
MPRINT(TRAIN):  ;
MPRINT(TM_SVD_DO_SAMP):   proc sort data=_outtmutil_;
MPRINT(TM_SVD_DO_SAMP):   by _termnum_;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 2483개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 데이터셋 WORK._OUTTMUTIL_은(는) 2483개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc spsvd data=_outtmutil_ max_k = 100 res = LOW local = LOG global =none in_global = _weights;
MPRINT(TM_SVD_DO_SAMP):   row _termnum_;
MPRINT(TM_SVD_DO_SAMP):   col _document_;
MPRINT(TM_SVD_DO_SAMP):   entry _count_;
MPRINT(TM_SVD_DO_SAMP):   output u = EMWS5.TextCluster3_svd_u v = _svdv s = EMWS5.TextCluster3_svd_s;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: P has been set to 25.
NOTE: Restart 1, Converged 43
NOTE: Restart 2, Converged 54
NOTE: Restart 3, Converged 71
NOTE: Restart 4, Converged 86
NOTE: Restart 5, Converged 98
NOTE: Singular values have converged.  Creating data sets.
NOTE: Restarted 5 times.
NOTE: Using value of 44 for K.
NOTE: 2483개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 469개의 관측값을 데이터셋 WORK._WEIGHTS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_SVD_U은(는) 469개의 관측값과 101개의 변수를 가지고 있습니다.
NOTE: 데이터셋 WORK._SVDV은(는) 430개의 관측값과 101개의 변수를 가지고 있습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_SVD_S은(는) 100개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SPSVD 실행(총 프로세스 시간):
      실행 시간           0.45 초
      cpu 시간            0.28 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sql noprint;
MPRINT(TM_SVD_DO_SAMP):   select count(*) into: svdkeep from EMWS5.TextCluster3_svd_s where keep=1;
MPRINT(TM_SVD_DO_SAMP):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_SVD_DO_SAMP):   data EMWS5.TextCluster3_svd_u;
MPRINT(TM_SVD_DO_SAMP):   set EMWS5.TextCluster3_svd_u(keep= index col1-col44);
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 469개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_SVD_U.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_SVD_U은(는) 469개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_SVD_DO_SAMP):   data _svdv;
MPRINT(TM_SVD_DO_SAMP):   set _svdv(keep= index col1-col44);
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 430개의 관측값을 데이터셋 WORK._SVDV.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDV은(는) 430개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sql noprint;
MPRINT(TM_SVD_DO_SAMP):   create table new_global as select a.* from _weights a, EMWS5.TextCluster3_svd_u b where a.index = b.index;
NOTE: Table WORK.NEW_GLOBAL created, with 469 rows and 2 columns.
 
MPRINT(TM_SVD_DO_SAMP):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sort data=_outtmutil_;
MPRINT(TM_SVD_DO_SAMP):   by _document_;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 2483개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 데이터셋 WORK._OUTTMUTIL_은(는) 2483개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc spsvd data=_outtmutil_ IN_U=EMWS5.TextCluster3_svd_u local = LOG global = none in_global = new_global ;
MPRINT(TM_SVD_DO_SAMP):   row _termnum_;
MPRINT(TM_SVD_DO_SAMP):   col _document_;
MPRINT(TM_SVD_DO_SAMP):   entry _count_;
MPRINT(TM_SVD_DO_SAMP):   output colpro=_svdcolpro bigpro normcol prefix="TextCluster3_SVD";
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 2483개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 469개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_SVD_U.에서 읽었습니다.
NOTE: 469개의 관측값을 데이터셋 WORK.NEW_GLOBAL.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDCOLPRO은(는) 430개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: 프로시저 SPSVD 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sort data=_keepdocs(keep=_document_) out=_docids;
MPRINT(TM_SVD_DO_SAMP):   by _document_;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._KEEPDOCS.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCIDS은(는) 500개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   data _svdcolpro;
MPRINT(TM_SVD_DO_SAMP):   merge _svdcolpro _docids(rename=(_document_=index));
MPRINT(TM_SVD_DO_SAMP):   by index;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 430개의 관측값을 데이터셋 WORK._SVDCOLPRO.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCIDS.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDCOLPRO은(는) 500개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   data _svdcolpro;
MPRINT(TM_SVD_DO_SAMP):   set _svdcolpro;
MPRINT(TM_SVD_DO_SAMP):   array svd_array TextCluster3_SVD1 - TextCluster3_SVD44;
MPRINT(TM_SVD_DO_SAMP):   do i = 1 to dim(svd_array);
MPRINT(TM_SVD_DO_SAMP):   if svd_array(i)=. then svd_array(i)=0;
MPRINT(TM_SVD_DO_SAMP):   end;
MPRINT(TM_SVD_DO_SAMP):   drop i;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._SVDCOLPRO.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDCOLPRO은(는) 500개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sort data=_outtmutil_;
MPRINT(TM_SVD_DO_SAMP):   by _termnum_;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 2483개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 데이터셋 WORK._OUTTMUTIL_은(는) 2483개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sql;
MPRINT(TM_SVD_DO_SAMP):   create table new_global as select a.* from _weights a, EMWS5.TextCluster3_svd_u b where a.index = b.index;
NOTE: Table WORK.NEW_GLOBAL created, with 469 rows and 2 columns.
 
MPRINT(TM_SVD_DO_SAMP):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc spsvd data=_outtmutil_ IN_V=_svdv local = LOG global = none in_global = new_global ;
MPRINT(TM_SVD_DO_SAMP):   row _termnum_;
MPRINT(TM_SVD_DO_SAMP):   col _document_;
MPRINT(TM_SVD_DO_SAMP):   entry _count_;
MPRINT(TM_SVD_DO_SAMP):   output wordPro = _svdrowpro bigpro normrow prefix="TextCluster3_SVD";
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 2483개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 430개의 관측값을 데이터셋 WORK._SVDV.에서 읽었습니다.
NOTE: 469개의 관측값을 데이터셋 WORK.NEW_GLOBAL.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDROWPRO은(는) 469개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: 프로시저 SPSVD 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   create table EMWS5.TextCluster3_terms(drop=index) as select a.*,b.* from EMWS5.TextFilter_terms a left join _svdrowpro b on a.key = b.index;
NOTE: Table EMWS5.TEXTCLUSTER3_TERMS created, with 2184 rows and 57 columns.
 
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.07 초
 
 
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmgetncl.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMGETNCL.SOURCE입니다.
24926     +
24927     + /*
24928     +  Macro:   tmgetncl.sas
24929     +  Purpose: To obtain a default number of clusters
24930     +  Syntax:  %tmgetncl(data=, maxclusters=, vars=);
24931     +
24932     +  Required Parameters:  data=      The input data set.
24933     +
24934     +  Optional Parameters:  vars=      Variables to be used
24935     +
24936     +  History:
24937     +  2001/01/23 - Bill Wheeler - Initial Coding.
24938     +
24939     +*/
24940     + %MACRO tmgetncl(data=, maxclusters=, vars=, tempDS=,
24941     +                 clusDS=, threads=THREADS);
24942     +
24943     +  %if &maxclusters= %then %let maxclusters = 40;
24944     +
24945     +  %if &vars ^= %then %let var = var &vars;
24946     +  %else %let var = ;
24947     +
24948     +  /* run PROC FASTCLUS with maxClusters clusters */
24949     +  proc fastclus data = &data noprint
24950     +    maxclusters = &maxclusters
24951     +    mean = &tempDS;
24952     +    &var
24953     +    ;
24954     +    run;
24955     +
24956     +  /* use PROC CLUSTER with the MEAN data set from FASTCLUS */
24957     +  proc cluster data = &tempDS
24958     +    method = WARD
24959     +    pseudo
24960     +    noprint
24961     +    outtree = &tempDS;
24962     +    &var;
24963     +  run;
24964     +
24965     +  %if (&SYSERR > 4) %then %do;
24966     +    data &clusDS; nclus = 0; run;
24967     +    %goto exit;
24968     +  %end;
24969     +
24970     +  /* sort and get rid of missing values in the outtree data set */
24971     +  %tmsort(data=&tempDS(where=(_ccc_ > -99999.0) keep = _ncl_ _ccc_),
24972     +        out=&tempDS, by=_ncl_, options=, threads=&threads);
24973     +
24974     +  data &clusDS; set &tempDS;
24975     +    keep nclus;
24976     +    retain loclclus -1 loclccc 0 maxccc 0 maxclus 0
24977     +   jclus -1 maxjump -1 nclus 0 jccc 0 prevjump 0 jump 0 occc 0 oncl 0;
24978     +
24979     +   if _N_ = 1 then do;
24980     +     maxccc = _ccc_;
24981     +     maxclus = _ncl_;
24982     +     nclus = _ncl_;
24983     +     occc = _ccc_;
24984     +     oncl = _ncl_;
24985     +   end;
24986     +   else if (_N_ = 2) then do;
24987     +     jump = _ccc_ - occc;
24988     +     if (jump > 0) then do;
24989     +       maxjump = jump;
24990     +       jclus = _ncl_;
24991     +     end;
24992     +     if (_ccc_ > maxccc) then do;
24993     +       maxccc = _ccc_;
24994     +       maxclus = _ncl_;
24995     +     end;
24996     +     occc = _ccc_;
24997     +     oncl = _ncl_;
24998     +   end;
24999     +
25000     +   else if (_N_ > 2) then do;
25001     +     prevjump = jump;
25002     +     jump = _ccc_ - occc;
25003     +
25004     +     if ((prevjump > 0) & (jump < 0) & (loclclus < 0)) then do;
25005     +        loclclus = oncl;
25006     +        loclccc = occc;
25007     +     end;
25008     +     if (_ccc_ > maxccc) then do;
25009     +       maxccc = _ccc_;
25010     +       maxclus = _ncl_;
25011     +     end;
25012     +     if ((jump > 0) & (jump > maxjump)) then do;
25013     +       jclus = _ncl_;
25014     +       maxjump = jump;
25015     +       jccc = _ccc_;
25016     +     end;
25017     +
25018     +     occc = _ccc_;
25019     +     oncl = _ncl_;
25020     +
25021     +     if ((loclclus > 0) & (jclus > 0)) then nclus = MIN(loclclus, jclus);
25022     +     else if (loclclus > 0) then nclus = loclclus;
25023     +     else if (jclus > 0) then nclus = jclus;
25024     +     else nclus = maxclus;
25025     +   end;
25026     +  run;
25027     +
25028     +  %exit: ;
25029     +
25030     +%MEND tmgetncl;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmfast.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMFAST.SOURCE입니다.
25031     + /*
25032     +
25033     +  Macro:   tmfast.sas
25034     +  Purpose: Call proc fastclus with given defaults and parameters.
25035     +  Syntax:  %tmfast(data=, clusters=, outstat=, vars=);
25036     +
25037     +  Required Parameters:  data=      The input data set.
25038     +                        clusters=  The maximum number of clusters
25039     +
25040     +  Optional Parameters:  vars=      Variables to be used
25041     +                        outstat=   The name of the OUTSTAT data set
25042     +                        outseed=   The name of the OUTSEED data set
25043     +
25044     +  Either outstat or outseed mut be given, but not both.
25045     +  History:
25046     +  2001/01/16 - Bill Wheeler - Initial Coding.
25047     +
25048     +*/
25049     +%MACRO tmfast(data=, clusters=, outstat=, outseed=,
25050     +                 id=, out=, vars=);
25051     + /* defaults */
25052     + %if (&id ne ) %then %let id = id &id;
25053     + %if (&out ne ) %then %let out = out = &out;
25054     + %if (&vars ne ) %then %let var = var &vars;
25055     + %else %let var = ;
25056     +
25057     + %if &outseed= %then
25058     + %do;
25059     +   proc fastclus data = &data
25060     +   maxclusters = &clusters noprint
25061     +   outstat = &outstat &out;
25062     +   &var;
25063     +   &id;
25064     + %end;
25065     + %else
25066     + %do;
25067     +   proc fastclus data = &data
25068     +   maxclusters = &clusters noprint
25069     +   outseed = &outseed &out;
25070     +   &var;
25071     +   &id;
25072     + %end;
25073     +%MEND tmfast;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmemclus.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMEMCLUS.SOURCE입니다.
25074     +
25075     + /*
25076     +
25077     +  Macro:   tmemclus.sas
25078     +  Purpose: Call proc emclus with given defaults and parameters.
25079     +  Syntax:  %tmemclus(data=, role=, clusters=, seed=,
25080     +                   outstat=, out=, vars=, cov=, iter=, secclus=,
25081     +                   seciter=, min=, method=, eps=, init=, print=,
25082     +                   p=, outliers=, decvar=, initstd=, dist=,
25083     +                   secstd=, nobs=, threads=);
25084     +  Required Parameters:  data=      The input data set.
25085     +                        role=      Train or score
25086     +                        clusters=  The number of primary clusters
25087     +
25088     +  Optional Parameters:  vars=      Variables to be used
25089     +                   cov=       Type of covariance matrix
25090     +                   iter=      Number of EM iterations
25091     +                   secclus    Number of secondary clusters
25092     +                   seciter    Number of k-means iterations
25093     +                   min=       Minimum number of obs in a cluster
25094     +                   method=    Standard or scaled
25095     +                   eps=       Stopping tolerance
25096     +                   init=      Random, Fastclus, or Emclus
25097     +                   print=     All, last, or none
25098     +                   p=
25099     +                   outliers=  Keep, cluster, or ignore
25100     +                   outstat=   Name of OUTSTAT data set
25101     +                   out=       Name of OUT data set
25102     +                   seed=      Name of SEED data set
25103     +                   decvar=    Proportion to decrease variances
25104     +                   initstd=   Initial standard deviation
25105     +                   dist=      Minimum distance between clusters
25106     +                   secstd=    Secondary cluster max std dev.
25107     +                   nobs=      Number of obs read in each iteration
25108     +  History:
25109     +  2001/01/16 - Bill Wheeler - Initial Coding.
25110     +  2001/11/29 - Bill Wheeler - Updated for version 8 or 9
25111     +*/
25112     +%MACRO tmemclus(data=, role=, clusters=, seed=,
25113     + outstat=, out=, vars=, cov=, iter=, secclus=,
25114     + seciter=, min=, method=, eps=, init=, print=,
25115     + p=, outliers=, decvar=, initstd=, dist=, secstd=, nobs=, threads=);
25116     +
25117     + %local saveout saveseed op1 op2 op3 op4;
25118     +
25119     + %LET saveout = &out;
25120     + %LET saveseed = &outstat;
25121     +
25122     + /* defaults */
25123     + %if &role= %then %let role = TRAIN;
25124     + %if &seed ne %then %let seed = seed=&seed;
25125     + %if &vars= %then %let var = ;
25126     + %else %let var = var &vars;
25127     + %if &cov ne %then %let cov = cov = &cov;
25128     + %if &iter ne %then %let iter = iter = &iter;
25129     + %if &init ne %then %let init = init = &init;
25130     + %if &eps ne  %then %let eps = eps = &eps;
25131     + %if &min ne %then %let min = min = &min;
25132     + %if &seciter ne %then %let seciter = seciter = &seciter;
25133     + %if &print ne %then %let print = print = &print;
25134     + %if &p ne %then %let p = p = &p;
25135     + %if &outliers ne %then %let outliers = outliers = &outliers;
25136     + %if &method ne %then %let method = method = &method;
25137     + %if &decvar ne %then %let decvar = decvar = &decvar;
25138     + %if &outstat ne %then %let outstat = outstat = &outstat;
25139     + %if &out ne %then %let out = out = &out;
25140     + %if (&threads >= 0)  %then %let threads = threads = &threads;
25141     + %else %let threads = ;
25142     +
25143     + %LET op1 = ;
25144     + %LET op2 = ;
25145     + %LET op3 = ;
25146     + %LET op4 = ;
25147     + %if ^(&initstd=) %then %let op1 = %str(initstd = &initstd);
25148     + %if ^(&dist=) %then %let op2 = %str(dist = &dist);
25149     + %if ^(&secstd=) %then %let op3 = %str(secstd = &secstd);
25150     + %if ^(&nobs=) %then %let op4 = %str(nobs = &nobs);
25151     +
25152     +
25153     + %IF &SYSVER < 9 %THEN %DO;
25154     +    %LET cov = ;
25155     +    %LET decvar = ;
25156     +    %LET outliers = ;
25157     +    %LET out = ;
25158     + %END;
25159     +
25160     +
25161     + %if %upcase(&role) = TRAIN %then
25162     + %do;
25163     +   proc emclus data = &data
25164     +   clusters = &clusters
25165     +   &seed
25166     +   &outstat
25167     +   &out
25168     +   &init
25169     +   &eps
25170     +   &method
25171     +   &secclus
25172     +   &min
25173     +   &print
25174     +   &outliers
25175     +   &iter
25176     +   &op1 &op2
25177     +   &op3 &op4
25178     +   &decvar
25179     +   &cov
25180     +   &threads
25181     +   ;
25182     +   &var;
25183     + %end;
25184     + %else
25185     +  %do;
25186     +    proc emclus data = &data
25187     +    role = score
25188     +    clusters = &clusters
25189     +    &seed
25190     +    &out
25191     +    &cov
25192     +    ;
25193     +    &var;
25194     +  %end;
25195     +
25196     + %IF &SYSVER < 9 and &saveout ^= %THEN %DO;
25197     +   proc emclus data = &data
25198     +   role = score
25199     +   clusters = &clusters
25200     +   seed = &saveseed
25201     +   &saveout
25202     +   ;
25203     +   &var;
25204     + %END;
25205     +
25206     +
25207     +%MEND tmemclus;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmpred.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMPRED.SOURCE입니다.
25208     +
25209     +/*
25210     +  Macro: tmpred(inds,outds,clusters,type=,ignore=,freqDS=)
25211     +
25212     +  Description: This macro will take output from
25213     +     emclus and generate predicted
25214     +      predicted clusters.
25215     +
25216     +  Parms: inds - input data set, produced by emclus.
25217     +   outds - data set with clusters created by this macro.
25218     +   clusters - number of clusters that should be on this data set
25219     +   type - valid values: 'max' or 'prob'.  Max will just take the
25220     +      cluster with the highest probability as the predicted cluster.
25221     +      In the case of a tie the first cluster with that value will
25222     +       selected.
25223     +      Prob will attempt to select multiple clusters based on
25224     +      how many clusters were requested.  That is if 3 clusters
25225     +      were requested, any cluster with prob>1/3 will be selected
25226     +      as the predicted cluster. THIS OPTION IS UNTESTED.
25227     +*/
25228     +
25229     +%macro tmpred(inds,outds,clusters,type=, ignore=0, freqDS=, compress=1);
25230     +
25231     +  %local _str newfreqDS _flag;
25232     +
25233     +  * set the optional arguments;
25234     +  %if &type= %then %let type=max;
25235     +  %if &ignore = 1 %then %let
25236     +    _str = if _CLUSTER_ = &clusters then _CLUSTER_ = .;
25237     +  %else %let _str = ;
25238     +  %if %str(&freqDS) ^= %str() %then %do;
25239     +   %let newfreqDS = &freqDS(keep=_c1-_c&clusters);
25240     +   %let _flag = 1;
25241     +  %end;
25242     +  %else %let _flag = 0;
25243     +
25244     +  %if &compress = 1 %then %let compress = compress=Y;
25245     +  %else %let compress = ;
25246     +
25247     +  data &outds(&compress drop=_c1-_c&clusters)
25248     +    %if &_flag = 1 %then %do;
25249     +    &newfreqDS
25250     +    %end;
25251     +    ;
25252     +    set &inds end=eof;
25253     +   * array for holding all probabilities;
25254     +    array _p prob1--prob&clusters;
25255     +    array _c(&clusters);
25256     +    retain _c 0;
25257     +   * get rid of working columns;
25258     +    drop _max_ _i /*prob1--prob&clusters*/ _WARN_;
25259     +    /* keep the largest probability and the cluster */
25260     +    _max_ = 0;
25261     +    do _i = 1 to &clusters;
25262     +      if _p(_i) > _max_ then do;
25263     +        _max_ = _p(_i);
25264     +        _CLUSTER_ = _i;
25265     +      end;
25266     +    end;
25267     +    if (_CLUSTER_ >= 1) and (_CLUSTER_ <= &clusters) then
25268     +      _c(_CLUSTER_) = _c(_CLUSTER_) + 1;
25269     +    else _CLUSTER_ = .;
25270     +    &_str;
25271     +    %if &_flag = 1 %then %do;
25272     +      if eof then do;
25273     +        output &freqDS;
25274     +                output &outDS;
25275     +          end;
25276     +          else output &outDS;
25277     +        %end;
25278     +
25279     +    run;
25280     +%mend tmpred;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmsort.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMSORT.SOURCE입니다.
25281     + /*
25282     +PROC SORT macro
25283     +
25284     +%tmsort(data=, out=, by=);
25285     +
25286     +data=      - name of input data set (outtree data set from PROC CLUSTER)
25287     +out=       - name of the output data set
25288     +by=        - by statement
25289     +options=   - proc options
25290     +*/
25291     +
25292     +%macro tmsort(data=, out=, by=, options=, threads=THREADS);
25293     +  %if %BQUOTE(&out) ^= %then %let out = out =  &out;
25294     +  %if &SYSVER < 9 %then %let threads = ;
25295     +
25296     +  proc sort data = %STR(&data) &threads &options
25297     +    &out;
25298     +    by &by;
25299     +  run;
25300     +
25301     +%mend tmsort;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select count(*) into: numTerms from EMWS5.TextFilter_terms a where a.numdocs>=2 and _ispar in('+',' ') ;
MPRINT(TM_CLUSTER):   select count (*) into: numdocs from EMWS5.TextTopic_TRAIN a;
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETNCL):   proc fastclus data = _svdcolpro noprint maxclusters = 10 mean = _clusTemp1;
MPRINT(TMGETNCL):   var TextCluster3_SVD1 - TextCluster3_SVD44 ;
MPRINT(TMGETNCL):   run;
 
NOTE: 데이터셋 WORK._CLUSTEMP1은(는) 10개의 관측값과 51개의 변수를 가지고 있습니다.
NOTE: 프로시저 FASTCLUS 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.00 초
 
 
MPRINT(TMGETNCL):   proc cluster data = _clusTemp1 method = WARD pseudo noprint outtree = _clusTemp1;
MPRINT(TMGETNCL):   var TextCluster3_SVD1 - TextCluster3_SVD44;
MPRINT(TMGETNCL):   run;
 
NOTE: 데이터셋 WORK._CLUSTEMP1은(는) 19개의 관측값과 60개의 변수를 가지고 있습니다.
NOTE: 프로시저 CLUSTER 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _clusTemp1(where=(_ccc_ > -99999.0) keep = _ncl_ _ccc_) out = _clusTemp1;
MPRINT(TMSORT):   by _ncl_;
MPRINT(TMSORT):   run;
 
NOTE: 9개의 관측값을 데이터셋 WORK._CLUSTEMP1.에서 읽었습니다.
      WHERE _ccc_>-99999;
NOTE: 데이터셋 WORK._CLUSTEMP1은(는) 9개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETNCL):  ;
MPRINT(TMGETNCL):   data _clusTemp;
MPRINT(TMGETNCL):   set _clusTemp1;
MPRINT(TMGETNCL):   keep nclus;
MPRINT(TMGETNCL):   retain loclclus -1 loclccc 0 maxccc 0 maxclus 0 jclus -1 maxjump -1 nclus 0 jccc 0 prevjump 0 jump 0 occc 0 oncl 0;
MPRINT(TMGETNCL):   if _N_ = 1 then do;
MPRINT(TMGETNCL):   maxccc = _ccc_;
MPRINT(TMGETNCL):   maxclus = _ncl_;
MPRINT(TMGETNCL):   nclus = _ncl_;
MPRINT(TMGETNCL):   occc = _ccc_;
MPRINT(TMGETNCL):   oncl = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   else if (_N_ = 2) then do;
MPRINT(TMGETNCL):   jump = _ccc_ - occc;
MPRINT(TMGETNCL):   if (jump > 0) then do;
MPRINT(TMGETNCL):   maxjump = jump;
MPRINT(TMGETNCL):   jclus = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   if (_ccc_ > maxccc) then do;
MPRINT(TMGETNCL):   maxccc = _ccc_;
MPRINT(TMGETNCL):   maxclus = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   occc = _ccc_;
MPRINT(TMGETNCL):   oncl = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   else if (_N_ > 2) then do;
MPRINT(TMGETNCL):   prevjump = jump;
MPRINT(TMGETNCL):   jump = _ccc_ - occc;
MPRINT(TMGETNCL):   if ((prevjump > 0) & (jump < 0) & (loclclus < 0)) then do;
MPRINT(TMGETNCL):   loclclus = oncl;
MPRINT(TMGETNCL):   loclccc = occc;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   if (_ccc_ > maxccc) then do;
MPRINT(TMGETNCL):   maxccc = _ccc_;
MPRINT(TMGETNCL):   maxclus = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   if ((jump > 0) & (jump > maxjump)) then do;
MPRINT(TMGETNCL):   jclus = _ncl_;
MPRINT(TMGETNCL):   maxjump = jump;
MPRINT(TMGETNCL):   jccc = _ccc_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   occc = _ccc_;
MPRINT(TMGETNCL):   oncl = _ncl_;
MPRINT(TMGETNCL):   if ((loclclus > 0) & (jclus > 0)) then nclus = MIN(loclclus, jclus);
MPRINT(TMGETNCL):   else if (loclclus > 0) then nclus = loclclus;
MPRINT(TMGETNCL):   else if (jclus > 0) then nclus = jclus;
MPRINT(TMGETNCL):   else nclus = maxclus;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   run;
 
NOTE: 9개의 관측값을 데이터셋 WORK._CLUSTEMP1.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSTEMP은(는) 9개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETNCL):   ;
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select max(nclus) into: numClus from _clusTemp ;
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select count(*) into: nobs from _svdcolpro;
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMFAST):   proc fastclus data = _svdcolpro maxclusters = 6 noprint outstat = _fastclusstat ;
MPRINT(TMFAST):   var TextCluster3_SVD1 - TextCluster3_SVD44;
MPRINT(TMFAST):   ;
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 데이터셋 WORK._FASTCLUSSTAT은(는) 40개의 관측값과 47개의 변수를 가지고 있습니다.
NOTE: 프로시저 FASTCLUS 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select max(CLUSTER) into :numClus from _fastclusstat where upcase(_TYPE_)='SEED' ;
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMEMCLUS):   proc emclus data = _svdcolpro clusters = 6 seed=_fastclusstat outstat = EMWS5.TextCluster3_emoutstat out = _tmutildoc init = FASTCLUS eps = .1 print = NONE iter = 5 decvar = 0 ;
MPRINT(TMEMCLUS):   var TextCluster3_SVD1 - TextCluster3_SVD44;
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   run;
 
NOTE: The standard EM algorithm will be run.
NOTE: DIST is set to 0.1359857201
NOTE: EPS is set to 0.1
NOTE: INITSTD is set to 15.234961025
NOTE: ITER is set to 5
NOTE: MAXTIME is set to 2147483647
WARNING: The maximum number of 5 iterations in the EM algorithm has been reached. Parameter estimates may not be accurate.
WARNING: Some variances were estimated to be less than the minimum allowable variance. Parameter estimates may not be accurate.
NOTE: 500개의 관측값을 데이터셋 WORK._SVDCOLPRO.에서 읽었습니다.
NOTE: 40개의 관측값을 데이터셋 WORK._FASTCLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_EMOUTSTAT은(는) 13개의 관측값과 51개의 변수를 가지고 있습니다.
NOTE: 데이터셋 WORK._TMUTILDOC은(는) 500개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: 프로시저 EMCLUS 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.07 초
 
 
MPRINT(TMPRED):   * set the optional arguments;
MPRINT(TMPRED):   data EMWS5.TextCluster3_docs(compress=Y drop=_c1-_c6) _clusstat(keep=_c1-_c6) ;
MPRINT(TMPRED):   set _tmutildoc end=eof;
MPRINT(TMPRED):   * array for holding all probabilities;
MPRINT(TMPRED):   array _p prob1--prob6;
MPRINT(TMPRED):   array _c(6);
MPRINT(TMPRED):   retain _c 0;
MPRINT(TMPRED):   * get rid of working columns;
MPRINT(TMPRED):   drop _max_ _i _WARN_;
MPRINT(TMPRED):   _max_ = 0;
MPRINT(TMPRED):   do _i = 1 to 6;
MPRINT(TMPRED):   if _p(_i) > _max_ then do;
MPRINT(TMPRED):   _max_ = _p(_i);
MPRINT(TMPRED):   _CLUSTER_ = _i;
MPRINT(TMPRED):   end;
MPRINT(TMPRED):   end;
MPRINT(TMPRED):   if (_CLUSTER_ >= 1) and (_CLUSTER_ <= 6) then _c(_CLUSTER_) = _c(_CLUSTER_) + 1;
MPRINT(TMPRED):   else _CLUSTER_ = .;
MPRINT(TMPRED):   ;
MPRINT(TMPRED):   if eof then do;
MPRINT(TMPRED):   output _clusstat;
MPRINT(TMPRED):   output EMWS5.TextCluster3_docs;
MPRINT(TMPRED):   end;
MPRINT(TMPRED):   else output EMWS5.TextCluster3_docs;
MPRINT(TMPRED):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._TMUTILDOC.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_DOCS은(는) 500개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: 데이터셋 'EMWS5.TEXTCLUSTER3_DOCS'을(를) 압축해서 크기가 0.00%(으)로 줄었습니다.
      압축된 파일은 4페이지입니다. 압축되지 않은 파일은 4페이지가 필요합니다.
NOTE: 데이터셋 WORK._CLUSSTAT은(는) 1개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster3_docs;
MPRINT(TM_CLUSTER):   set EMWS5.TextCluster3_docs;
MPRINT(TM_CLUSTER):   rename prob1-prob6 = TextCluster3_prob1-TextCluster3_prob6;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_DOCS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_DOCS은(는) 500개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   data _clusstat;
MPRINT(TM_CLUSTER):   array c(6) _c1-_c6;
MPRINT(TM_CLUSTER):   set _clusstat;
MPRINT(TM_CLUSTER):   totalobs=0;
MPRINT(TM_CLUSTER):   do _CLUSTER_ = 1 to 6;
MPRINT(TM_CLUSTER):   Freq = c(_CLUSTER_);
MPRINT(TM_CLUSTER):   totalobs=totalobs+c(_CLUSTER_);
MPRINT(TM_CLUSTER):   output;
MPRINT(TM_CLUSTER):   end;
MPRINT(TM_CLUSTER):   call symput ('totNumDocs', totalobs);
MPRINT(TM_CLUSTER):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      451:154
NOTE: 1개의 관측값을 데이터셋 WORK._CLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSSTAT은(는) 6개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   data _clusstat;
MPRINT(TM_CLUSTER):   set _clusstat;
MPRINT(TM_CLUSTER):   Percent = Freq/ 500;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK._CLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSSTAT은(는) 6개의 관측값과 10개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   data _clustermean(rename=(TextCluster3_SVD1 - TextCluster3_SVD44 = _mean1-_mean44));
MPRINT(TM_CLUSTER):   set EMWS5.TextCluster3_emoutstat(keep=cluster _TYPE_ TextCluster3_SVD1 - TextCluster3_SVD44);
MPRINT(TM_CLUSTER):   if _TYPE_ = "MEAN";
MPRINT(TM_CLUSTER):   keep cluster TextCluster3_SVD1 - TextCluster3_SVD44 ;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 13개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_EMOUTSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSTERMEAN은(는) 6개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   proc sql;
MPRINT(TM_CLUSTER):   create table _meandocs(drop=cluster) as select a.*, b.* from EMWS5.TextCluster3_docs a left join _clustermean b on a._cluster_=b.cluster ;
NOTE: Table WORK._MEANDOCS created, with 500 rows and 96 columns.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_CLUSTER):   data _rmscalc;
MPRINT(TM_CLUSTER):   merge _meandocs(in=inhere) _clusstat;
MPRINT(TM_CLUSTER):   array _means(44) _mean1-_mean44;
MPRINT(TM_CLUSTER):   array _svds(44) TextCluster3_SVD1 - TextCluster3_SVD44;
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   error=0;
MPRINT(TM_CLUSTER):   do i = 1 to 44;
MPRINT(TM_CLUSTER):   error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
MPRINT(TM_CLUSTER):   end;
MPRINT(TM_CLUSTER):   drop i;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._MEANDOCS.에서 읽었습니다.
NOTE: 6개의 관측값을 데이터셋 WORK._CLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._RMSCALC은(는) 500개의 관측값과 106개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   proc summary data=_rmscalc nway;
MPRINT(TM_CLUSTER):   class _cluster_;
MPRINT(TM_CLUSTER):   var error;
MPRINT(TM_CLUSTER):   output out=_meanerr mean=meane sum=sume;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._RMSCALC.에서 읽었습니다.
NOTE: 데이터셋 WORK._MEANERR은(는) 6개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_CLUSTER):   data _rmsse;
MPRINT(TM_CLUSTER):   set _meanerr;
MPRINT(TM_CLUSTER):   if _freq_ gt 1 then do;
MPRINT(TM_CLUSTER):   _rmsstd_=sqrt(sume/((_freq_-1)*(44)));
MPRINT(TM_CLUSTER):   end;
MPRINT(TM_CLUSTER):   else do;
MPRINT(TM_CLUSTER):   _rmsstd_=0;
MPRINT(TM_CLUSTER):   end;
MPRINT(TM_CLUSTER):   keep _cluster_ _rmsstd_;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK._MEANERR.에서 읽었습니다.
NOTE: 데이터셋 WORK._RMSSE은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   proc sql;
MPRINT(TM_CLUSTER):   create table _clusstat2(drop=cluster) as select a.*,b.* from _clustermean a left join _rmsse b on a.cluster=b._cluster_;
NOTE: Table WORK._CLUSSTAT2 created, with 6 rows and 46 columns.
 
MPRINT(TM_CLUSTER):   create table EMWS5.TextCluster3_clusters as select a.*, b.freq, b.percent from _clusstat2(keep=_cluster_ _mean1-_mean44 _rmsstd_) a right join _clusstat b on a._cluster_=b._cluster_ where b.freq>0 ;
NOTE: Table EMWS5.TEXTCLUSTER3_CLUSTERS created, with 6 rows and 48 columns.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmterm1.source';
MPRINT(TM_CLUSTER):   proc sort data=EMWS5.TextFilter_terms out=_terms_;
MPRINT(TM_CLUSTER):   by key _ispar;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 입력 데이터셋이 이미 정렬되어 있습니다; 출력 데이터셋에 복사되었습니다.
NOTE: 2184개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TERMS_DATA.에서 읽었습니다.
      WHERE KEEP='Y';
NOTE: 1870개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TERM_STRINGS.에서 읽었습니다.
NOTE: 2184개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TERMS.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 2184개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_CLUSTER):   data _terms_;
MPRINT(TM_CLUSTER):   set _terms_;
MPRINT(TM_CLUSTER):   by key _ispar;
MPRINT(TM_CLUSTER):   if first.key then output;
MPRINT(TM_CLUSTER):   else;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 2184개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 1869개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   data _terms_;
MPRINT(TM_CLUSTER):   set _terms_;
MPRINT(TM_CLUSTER):   if _ispar='+' then Term=_ispar || ' ' || term;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 1869개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 1869개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = EMWS5.TextFilter_tmout threads out = _tmout_;
MPRINT(TMSORT):   by _termnum_;
MPRINT(TMSORT):   run;
 
NOTE: 3584개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._TMOUT_은(는) 3584개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   data _tmout_;
MPRINT(TM_CLUSTER):   merge _tmout_ (in=_A_) _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
MPRINT(TM_CLUSTER):   by _termnum_;
MPRINT(TM_CLUSTER):   if _A_;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 3584개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 1869개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TMOUT_은(는) 3584개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_CLUSTER):   data _docs_;
MPRINT(TM_CLUSTER):   set EMWS5.TextCluster3_docs (rename=(index=_document_) keep=index _cluster_);
MPRINT(TM_CLUSTER):   _SEGMNT_=_cluster_;
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_DOCS.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;
 
NOTE: 3584개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3584개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 2163개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;
 
NOTE: 3584개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3584개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 7개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.06 초
 
 
MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;
 
NOTE: 7개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;
 
NOTE: 2163개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 2163개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;
 
NOTE: 2163개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 157개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;
 
NOTE: 157개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 42개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 115개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.07 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 322 rows and 3 columns.
 
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;
 
NOTE: 322개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 115개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 6 ) 4 clus1 - clus6 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 6 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus6 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 3584 - 7;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 7 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 3584 - 553;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 553 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 3584 - 537;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 537 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 3584 - 378;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 378 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus5 = 0) or (clus5 < 0) then cdf5 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus5 ;
MPRINT(TMTERM1):   div = 3584 - 440;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf5 = CDF( 'binomial', clus5 , propor , 440 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf5 = 1;
MPRINT(TMTERM1):   else cdf5 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus6 = 0) or (clus6 < 0) then cdf6 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus6 ;
MPRINT(TMTERM1):   div = 3584 - 1669;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf6 = CDF( 'binomial', clus6 , propor , 1669 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf6 = 1;
MPRINT(TMTERM1):   else cdf6 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;
 
NOTE: 115개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 115개의 관측값과 14개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 6 ) cdf1 - cdf6 ;
MPRINT(TMTERM1):   array a_count ( 6 ) clus1 - clus6 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 6 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;
 
NOTE: 115개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 322개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;
 
NOTE: 322개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 322개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 322) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 322) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 322) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;
 
NOTE: 322개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TMSORT):   proc sort data = EMWS5.TextCluster3_clusters threads out = EMWS5.TextCluster3_clusters;
MPRINT(TMSORT):   by _cluster_;
MPRINT(TMSORT):   run;
 
NOTE: 6개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_CLUSTERS은(는) 6개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TMSORT):   proc sort data = _desc_ threads out = _desc_;
MPRINT(TMSORT):   by _cluster_;
MPRINT(TMSORT):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   data _desc_;
MPRINT(TM_CLUSTER):   merge EMWS5.TextCluster3_clusters _desc_;
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 6개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_CLUSTERS.에서 읽었습니다.
NOTE: 6개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 6개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _desc_ threads out = EMWS5.TextCluster3_clusters;
MPRINT(TMSORT):   by _cluster_;
MPRINT(TMSORT):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_CLUSTERS은(는) 6개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   filename temp;
NOTE: Fileref TEMP을(를) 삭제했습니다.
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   * add the info to EMINFO to forward on to other nodes ;
MPRINT(TRAIN):   data EMWS5.TextCluster3_EMINFO;
MPRINT(TRAIN):   length TARGET KEY $32 DATA $43;
MPRINT(TRAIN):   key="LastTMNode";
MPRINT(TRAIN):   data="TextCluster3";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTMNodeType";
MPRINT(TRAIN):   data="TextCluster";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTextCluster";
MPRINT(TRAIN):   data="TextCluster3";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="PRESCORECODE";
MPRINT(TRAIN):   data="TextCluster3";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   run;
 
NOTE: 변수 TARGET이(가) 초기화되지 않았습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_EMINFO은(는) 4개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select count(*) into :svdkeep from EMWS5.TextCluster3_svd_s where keep=1;
MPRINT(TRAIN):   select count(*) into :cluscnt from EMWS5.TextCluster3_clusters;
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRAIN):   data EMWS5.TextCluster3_tmconfig;
MPRINT(TRAIN):   set EMWS5.TextCluster3_tmconfig;
MPRINT(TRAIN):   clus_alg = "1.0";
MPRINT(TRAIN):   maxsvd = 100;
MPRINT(TRAIN):   svdkeep= 44;
MPRINT(TRAIN):   last_prescore = "TextTopic                                  ";
MPRINT(TRAIN):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_TMCONFIG.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_TMCONFIG은(는) 1개의 관측값과 33개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   length KEY $32 DELETE $1 UNAME $32 ROLE $32 LEVEL $10 ORDER $8 COMMENT $64 LOWERLIMIT 8 UPPERLIMIT 8;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_CLUSTER_");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("SEGMENT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("NOMINAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 1개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD1");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 1개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 2개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD2");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 2개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 3개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD3");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 3개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 4개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD4");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 4개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 5개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD5");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 5개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 6개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD6");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 7개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD7");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 7개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 8개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD8");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 8개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 9개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD9");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 9개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 10개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD10");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 10개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 11개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD11");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 11개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 12개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD12");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 12개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 13개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD13");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 13개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 14개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD14");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 14개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 15개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD15");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 15개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 16개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD16");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 16개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 17개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD17");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 17개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 18개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD18");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 18개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 19개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD19");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 19개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 20개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD20");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 20개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 21개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD21");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 21개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 22개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD22");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 22개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 23개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD23");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 23개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 24개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD24");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 24개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 25개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD25");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 25개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 26개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD26");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 26개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 27개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD27");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 27개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 28개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD28");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 28개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 29개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD29");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 29개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 30개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD30");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 30개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 31개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD31");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 31개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 32개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD32");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 32개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 33개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD33");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 33개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 34개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD34");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 34개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 35개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD35");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 35개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 36개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD36");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 36개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 37개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.00 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD37");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 37개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 38개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD38");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 38개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 39개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD39");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 39개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 40개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD40");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 40개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 41개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD41");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 41개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 42개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD42");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 42개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 43개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD43");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 43개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 44개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_SVD44");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 44개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 45개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_PROB1");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 45개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 46개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_PROB2");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 46개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 47개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_PROB3");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 47개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 48개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_PROB4");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 48개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 49개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_PROB5");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 49개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 50개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster3_PROB6");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 50개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 51개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename temp;
WARNING: 파일 이름 TEMP이(가) 논리적으로 할당되지 않았습니다.
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: TextCluster3;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
25638      *------------------------------------------------------------*;
25639      * End TRAIN: TextCluster3;
25640      *------------------------------------------------------------*;
 
25641      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
25642      * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
25643      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
25644      ;
MPRINT(EM_DIAGRAM):   ;
25645      ;
MPRINT(EM_DIAGRAM):   ;
25646      ;
MPRINT(EM_DIAGRAM):   ;
25647      ;
MPRINT(EM_DIAGRAM):   ;
25648      quit;
MPRINT(EM_DIAGRAM):   quit;
25649      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
25650      * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
25651      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
25652      /*; *"; *'; */
25653      ;
MPRINT(EM_DIAGRAM):   ;
25654      run;
MPRINT(EM_DIAGRAM):   run;
25655      quit;
MPRINT(EM_DIAGRAM):   quit;
25656      /* Reset EM Options */
25657      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
25658      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
25659      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
25660      proc sort data=WORK.EM_METACHANGE;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_METACHANGE;
25661      by key uname;
MPRINT(EM_DIAGRAM):   by key uname;
25662      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 51개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 51개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
25663      filename x "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\CDELTA_TRAIN.sas";
MPRINT(EM_DIAGRAM):    filename x "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\CDELTA_TRAIN.sas";
25664      data _null_;
MPRINT(EM_DIAGRAM):   data _null_;
25665      file x;
MPRINT(EM_DIAGRAM):   file x;
25666      put 'if upcase(NAME) = "TEXTCLUSTER3_CLUSTER_" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_CLUSTER_" then do;';
25667      put 'ROLE = "SEGMENT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "SEGMENT";';
25668      put 'LEVEL = "NOMINAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "NOMINAL";';
25669      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25670      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25671      put 'if upcase(NAME) = "TEXTCLUSTER3_PROB1" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_PROB1" then do;';
25672      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25673      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25674      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25675      put 'if upcase(NAME) = "TEXTCLUSTER3_PROB2" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_PROB2" then do;';
25676      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25677      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25678      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25679      put 'if upcase(NAME) = "TEXTCLUSTER3_PROB3" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_PROB3" then do;';
25680      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25681      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25682      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25683      put 'if upcase(NAME) = "TEXTCLUSTER3_PROB4" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_PROB4" then do;';
25684      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25685      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25686      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25687      put 'if upcase(NAME) = "TEXTCLUSTER3_PROB5" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_PROB5" then do;';
25688      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25689      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25690      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25691      put 'if upcase(NAME) = "TEXTCLUSTER3_PROB6" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_PROB6" then do;';
25692      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25693      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25694      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25695      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD1" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD1" then do;';
25696      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25697      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25698      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25699      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25700      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD10" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD10" then do;';
25701      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25702      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25703      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25704      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25705      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD11" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD11" then do;';
25706      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25707      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25708      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25709      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25710      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD12" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD12" then do;';
25711      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25712      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25713      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25714      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25715      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD13" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD13" then do;';
25716      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25717      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25718      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25719      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25720      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD14" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD14" then do;';
25721      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25722      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25723      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25724      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25725      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD15" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD15" then do;';
25726      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25727      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25728      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25729      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25730      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD16" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD16" then do;';
25731      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25732      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25733      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25734      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25735      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD17" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD17" then do;';
25736      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25737      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25738      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25739      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25740      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD18" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD18" then do;';
25741      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25742      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25743      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25744      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25745      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD19" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD19" then do;';
25746      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25747      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25748      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25749      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25750      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD2" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD2" then do;';
25751      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25752      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25753      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25754      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25755      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD20" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD20" then do;';
25756      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25757      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25758      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25759      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25760      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD21" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD21" then do;';
25761      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25762      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25763      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25764      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25765      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD22" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD22" then do;';
25766      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25767      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25768      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25769      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25770      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD23" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD23" then do;';
25771      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25772      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25773      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25774      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25775      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD24" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD24" then do;';
25776      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25777      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25778      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25779      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25780      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD25" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD25" then do;';
25781      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25782      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25783      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25784      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25785      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD26" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD26" then do;';
25786      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25787      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25788      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25789      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25790      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD27" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD27" then do;';
25791      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25792      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25793      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25794      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25795      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD28" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD28" then do;';
25796      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25797      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25798      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25799      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25800      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD29" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD29" then do;';
25801      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25802      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25803      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25804      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25805      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD3" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD3" then do;';
25806      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25807      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25808      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25809      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25810      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD30" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD30" then do;';
25811      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25812      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25813      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25814      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25815      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD31" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD31" then do;';
25816      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25817      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25818      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25819      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25820      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD32" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD32" then do;';
25821      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25822      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25823      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25824      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25825      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD33" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD33" then do;';
25826      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25827      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25828      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25829      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25830      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD34" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD34" then do;';
25831      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25832      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25833      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25834      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25835      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD35" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD35" then do;';
25836      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25837      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25838      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25839      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25840      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD36" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD36" then do;';
25841      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25842      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25843      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25844      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25845      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD37" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD37" then do;';
25846      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25847      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25848      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25849      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25850      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD38" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD38" then do;';
25851      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25852      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25853      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25854      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25855      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD39" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD39" then do;';
25856      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25857      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25858      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25859      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25860      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD4" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD4" then do;';
25861      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25862      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25863      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25864      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25865      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD40" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD40" then do;';
25866      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25867      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25868      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25869      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25870      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD41" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD41" then do;';
25871      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25872      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25873      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25874      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25875      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD42" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD42" then do;';
25876      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25877      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25878      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25879      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25880      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD43" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD43" then do;';
25881      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25882      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25883      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25884      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25885      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD44" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD44" then do;';
25886      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25887      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25888      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25889      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25890      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD5" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD5" then do;';
25891      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25892      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25893      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25894      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25895      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD6" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD6" then do;';
25896      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25897      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25898      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25899      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25900      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD7" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD7" then do;';
25901      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25902      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25903      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25904      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25905      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD8" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD8" then do;';
25906      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25907      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25908      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25909      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25910      put 'if upcase(NAME) = "TEXTCLUSTER3_SVD9" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER3_SVD9" then do;';
25911      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25912      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25913      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25914      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 파일 X:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,파일 크기 (바이트)=0,
      마지막 수정일=2018년 11월 17일 17시43분32초,
      생성 시간=2018년 11월 17일 17시42분52초
 
NOTE: 248개의 레코드를 파일 X에 기록했습니다.
      최소 레코드 길이는 4입니다.
      최대 레코드 길이는 50입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
25915      filename x;
MPRINT(EM_DIAGRAM):   filename x;
NOTE: Fileref X을(를) 삭제했습니다.
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 17일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "17시43분33초" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 스코어 로그";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* 스코어 로그
날짜:                2018년 11월 17일
시간:                17시43분33초
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O2D5H045 "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O2D5H045 new;
MPRINT(EM_DIAGRAM):   run;
26017      %let EMEXCEPTIONSTRING=;
26018      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
26019      * SCORE: TextCluster3;
MPRINT(EM_DIAGRAM):   * SCORE: TextCluster3;
26020      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
26021      %let EM_ACTION = SCORE;
26022      %let syscc = 0;
26023      %macro main();
26024
26025         %if %upcase(&EM_ACTION) eq CREATE %then %do;
26026            filename temp catalog 'sashelp.emtxtext.cluster_create.source';
26027            %include temp;
26028            %create();
26029         %end;
26030         %if %upcase(&EM_ACTION) eq TRAIN %then %do;
26031            filename temp catalog 'sashelp.emtxtext.cluster_train.source';
26032            %include temp;
26033            %train();
26034         %end;
26035         %if %upcase(&EM_ACTION) eq REPORT %then %do;
26036            filename temp catalog 'sashelp.emtxtext.cluster_report.source';
26037            %include temp;
26038            %report();
26039         %end;
26040         %if %upcase(&EM_ACTION) eq SCORE %then %do;
26041            filename temp catalog 'sashelp.emtxtext.cluster_score.source';
26042            %include temp;
26043            %score();
26044         %end;
26045      %mend main;
26046
26047      %main();
MPRINT(EM_DIAGRAM):
MPRINT(MAIN):   filename temp catalog 'sashelp.emtxtext.cluster_score.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.CLUSTER_SCORE.SOURCE입니다.
26048     +%macro tmc_score(import_ds=,configdata=,export_ds=,term_ds=,export_out=,clusters_ds=,svdu=,svds=,
26049     +    import_out=,em_outstat=,prefixstring=,ocluster=,ndescterms=,ftmout=,fterms=,hier=);
26050     +  %if &import_ds ne %then %do;
26052     +    %let syscc=0;
26054     +    %tmc_doc_score(import=&import_ds,export=&export_ds,emoutstat=&em_outstat,
26055     +                termds=&term_ds,clusters=&clusters_ds,configds=&configdata,
26056     +                _scrout=&import_out, svd_u=&svdu, svd_s=&svds, prefix=&prefixstring,
26057     +                outclusters=&ocluster, descterms=&ndescterms, filterterms=&fterms,
26058     +                filtertmout=&ftmout, hierds=&hier);
26060     +  %end;
26062     +%mend tmc_score;
26063     +%macro score();
26065     +    %global last_parse_node last_filter_node last_prescore_node server_err
26066     +      parsevar EM_SASMSG ;
26067     +    %let syscc=0;
26068     +    %if ^%symexist(tm_debug) %then %let tm_debug=0;
26069     +    /*use saved version of em_info in case macro is not populated*/
26070     +    %em_getname(key=last_tm_nodes, type=data);
26072     +    filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
26073     +    %include temp;
26074     +    %tm_get_last_filter(eminfo=&em_user_last_tm_nodes,em_lib=&em_lib,
26075     +                        em_variableset=&em_data_variableset);
26076     +    %if &EMEXCEPTIONSTRING ne %then %goto end_cluster_score;
26077     +    %let lastparsenode=&last_parse_node;
26078     +    %let lastfilternode=&last_filter_node;
26079     +    %let lastprescore=&last_prescore_node;
26080     +    %let filt_node=;
26082     +   %em_getname(key=terms, type=data);
26083     +   %em_getname(key=docs, type=data);
26084     +   %em_getname(key=clusters, type=data);
26085     +   %em_getname(key=svd_u, type=data);
26086     +   %em_getname(key=svd_s, type=data);
26087     +   %em_getname(key=emoutstat, type=data);
26088     +   %em_getname(key=tmconfig, type=data);
26090     +   %em_getname(key=tmout, type=data);
26091     +   %em_getname(key=validout, type=data);
26092     +   %em_getname(key=testout, type=data);
26093     +   %em_getname(key=scoreout, type=data);
26094     +   %em_getname(key=PRESCORECODE, type=file, extension=sas);
26095     +   %let systmutil=;
26097     +    filename temp catalog 'sashelp.emtxtext.tm_data2code.source';
26098     +    %include temp;
26099     +    filename temp catalog 'sashelp.emtext.tmemclus.source';
26100     +    %include temp;
26101     +    filename temp catalog 'sashelp.emtext.tmpred.source';
26102     +    %include temp;
26103     +    filename temp catalog 'sashelp.emtext.tmsort.source';
26104     +    %include temp;
26105     +    filename temp catalog 'sashelp.emtxtext.tmc_doc_score.source';
26106     +    %include temp;
26107     +    filename temp catalog 'sashelp.emtext.tmsvd.source';
26108     +    %include temp;
26109     +    filename temp catalog 'sashelp.emtext.tmfast.source';
26110     +    %include temp;
26112     +   %let EM_PUBLISHCODE = PUBLISH;
26113     +   %let EM_SCORECODEFORMAT = DATASTEP;
26114     +   %let overwrite_pre = ;
26116     +   %let lastprescore=%trim(%left(&lastprescore));
26118     +   /* Create indexed term table for writing out score code */
26119     +   proc sql noprint;
26120     +       select count(*) into :svdkeep
26121     +       from &em_user_svd_s
26122     +       where keep=1;
26123     +   create table _clusterms as
26124     +      select key, term, role, keep, freq, numdocs, parent, _ispar, weight from &em_user_terms;
26126     +   data _filter_tmout;
26127     +      set &EM_LIB..&lastfilternode._tmout;
26128     +   run;
26130     +   %tmc_score(import_ds=&em_import_data,export_ds=&em_export_train,
26131     +              import_out=_filter_tmout,
26132     +              export_out=&EM_export_transaction,
26133     +              term_ds=_clusterms,
26134     +              clusters_ds=&em_user_clusters,
26135     +              svdu=&em_user_svd_u,
26136     +              svds=&em_user_svd_s,
26137     +              em_outstat=&em_user_emoutstat,
26138     +              configdata=&em_user_tmconfig,
26139     +              prefixstring=&EM_NODEID,
26140     +              ocluster=&em_user_clusters,
26141     +              ndescterms=&em_property_ndescterms,
26142     +              fterms=&EM_LIB..&lastfilternode._terms,
26143     +              ftmout=&EM_LIB..&lastfilternode._tmout,
26144     +              hier=&em_user_hierds);
26146     +   %tmc_score(import_ds=&em_import_validate,export_ds=&em_export_validate,
26147     +              export_out=&EM_USER_validout,
26148     +              import_out=&EM_LIB..&lastfilternode._validout,
26149     +              term_ds=_clusterms,
26150     +              clusters_ds=&em_user_clusters,
26151     +              svdu=&em_user_svd_u,
26152     +              svds=&em_user_svd_s,
26153     +              em_outstat=&em_user_emoutstat,
26154     +              configdata=&em_user_tmconfig,
26155     +              prefixstring=&EM_NODEID);
26156     +   %tmc_score(import_ds=&em_import_test,export_ds=&em_export_test,
26157     +              export_out=&EM_USER_testout,
26158     +              import_out=&EM_LIB..&lastfilternode._testout,
26159     +              term_ds=_clusterms,
26160     +              clusters_ds=&em_user_clusters,
26161     +              svdu=&em_user_svd_u,
26162     +              svds=&em_user_svd_s,
26163     +              em_outstat=&em_user_emoutstat,
26164     +              configdata=&em_user_tmconfig,
26165     +              prefixstring=&EM_NODEID);
26167     +   %if &syscc>4 %then %do;
26168     +       %let syscc=0;
26169     +       %goto end_cluster_score;
26170     +   %end;
26172     +   * path of the diagram ;
26173     +   %let emwspath = ;
26174     +   data _null_;
26175     +      call symput("emwspath", strip(pathname("&EM_LIB")));
26176     +   run;
26178     +   filename pre "&EM_USER_PRESCORECODE";
26179     +   data _null_;
26180     +       file pre;
26181     +       put 'filename temp catalog "sashelp.emtext.tmemclus.source";';
26182     +       put '%include temp;';
26183     +       put 'filename temp catalog "sashelp.emtext.tmpred.source";';
26184     +       put '%include temp;';
26185     +       put 'filename temp catalog "sashelp.emtxtext.tmc_doc_score.source";';
26186     +       put '%include temp;';
26187     +       put 'filename temp catalog "sashelp.emtext.tmsort.source";';
26188     +       put '%include temp;';
26189     +       put 'filename temp catalog "sashelp.emtext.tmsvd.source";';
26190     +       put '%include temp;';
26191     +       put 'filename temp catalog "sashelp.emtext.tmfast.source";';
26192     +       put '%include temp;';
26193     +       put 'filename temp;';
26194     +   run;
26197     +   /* We need to use last prescore */
26198     +   %if &lastprescore ne %then %do;
26199     +      %let tmprescoreFile = %bquote(&emwspath)&em_dsep&lastprescore&em_dsep.PRESCORECODE.sas;
26200     +      filename tmpre "&tmprescoreFile";
26201     +      %em_copyfile(infref=tmpre, outfref=pre, append=Y);
26202     +      filename tmpre;
26203     +   %end;
26205     +   data _codeclusters;
26206     +        set &em_user_clusters (drop=clus_desc);
26207     +   run;
26209     +     %if not %symexist(em_term_loc) %then %do;
26210     +       %let em_term_loc = %bquote(%sysfunc(pathname(&EM_LIB)));
26211     +         libname termloc "&em_term_loc";
26213     +      %let scored_terms = termloc.&lastfilternode._filtterms;
26214     +       %let scored_clust = termloc.&EM_NODEID._clusters;
26215     +       %let scored_config = termloc.&EM_NODEID._tmconfig;
26216     +       %let scored_svd_u = termloc.&EM_NODEID._svd_u;
26217     +       %let scored_svd_s= termloc.&EM_NODEID._svd_s;
26219     +       %if &em_property_algorithm=1.0 %then  %do;
26220     +          %let scored_emoutstat= termloc.&EM_NODEID._emoutstat;
26221     +       %end;
26223     +   %end;
26224     +   %else %do; /* Write out data sets to external directory */
26225     +       libname termloc "&em_term_loc";
26226     +        %if %sysfunc(libref(termloc)) ne 0 %then %do;
26227     +           %let  EMEXCEPTIONSTRING = EMTOOL.EMTERMLOC,&em_term_loc;
26228     +           %goto end_cluster_score;
26229     +       %end;
26231     +      /* copy datasets to use for prescore code*/
26232     +       data termloc.&EM_LIB._&EM_NODEID._CLUSTERS;
26233     +         set _codeclusters;
26234     +       run;
26236     +       data termloc.&EM_LIB._&EM_NODEID._svd_u;
26237     +         set &em_user_svd_u;
26238     +       run;
26240     +       data termloc.&EM_LIB._&EM_NODEID._svd_s;
26241     +         set &em_user_svd_s;
26242     +       run;
26244     +       data termloc.&EM_LIB._&EM_NODEID._tmconfig;
26245     +         set &em_user_tmconfig;
26246     +       run;
26248     +       %let scored_terms = termloc.&EM_LIB._&lastfilternode._filtterms;
26249     +       %let scored_clust = termloc.&EM_LIB._&EM_NODEID._CLUSTERS;
26250     +       %let scored_config = termloc.&EM_LIB._&EM_NODEID._tmconfig;
26251     +       %let scored_svd_u = termloc.&EM_LIB._&EM_NODEID._svd_u;
26252     +       %let scored_svd_s= termloc.&EM_LIB._&EM_NODEID._svd_s;
26254     +       %if &em_property_algorithm=1.0 %then  %do;
26255     +         data termloc.&EM_LIB._&EM_NODEID._emoutstat;
26256     +         set &em_user_emoutstat;
26257     +         run;
26258     +           %let scored_emoutstat= termloc.&EM_LIB._&EM_NODEID._emoutstat;
26259     +       %end;
26260     +   %end;
26264     +   %let _score_append=;
26266     +   * Now save code, if necessary, for search phrase;
26267     +   filename _tmscore "&EM_FILE_EMPUBLISHSCORECODE";
26268     +   %if &em_property_algorithm=1.0 %then %do;
26269     +   data _NULL_;
26270     +     file _tmscore;
26271     +     length string $200;
26272     +     string ='%tmc_doc_score(import='||'&em_score_output'||",export=work._newexport,";
26273     +     put string;
26274     +     string="      termds=&scored_terms, configds=&scored_config,";
26275     +     put string;
26276     +     string= "      clusters=&scored_clust, emoutstat=&scored_emoutstat, ";
26277     +     put string;
26278     +     string = "      _scrout=work.&lastfilternode._out, svd_u=&scored_svd_u, svd_s=&scored_svd_s, prefix=&em_nodeid);";
26279     +     put string;
26280     +     string='data &em_score_output; set work._newexport;';
26281     +     put string;
26282     +    run;
26283     +    %end;
26284     +    %else %do;
26285     +    data _NULL_;
26286     +     file _tmscore;
26287     +     string= '%'||"tmc_doc_score(import="||'&em_score_output'||",export=work._newexport,";
26288     +     put string;
26289     +     put "      termds=&scored_terms,configds=&scored_config,";
26290     +     put "      clusters=&scored_clust, ";
26291     +     put "      _scrout=work.&lastfilternode._out, svd_u=&scored_svd_u, svd_s=&scored_svd_s, prefix=&em_nodeid);";
26292     +     put 'data &em_score_output; set work._newexport;';
26293     +    run;
26294     +    %end;
26295     +   filename _tmscore;
26297     +%end_cluster_score:
26298     +    filename temp;
26299     +    %if &tm_debug =0 %then %do;
26300     +    proc sql noprint;
26301     +        drop table _clusterms;
26302     +        drop table _filter_tmout;
26303     +        drop table _codeclusters;
26304     +    quit;
26305     +    %end;
26307     +%mend score;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):  ;
MPRINT(SCORE):   filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_GET_LAST_FILTER.SOURCE입니다.
26309     +/* ****************************************************************
26310     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
26311     + *
26312     + * Name:             tm_get_last_filter.sas
26313     + * Product:          SAS Text Miner
26314     + * Language:         Sas
26315     + * Script:
26316     + *
26317     + * Usage:
26318     + *
26319     + * Purpose:  macro to get the last filter node and the last parse node in the
26320     + *   diagram that corresponds to the current parse variable.  If there is no filter
26321     + *   node, the filter node is set to the last parse node.
26322     + *
26323     + *
26324     + *
26325     + * History:
26326     + * 14Aug09 Initial Coding
26327     + *
26328     + * Notes:
26329     + *    Returns an error in the following cases:
26330     + *      1. There is no preceding parse node.
26331     + *      2. There is no parse node with the current parse variable.
26332     + *
26333     + * Last Modified By:
26334     + * Last Modified On: Wed Sep 23 15:35:04 2009
26335     + *
26336     + * End
26337     + * ************************************************************** */
26338     +%macro tm_get_last_filter(eminfo=,em_lib=, em_variableset=);
26339     +   %let last_parse_node=;
26340     +   %let last_filter_node=;
26341     +   %let last_prescore_node=;
26342     +   %let server_err=;
26343     +   %let EMEXCEPTIONSTRING=;
26344     +   %let syscc=0;
26345     +
26346     +    /* verify that setinit for SAS Text Miner is currently active */
26347     +    %if %sysfunc(sysprod(PRODNUM107)) ne 1 %then %do;
26348     +       %let EMEXCEPTIONSTRING = EMTOOL.NOTMLICENSE;
26349     +        %goto end_macro;
26350     +        %end;
26351     +
26352     +
26353     +    * find last filter or text parse node if no filter node. ;
26354     +   %if %sysfunc(exist(&eminfo)) %then %do;
26355     +      proc sql noprint;
26356     +      select data into :last_parse_node from &eminfo where key="LastTextParsing";
26357     +         select data into :last_filter_node from &eminfo where key="LastTextFilter";
26358     +         select data into :last_prescore_node from &eminfo where kupcase(key)="PRESCORECODE";
26359     +      quit;
26360     +
26361     +   %end;
26362     +
26363     +   %if &last_parse_node= %then %do;
26364     +      %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGNODE;
26365     +      %goto end_macro;
26366     +      %end;
26367     +
26368     +   %else %if &last_filter_node= %then %let last_filter_node = %ktrim(&last_parse_node);
26369     +   %else %let last_filter_node = %ktrim(&last_filter_node);
26370     +   %let last_parse_node = %ktrim(&last_parse_node);
26371     +
26372     +   * Check to make sure parse variable is present and still exists;
26373     +   %let parsevar = ;
26374     +   proc sql noprint;
26375     +    select parsevar into :parsevar
26376     +    from &em_lib..&last_filter_node._tmconfig;
26377     +    quit;
26378     +
26379     +    *check for dropped parsevar on input dataset;
26380     +       %let parsevarOK= ;
26381     +       %let parsevarN=%kupcase(%ktrim(&parsevar));
26382     +       data _null_;
26383     +         set &em_variableset(where=(kupcase(NAME)="&parsevarN" and USE in('Y' 'D')));
26384     +         if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
26385     +         run;
26386     +       %if(&parsevarOK eq ) %then %do;
26387     +          %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGVAR;
26388     +          %goto end_macro;
26389     +          %end;
26390     +%end_macro:
26391     +
26392     +%mend tm_get_last_filter;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_GET_LAST_FILTER):   * find last filter or text parse node if no filter node. ;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select data into :last_parse_node from EMWS5.TextCluster3_last_tm_nodes where key="LastTextParsing";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_filter_node from EMWS5.TextCluster3_last_tm_nodes where key="LastTextFilter";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_prescore_node from EMWS5.TextCluster3_last_tm_nodes where kupcase(key)="PRESCORECODE";
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_GET_LAST_FILTER):   * Check to make sure parse variable is present and still exists;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select parsevar into :parsevar from EMWS5.TextFilter_tmconfig;
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GET_LAST_FILTER):   *check for dropped parsevar on input dataset;
MPRINT(TM_GET_LAST_FILTER):   data _null_;
MPRINT(TM_GET_LAST_FILTER):   set EMWS5.TextCluster3_VariableSet(where=(kupcase(NAME)="REVIEW" and USE in('Y' 'D')));
MPRINT(TM_GET_LAST_FILTER):   if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
MPRINT(TM_GET_LAST_FILTER):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_VARIABLESET.에서 읽었습니다.
      WHERE (KUPCASE(NAME)='REVIEW') and USE in ('D', 'Y');
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):   filename temp catalog 'sashelp.emtxtext.tm_data2code.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_DATA2CODE.SOURCE입니다.
26393     +/* ****************************************************************
26394     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
26395     + *
26396     + * Name:             tm_data2code.sas
26397     + * Product:          SAS Text Miner
26398     + * Language:         Sas
26399     + * Script:
26400     + *
26401     + * Usage:  %tm_data2code(data=, outdata=WORK.DATA);
26402     + *
26403     + * Purpose:          To do a data2code (like %em_data2code()) but allow the input data
26404     + *  to be view or data.
26405     + *
26406     + *    PARAMETERS:
26407     + *        DATA        = data set
26408     + *        OUTDATA     = out data set
26409     + *        OUTFILE     = file where to saved the code
26410     + *        APPEND      = append (Y/N)
26411     + * History:
26412     + * 11Jun09 Initial Coding
26413     + *
26414     + * Notes:
26415     + *
26416     + * Last Modified By:
26417     + * Last Modified On: Thu Jul 23 11:00:06 2009
26418     + *
26419     + * End
26420     + * ************************************************************** */
26421     +%macro tm_data2code(data=, outdata=WORK.DATA, outfile=, append=N);
26422     +%if &data eq %then %do;
26423     +   %put ERROR: Data set not defined;
26424     +   %end;
26425     +%else %do;
26426     +   %if (^%sysfunc(exist(&data)) and ^%sysfunc(exist(&data, view))) %then %do;
26427     +       %put ERROR: Data set does not exist;
26428     +       %end;
26429     +   %else %do;
26430     +      %global em_data em_outdata em_codefile em_append;
26431     +      %let em_data=&data;
26432     +      %let em_outdata=&outdata;
26433     +      %let em_codefile=&outfile;
26434     +      %let em_append=&append;
26435     +      proc display c=sashelp.emutil.data2code.scl; run;
26436     +      %end;
26437     +   %end;
26438     +%mend;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmemclus.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMEMCLUS.SOURCE입니다.
26439     +
26440     + /*
26441     +
26442     +  Macro:   tmemclus.sas
26443     +  Purpose: Call proc emclus with given defaults and parameters.
26444     +  Syntax:  %tmemclus(data=, role=, clusters=, seed=,
26445     +                   outstat=, out=, vars=, cov=, iter=, secclus=,
26446     +                   seciter=, min=, method=, eps=, init=, print=,
26447     +                   p=, outliers=, decvar=, initstd=, dist=,
26448     +                   secstd=, nobs=, threads=);
26449     +  Required Parameters:  data=      The input data set.
26450     +                        role=      Train or score
26451     +                        clusters=  The number of primary clusters
26452     +
26453     +  Optional Parameters:  vars=      Variables to be used
26454     +                   cov=       Type of covariance matrix
26455     +                   iter=      Number of EM iterations
26456     +                   secclus    Number of secondary clusters
26457     +                   seciter    Number of k-means iterations
26458     +                   min=       Minimum number of obs in a cluster
26459     +                   method=    Standard or scaled
26460     +                   eps=       Stopping tolerance
26461     +                   init=      Random, Fastclus, or Emclus
26462     +                   print=     All, last, or none
26463     +                   p=
26464     +                   outliers=  Keep, cluster, or ignore
26465     +                   outstat=   Name of OUTSTAT data set
26466     +                   out=       Name of OUT data set
26467     +                   seed=      Name of SEED data set
26468     +                   decvar=    Proportion to decrease variances
26469     +                   initstd=   Initial standard deviation
26470     +                   dist=      Minimum distance between clusters
26471     +                   secstd=    Secondary cluster max std dev.
26472     +                   nobs=      Number of obs read in each iteration
26473     +  History:
26474     +  2001/01/16 - Bill Wheeler - Initial Coding.
26475     +  2001/11/29 - Bill Wheeler - Updated for version 8 or 9
26476     +*/
26477     +%MACRO tmemclus(data=, role=, clusters=, seed=,
26478     + outstat=, out=, vars=, cov=, iter=, secclus=,
26479     + seciter=, min=, method=, eps=, init=, print=,
26480     + p=, outliers=, decvar=, initstd=, dist=, secstd=, nobs=, threads=);
26481     +
26482     + %local saveout saveseed op1 op2 op3 op4;
26483     +
26484     + %LET saveout = &out;
26485     + %LET saveseed = &outstat;
26486     +
26487     + /* defaults */
26488     + %if &role= %then %let role = TRAIN;
26489     + %if &seed ne %then %let seed = seed=&seed;
26490     + %if &vars= %then %let var = ;
26491     + %else %let var = var &vars;
26492     + %if &cov ne %then %let cov = cov = &cov;
26493     + %if &iter ne %then %let iter = iter = &iter;
26494     + %if &init ne %then %let init = init = &init;
26495     + %if &eps ne  %then %let eps = eps = &eps;
26496     + %if &min ne %then %let min = min = &min;
26497     + %if &seciter ne %then %let seciter = seciter = &seciter;
26498     + %if &print ne %then %let print = print = &print;
26499     + %if &p ne %then %let p = p = &p;
26500     + %if &outliers ne %then %let outliers = outliers = &outliers;
26501     + %if &method ne %then %let method = method = &method;
26502     + %if &decvar ne %then %let decvar = decvar = &decvar;
26503     + %if &outstat ne %then %let outstat = outstat = &outstat;
26504     + %if &out ne %then %let out = out = &out;
26505     + %if (&threads >= 0)  %then %let threads = threads = &threads;
26506     + %else %let threads = ;
26507     +
26508     + %LET op1 = ;
26509     + %LET op2 = ;
26510     + %LET op3 = ;
26511     + %LET op4 = ;
26512     + %if ^(&initstd=) %then %let op1 = %str(initstd = &initstd);
26513     + %if ^(&dist=) %then %let op2 = %str(dist = &dist);
26514     + %if ^(&secstd=) %then %let op3 = %str(secstd = &secstd);
26515     + %if ^(&nobs=) %then %let op4 = %str(nobs = &nobs);
26516     +
26517     +
26518     + %IF &SYSVER < 9 %THEN %DO;
26519     +    %LET cov = ;
26520     +    %LET decvar = ;
26521     +    %LET outliers = ;
26522     +    %LET out = ;
26523     + %END;
26524     +
26525     +
26526     + %if %upcase(&role) = TRAIN %then
26527     + %do;
26528     +   proc emclus data = &data
26529     +   clusters = &clusters
26530     +   &seed
26531     +   &outstat
26532     +   &out
26533     +   &init
26534     +   &eps
26535     +   &method
26536     +   &secclus
26537     +   &min
26538     +   &print
26539     +   &outliers
26540     +   &iter
26541     +   &op1 &op2
26542     +   &op3 &op4
26543     +   &decvar
26544     +   &cov
26545     +   &threads
26546     +   ;
26547     +   &var;
26548     + %end;
26549     + %else
26550     +  %do;
26551     +    proc emclus data = &data
26552     +    role = score
26553     +    clusters = &clusters
26554     +    &seed
26555     +    &out
26556     +    &cov
26557     +    ;
26558     +    &var;
26559     +  %end;
26560     +
26561     + %IF &SYSVER < 9 and &saveout ^= %THEN %DO;
26562     +   proc emclus data = &data
26563     +   role = score
26564     +   clusters = &clusters
26565     +   seed = &saveseed
26566     +   &saveout
26567     +   ;
26568     +   &var;
26569     + %END;
26570     +
26571     +
26572     +%MEND tmemclus;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmpred.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMPRED.SOURCE입니다.
26573     +
26574     +/*
26575     +  Macro: tmpred(inds,outds,clusters,type=,ignore=,freqDS=)
26576     +
26577     +  Description: This macro will take output from
26578     +     emclus and generate predicted
26579     +      predicted clusters.
26580     +
26581     +  Parms: inds - input data set, produced by emclus.
26582     +   outds - data set with clusters created by this macro.
26583     +   clusters - number of clusters that should be on this data set
26584     +   type - valid values: 'max' or 'prob'.  Max will just take the
26585     +      cluster with the highest probability as the predicted cluster.
26586     +      In the case of a tie the first cluster with that value will
26587     +       selected.
26588     +      Prob will attempt to select multiple clusters based on
26589     +      how many clusters were requested.  That is if 3 clusters
26590     +      were requested, any cluster with prob>1/3 will be selected
26591     +      as the predicted cluster. THIS OPTION IS UNTESTED.
26592     +*/
26593     +
26594     +%macro tmpred(inds,outds,clusters,type=, ignore=0, freqDS=, compress=1);
26595     +
26596     +  %local _str newfreqDS _flag;
26597     +
26598     +  * set the optional arguments;
26599     +  %if &type= %then %let type=max;
26600     +  %if &ignore = 1 %then %let
26601     +    _str = if _CLUSTER_ = &clusters then _CLUSTER_ = .;
26602     +  %else %let _str = ;
26603     +  %if %str(&freqDS) ^= %str() %then %do;
26604     +   %let newfreqDS = &freqDS(keep=_c1-_c&clusters);
26605     +   %let _flag = 1;
26606     +  %end;
26607     +  %else %let _flag = 0;
26608     +
26609     +  %if &compress = 1 %then %let compress = compress=Y;
26610     +  %else %let compress = ;
26611     +
26612     +  data &outds(&compress drop=_c1-_c&clusters)
26613     +    %if &_flag = 1 %then %do;
26614     +    &newfreqDS
26615     +    %end;
26616     +    ;
26617     +    set &inds end=eof;
26618     +   * array for holding all probabilities;
26619     +    array _p prob1--prob&clusters;
26620     +    array _c(&clusters);
26621     +    retain _c 0;
26622     +   * get rid of working columns;
26623     +    drop _max_ _i /*prob1--prob&clusters*/ _WARN_;
26624     +    /* keep the largest probability and the cluster */
26625     +    _max_ = 0;
26626     +    do _i = 1 to &clusters;
26627     +      if _p(_i) > _max_ then do;
26628     +        _max_ = _p(_i);
26629     +        _CLUSTER_ = _i;
26630     +      end;
26631     +    end;
26632     +    if (_CLUSTER_ >= 1) and (_CLUSTER_ <= &clusters) then
26633     +      _c(_CLUSTER_) = _c(_CLUSTER_) + 1;
26634     +    else _CLUSTER_ = .;
26635     +    &_str;
26636     +    %if &_flag = 1 %then %do;
26637     +      if eof then do;
26638     +        output &freqDS;
26639     +                output &outDS;
26640     +          end;
26641     +          else output &outDS;
26642     +        %end;
26643     +
26644     +    run;
26645     +%mend tmpred;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmsort.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMSORT.SOURCE입니다.
26646     + /*
26647     +PROC SORT macro
26648     +
26649     +%tmsort(data=, out=, by=);
26650     +
26651     +data=      - name of input data set (outtree data set from PROC CLUSTER)
26652     +out=       - name of the output data set
26653     +by=        - by statement
26654     +options=   - proc options
26655     +*/
26656     +
26657     +%macro tmsort(data=, out=, by=, options=, threads=THREADS);
26658     +  %if %BQUOTE(&out) ^= %then %let out = out =  &out;
26659     +  %if &SYSVER < 9 %then %let threads = ;
26660     +
26661     +  proc sort data = %STR(&data) &threads &options
26662     +    &out;
26663     +    by &by;
26664     +  run;
26665     +
26666     +%mend tmsort;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtxtext.tmc_doc_score.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TMC_DOC_SCORE.SOURCE입니다.
26667     +/*****************************************************************************
26668     +*
26669     +* tmc_doc_score
26670     +*
26671     +*  import  =  the doc data set of _document_ ids's as input
26672     +*  export = the new doc dataset with the svd dimensions and cluster results as output
26673     +*  termds = the terms table as input
26674     +*  clusters = input dataset of clusters from train
26675     +*  emoutstat = input dataset of seeds from training
26676     +*  _scrout = input OUT data set to be scored, may be trimmed based on conent of termds
26677     +*  svd_u = input singular vectors
26678     +
26679     +
26680     +*  svd_s = input singular values
26681     +*  prefxi = variable prefix string identifier.
26682     +*
26683     +**************************************************************************************/
26684     +
26685     +%macro tmc_doc_score(import=,export=,termds=,export_out=,clusters=,emoutstat=,
26686     +                 _scrout=,svd_u=,svd_s=,configds=,prefix=, outclusters=,hierds=,
26687     +                filterterms=,filtertmout=, descterms=);
26688     +
26689     +   %if ^%symexist(tm_debug) %then %let tm_debug=0;
26690     +
26691     +    proc sql noprint;
26692     +        select cellwgt into: cellwgt
26693     +            from &configds;
26694     +        select clus_alg into: algorithm
26695     +            from &configds;
26696     +        select parseVar into :textvar
26697     +            from &configds;
26698     +        select count(*) into :nclus
26699     +            from &clusters;
26700     +        select count(*) into :svdkeep
26701     +            from &svd_s
26702     +            where keep=1;
26703     +    quit;
26704     +
26705     +    %let svdkeep=%left(&svdkeep);
26706     +    %let nclus=%left(&nclus);
26707     +    %let algorithm=%left(&algorithm);
26708     +    %Let cellwgt=%left(&cellwgt);
26709     +    data _import_ds;
26710     +        set &import;
26711     +    run;
26712     +
26713     +
26714     +    %tmsort(data=&termds(where=(keep='Y')), out=_terms(keep= KEY PARENT),
26715     +            by=KEY);
26716     +    %tmsort(data=&_scrout, out=&_scrout, by=_termnum_);
26717     +
26718     +    data _svdm1;
26719     +        merge _terms (where=(PARENT ne _termnum_) in=_b_ keep=KEY PARENT rename=(KEY=_TERMNUM_))
26720     +              &_scrout (in = _A_ rename=(_COUNT_=COUNT));
26721     +        by _termnum_;
26722     +        if _B_;
26723     +        if (_A_ and _B_ and (PARENT ne .))
26724     +          then _TERMNUM_ = PARENT;
26725     +
26726     +        keep _TERMNUM_ _DOCUMENT_ COUNT;
26727     +        if (_DOCUMENT_=.) or (COUNT=.) then delete;
26728     +    run;
26729     +
26730     +    proc sql ;
26731     +       create table _scrout as select distinct _TERMNUM_, _DOCUMENT_,
26732     +        sum(COUNT) as _COUNT_ from _svdm1
26733     +        group by _TERMNUM_, _DOCUMENT_;
26734     +
26735     +       drop table _svdm1;
26736     +       drop table _terms;
26737     +    quit;
26738     +
26739     +    %tmsort(data=&termds(where=(KEEP='Y' and PARENT=.)),
26740     +         out=_weights (rename=(KEY=INDEX WEIGHT=GWGT) keep=KEY WEIGHT),
26741     +         by=KEY, options=, threads=);
26742     +
26743     +
26744     +    %tmsort(data=_scrout, out=_scrout, by=_DOCUMENT_, options=, threads=);
26745     +      %let svdkeep=%left(&svdkeep);
26746     +      data &svd_u;
26747     +         set &svd_u(keep= index col1-col&svdkeep);
26748     +      run;
26749     +
26750     +      proc sql;
26751     +         create table  _inweights as
26752     +         select a.*
26753     +         from _weights a right join &svd_u b
26754     +         on a.index=b.index
26755     +         ;
26756     +       quit;
26757     +    %if %lowcase(&cellwgt) = bin %then %let cellwgt=BINARY;
26758     +    proc spsvd data=_scrout IN_U=&svd_u
26759     +        local = &cellwgt global = none in_global = _inweights ;
26760     +        row _TERMNUM_;
26761     +        col _DOCUMENT_;
26762     +        entry _COUNT_;
26763     +        output colpro=_COLPRO bigpro normcol prefix="&prefix._SVD";
26764     +    run;
26765     +    proc sort data=_import_ds;
26766     +    by _DOCUMENT_; run;
26767     +
26768     +    proc sort data=_colpro;
26769     +    by INDEX;
26770     +    run;
26771     +
26772     +    data &export;
26773     +        merge _import_ds (in=_C_ ) _colpro (rename=(INDEX=_DOCUMENT_));
26774     +        by _DOCUMENT_;
26775     +        if _C_;
26776     +    run;
26777     +
26778     +    data &export;
26779     +       set  &export;
26780     +       array svd_array &prefix._SVD1 - &prefix._SVD&svdkeep.;
26781     +       do i = 1 to dim(svd_array);
26782     +          if svd_array(i)=. then svd_array(i)=0;
26783     +       end;
26784     +       drop i;
26785     +    run;
26786     +
26787     +
26788     +    %tmsort(data=&export, out=, by=_document_, options=, threads=);
26789     +
26790     +    %if %left(&algorithm)=1.0 %then %do;
26791     +
26792     +        %tmemclus(data=&export,
26793     +            role=SCORE, clusters=&nclus,
26794     +            seed=&emoutstat,
26795     +            outstat=, out=&export,
26796     +            vars=%STR(&prefix._SVD1 - &prefix._SVD&SVDKEEP),
26797     +            cov=, iter=5, secclus=,
26798     +            seciter=, min=, method=, eps=.1, init=, print=,
26799     +            p=, outliers=, decvar=0,
26800     +            initstd=, dist=, secstd=, nobs=);
26801     +        run;
26802     +
26803     +        %tmpred(&export, &export, &nclus, type=, ignore=0,
26804     +                  freqDS=, compress=1);
26805     +
26806     +        data &export;
26807     +           set &export;
26808     +           rename prob1-prob&nClus = &prefix._prob1-&prefix._prob&nclus;
26809     +           rename _cluster_=&prefix._cluster_;
26810     +        run;
26811     +
26812     +        %if &outclusters ne %then %do;
26813     +              %let memloc = _tmmem;
26814     +              proc tmutil data=&_scrout key=&filterterms ;
26815     +                 control init memloc="&memloc" release;
26816     +                 output keeponly out=_outtmutil;
26817     +              run;
26818     +
26819     +              data _docdata;
26820     +                 set &export (rename=(&prefix._cluster_=cluster));
26821     +              run;
26822     +
26823     +              /* Recalculate desc terms */
26824     +              data _terms_;
26825     +               set &filterterms;
26826     +               by key _ispar;
26827     +               if first.key then
26828     +                output;
26829     +               else;
26830     +              run;
26831     +
26832     +              data _terms_;
26833     +               set _terms_;
26834     +               if _ispar='+' then
26835     +                  Term=_ispar || ' ' || term;
26836     +              run;
26837     +
26838     +             %tmsort(data=_outtmutil,
26839     +               out=_tmout_,
26840     +               by=_termnum_,
26841     +                  options=,
26842     +               threads=threads);
26843     +
26844     +
26845     +             data _tmout_;
26846     +               merge _tmout_ (in=_A_)
26847     +                  _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
26848     +               by _termnum_;
26849     +               if _A_;
26850     +             run;
26851     +
26852     +             data _docs_;
26853     +               set _docdata (rename=(cluster=_cluster_) keep=_document_ cluster);
26854     +               _SEGMNT_=_cluster_;
26855     +             run;
26856     +
26857     +             %tmterm1(DSN_TPARS=_tmout_,
26858     +              DSN_CLUS=_docs_,
26859     +              DSN_DESC=_desc_,
26860     +              N_DESC_TERMS=&descterms,
26861     +              N_CLUS=&nclus,
26862     +              top_freq=%eval(&descterms*2),
26863     +              key=);
26864     +
26865     +             %tmsort(data=_desc_,
26866     +               out=_desc_,
26867     +               by=_cluster_,
26868     +                  options=,
26869     +               threads=threads);
26870     +
26871     +             proc sql noprint;
26872     +               create table &outclusters as
26873     +                 select a.clus_desc, b.* from &outclusters b left join _desc_ a
26874     +                 on a._cluster_=b._cluster_;
26875     +             quit;
26876     +
26877     +       %end;
26878     +
26879     +    %end;
26880     +    %else %do;
26881     +
26882     +        data _clustermean;
26883     +            set &clusters(keep=_cluster_ _mean1-_mean&svdkeep. freq);
26884     +        run;
26885     +
26886     +        proc sql;
26887     +        create table _meandocs as
26888     +            select a.*, b.*
26889     +            from &export(keep=&prefix._SVD1 - &prefix._SVD&SVDKEEP _document_) a , _clustermean b;
26890     +        quit;
26891     +
26892     +
26893     +        proc sort data=_meandocs;
26894     +        by _document_;
26895     +        run;
26896     +
26897     +        %if (&syscc>4) %then %do;
26898     +            %let emexceptionstring=EMTOOL.INSUFFICIENTMEM;
26899     +            %goto end_tmc;
26900     +        %end;
26901     +
26902     +        %tmsort(data=_meandocs,out=,by=_document_);
26903     +
26904     +          data _docdata(drop=_mean1-_mean&svdkeep. j _CLUSTER_ _freq_ rename=(_cluster_=&prefix._cluster_ distance=&prefix._distance));
26905     +            set _meandocs;
26906     +            drop _minDist_ _dist_ j freq;
26907     +            label CLUSTER = 'Cluster ID';
26908     +            array _means(&svdkeep) _mean1-_mean&svdkeep.;
26909     +            array _cols(&svdkeep) &prefix._SVD1-&prefix._SVD&svdkeep.;
26910     +            by _document_;
26911     +            retain CLUSTER _mindist_;
26912     +            _dist_ = 0;
26913     +            /* innner product*/
26914     +            do j = 1 to &svdkeep;
26915     +                _dist_ = _dist_ + (_cols(j)-_means(j))*(_cols(j)-_means(j));
26916     +            end;
26917     +
26918     +            /* initialization*/
26919     +            if first._document_ then do;
26920     +                _minDist_ = _dist_;
26921     +                CLUSTER = _cluster_;
26922     +            end;
26923     +            /*optimization*/
26924     +            if (_dist_ < _minDist_) then do;
26925     +                _minDist_ = _dist_;
26926     +                CLUSTER = _cluster_;
26927     +            end;
26928     +            if last._document_ then do;
26929     +               output;
26930     +            end;
26931     +        run;
26932     +        proc sort data=_docdata;
26933     +           by _document_;
26934     +        proc sort data=&export;
26935     +           by _document_;
26936     +        run;
26937     +
26938     +        data &export;
26939     +           merge &export _docdata;
26940     +           by _document_;
26941     +           rename cluster=&prefix._cluster_;
26942     +        run;
26943     +    %end;
26944     +
26945     +    /* Reorder variables in exported data set */
26946     +    proc sql noprint;
26947     +        create table &export as
26948     +        select &textvar, &prefix._cluster_, *
26949     +        from &export;
26950     +    quit;
26951     +
26952     +
26953     +    %if &outclusters ne %then %do;
26954     +
26955     +        /* update freqencies in cluster table */
26956     +         proc freq data =_docdata ;
26957     +            tables cluster/out=_tempfreqtable;
26958     +         run;
26959     +
26960     +        proc sql noprint;
26961     +            create table &outclusters as
26962     +            select  a.*, b.count as freq, b.percent/100 as percent
26963     +            from &clusters (drop= freq percent _rmsstd_) a, _tempfreqtable b
26964     +           where a._cluster_=b.cluster;
26965     +
26966     +        quit;
26967     +
26968     +        %if %left(&algorithm)=2.0 %then %do;
26969     +
26970     +          proc sql noprint;
26971     +
26972     +             create table &hierds as select a.freq, b.*
26973     +                from &outclusters a right join &hierds b on a._cluster_=b._cluster_;
26974     +          quit;
26975     +
26976     +          /* Find descriptive terms for clusters & parents */
26977     +          filename temp catalog 'sashelp.emtxtext.tmgethierterms.source';
26978     +          %include temp;
26979     +          filename temp;
26980     +
26981     +          %tm_getHierTerms(hierds=&hierds,
26982     +                         docs=_docdata,
26983     +                         tmout=&filtertmout,
26984     +                         terms= &filterterms,
26985     +                         ndescterms=&descterms);
26986     +
26987     +          proc sql noprint;
26988     +             create table &outclusters as
26989     +                select a.clus_desc, b.* from &hierds a, &outclusters b
26990     +                where a._cluster_=b._cluster_;
26991     +
26992     +             update &hierds set freq=0 where clus_desc="" and _cluster_ ne 1;
26993     +          quit;
26994     +
26995     +          /* Add frequencies to ancestors */
26996     +          data _hd;
26997     +             set &hierds;
26998     +             cluster=_cluster_;
26999     +             drop _cluster_ parent;
27000     +          run;
27001     +
27002     +          %let empty=1;
27003     +
27004     +          %do %while (&empty);
27005     +
27006     +            proc sql noprint;
27007     +                update _hd set freq=
27008     +                    (select sum(freq) from &HIERDS
27009     +                    where parent=cluster)
27010     +                    where freq=. and cluster not in
27011     +                    (select parent from &hierds where freq=.);
27012     +                select count(*) into :empty from _hd
27013     +                    where freq=.;
27014     +                update &hierds set freq=(select freq from _hd where _cluster_=cluster);
27015     +            quit;
27016     +
27017     +          %end;
27018     +
27019     +          /* Set graphdesc variable for graph display */
27020     +          data &hierds(drop=plus pos sub);
27021     +            set &hierds;
27022     +            plus='';
27023     +            if substr(CLUS_DESC, 1, 1) = "+" then plus="+ ";
27024     +            if ktrim(clus_desc) ne "" then do;
27025     +              if(substr(CLUS_DESC, 1, 1)) = "'" then do;
27026     +                 pos = findc(CLUS_DESC, "'",2);
27027     +                 sub = substr(CLUS_DESC,1,pos);
27028     +              end;
27029     +              else sub = scan(CLUS_DESC, 1);
27030     +              graphdesc=_CLUSTER_ || ': ' || plus || sub;
27031     +            end;
27032     +            else graphdesc=_CLUSTER_;
27033     +          run;
27034     +        %end;
27035     +
27036     +         /*calculate residual for each doc */
27037     +
27038     +         proc sort data=_docdata (rename=(cluster=_cluster_));
27039     +            by _cluster_;
27040     +         run;
27041     +
27042     +         data _rmscalc;
27043     +            merge _docdata(in=inhere) &outclusters;
27044     +            array _means(&svdkeep) _mean1-_mean&svdkeep.;
27045     +            array _svds(&svdkeep) &prefixstring._SVD1 - &prefixstring._SVD&svdkeep.;
27046     +            by _cluster_;
27047     +            error=0;
27048     +            do i = 1 to &svdkeep;
27049     +               error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
27050     +            end;
27051     +
27052     +            drop i ;
27053     +         run;
27054     +
27055     +          /*calc standardized residual for clusters*/
27056     +         proc summary data=_rmscalc nway;
27057     +            class _cluster_;
27058     +            var error;
27059     +            output out=_meanerr mean=meane sum=sume;
27060     +         run;
27061     +
27062     +         data _rmsse;
27063     +            set _meanerr;
27064     +            /* original code divides by number of svd dims*/
27065     +            if _freq_ gt 1 then do;
27066     +              _rmsstd_=sqrt(sume/((_freq_-1)*(&svdkeep.)));
27067     +            end;
27068     +            else do;
27069     +              _rmsstd_=0;
27070     +            end;
27071     +            keep _cluster_  _rmsstd_;
27072     +         run;
27073     +
27074     +
27075     +         proc sql noprint;
27076     +           create table _clusstat2 as
27077     +           select a.*,b.*
27078     +           from &outclusters a left join _rmsse b
27079     +           on a._cluster_=b._cluster_;
27080     +
27081     +           create table &outclusters as
27082     +           select * from _clusstat2;
27083     +         quit;
27084     +
27085     +
27086     +    %end;
27087     +
27088     +
27089     +%end_tmc:
27090     +    %if &tm_debug =0  %then %do;
27091     +    proc sql noprint;
27092     +        drop table _weights;
27093     +        drop table _colpro;
27094     +        drop table _scrout;
27095     +        drop table _svdm1;
27096     +        drop table _inweights;
27097     +        drop table _clustermean;
27098     +        drop table _clusstat2;
27099     +        drop table _outtmutil;
27100     +        drop table _rmscalc;
27101     +        drop table _rmsse;
27102     +        drop table _meanerr;
27103     +        drop table _meandocs;
27104     +        drop table _import_ds;
27105     +        drop table _hd;
27106     +        drop table _terms_;
27107     +        drop table _docs_;
27108     +        drop table _tmout_;
27109     +        drop table _desc_;
27110     +        drop table _docdata;
27111     +    quit;
27112     +    %end;
27113     +
27114     +%mend tmc_doc_score;
27115     +
27116     +
27117     +
27118     +
27119     +
27120     +
27121     +
27122     +
27123     +
27124     +
27125     +
27126     +
27127     +
27128     +
27129     +
27130     +
27131     +
27132     +
27133     +
27134     +
27135     +
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmsvd.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMSVD.SOURCE입니다.
27137     + /*
27139     +  Macro:     tmsvd.sas
27140     +  Purpose:  Call proc spsvd with given defaults and parameters.
27141     +  Syntax:   %tmsvd(in,k=,global=,local=,row=,col=,entry=,scaleOp=,normOp=,
27142     +            in_global=,in_u=,in_s=,in_v=,u=,s=,v=,wgt=,wordPro=,
27143     +           colPro=, p=, tol=, gwgt=, mink=, maxk=, res=, remote=, compact=,bigpro=0);
27145     +  Required Parameters:  in     The data= data set.
27146     +  Optional Parameters:  k= The number of dimensions to reduce to
27147     +                   global=  The global weight to use, defaults to IDF.
27148     +                   local=  The local weight to use, defaults to BINARY.
27149     +                   row=   Column in the input data set that represents
27150     +                          the matrix row,
27151     +                       defaults to _termnum_.
27152     +            col=   Column in the input data set that represents
27153     +                          the matrix column,
27154     +                         defaults to _document_.
27155     +            entry= Column in the input data set that represents the
27156     +                          value in the
27157     +                         given row,column cell.  Defaults to _count_.
27158     +             scaleOp= Scale options: scalerow scalecol scaleall
27159     +            normOp=  Normalization options: normrow normcol normall
27160     +            in_global= The gwgt= output data set from a prior spsvd run.
27161     +                   in_u=  The u= output from a prior spsvd run.
27162     +                   in_s=  The s= output from a prior spsvd run.
27163     +                   in_v=  The v= output from a prior spsvd run.
27164     +                   u=     matrix U data set
27165     +                   s=     matrix S data set
27166     +                   v=     matrix V data set
27167     +                  wgt=   weighted input matrix data set
27168     +                  wordPro= projections of rows of A onto columns of V
27169     +                  colPro=  projection of columns of A onto columns of U
27170     +                  p=   number of iterations
27171     +                  tol= convergence tolerance
27172     +                   gwgt= global weights data set
27173     +                  mink=
27174     +                  maxk=
27175     +                  res=
27176     +                  remote= name of file
27178     +  History:
27179     +  2001/01/16 - Kevin Daly - Initial coding.
27180     +  2001/01/19 - Kevin Daly - Fixed so that when global=NONE and local=NONE,
27181     +             no gwgt data set
27182     +               is requested.  This was causing an error and the proc
27183     +              would terminate.
27184     +  2001/02/21 - Bill Wheeler - Allowd all options to be specified
27185     +  2001/05/14 - Bill Wheeler - Added version 9 options min_k, max_k, resolution
27186     +  2001/08/14 - Bill Wheeler - Added remote option
27187     +  2001/11/29 - Bill Wheeler - Updated for version 8 or 9
27188     +*/
27190     +%macro tmsvd(in,k=,global=,local=,row=,col=,entry=,scaleOp=,normOp=,
27191     +             in_global=, in_u=, in_s=, in_v=, u=, s=, v=,
27192     +             wgt=, wordPro=, colPro=, p=, tol=, gwgt=, mink=, maxk=, res=,
27193     +             remote=, compact=,bigpro= );
27195     +  %put;
27196     +  /* Defaults */
27197     +  %if &k ^= %then %let k = k = &k;
27198     +  %if &global ^= %then %let global = global = &global;
27199     +  %if %lowcase(&local) = bin %then %let local=BINARY;
27200     +  %if &local ^= %then %let local=local=&local;
27201     +  %if &row= %then %let row=_termnum_;
27202     +  %if &col= %then %let col=_document_;
27203     +  %if &entry= %then %let entry=_count_;
27204     +  %if &scaleOp ^= %then %let scaleOp = scaledoc;
27205     +  %if &normOp ^= %then %let normOp = normdoc;
27206     +  %if &compact ^= %then %let compact = compact;
27207     +  %else %let compact = ;
27209     +  %if &in_global ^= %then %let in_global = in_global=&in_global;
27210     +  %if &in_u ^= %then %let in_u = in_u=&in_u;
27211     +  %if &in_s ^= %then %let in_s = in_s=&in_s;
27212     +  %if &in_v ^= %then %let in_v = in_v=&in_v;
27213     +  %if ((&p ^= ) and (&p ^= .)) %then %let p = p=&p;
27214     +  %else %let p = ;
27215     +  %if ((&tol ^= ) and (&tol ^= .)) %then %let tol = tol=&tol;
27216     +  %else %let tol = ;
27218     +  %IF &SYSVER < 9 %THEN %DO;
27219     +    %IF &k = %THEN %DO;
27220     +      %IF &maxk ^= %THEN %LET k = k = &maxk;
27221     +      %ELSE %LET k = k = 100;
27222     +    %END;
27223     +    %LET mink = ;
27224     +    %LET maxk = ;
27225     +    %LET res = ;
27226     +    %LET remote = ;
27227     +    %LET compact = ;
27228     +  %END;
27231     +  %if &colPro ^= %then %let colPro = COLPRO=&colPro;
27232     +  %if &gwgt ^= %then %let gwgt = GWGT=&gwgt;
27233     +  %if &s ^= %then %let s = S=&s;
27234     +  %if &u ^= %then %let u = U=&u;
27235     +  %if &v ^= %then %let v = V=&v;
27236     +  %if &wordPro ^= %then %let wordPro = WORDPRO=&wordPro;
27237     +  %if &wgt ^= %then %let wgt = WGT=&wgt;
27238     +  %if (&mink ^=  ) and (&mink ^= .) %then %let mink = min_k = &mink;
27239     +  %else %let mink = ;
27240     +  %if &maxk ^= %then %let maxk = max_k = &maxk;
27241     +  %if &res ^= %then %let res = res = &res;
27242     +  proc sort data=&in; by &col;
27243     +  /* Run the proc */
27244     +  proc spsvd data=&in
27245     +      &mink
27246     +      &maxk
27247     +      &res
27248     +      &k &compact
27249     +    &local &global &in_global
27250     +    &in_u &in_s &in_v &p &tol;
27251     +    row &row; col &col; entry &entry;
27252     +      output &colPro &gwgt &normOp &scaleOp &s &u &v
27253     +           &wordPro &wgt &bigpro;
27254     +    &remote;
27255     +  run;
27257     +%mend tmsvd;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmfast.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMFAST.SOURCE입니다.
27258     + /*
27259     +
27260     +  Macro:   tmfast.sas
27261     +  Purpose: Call proc fastclus with given defaults and parameters.
27262     +  Syntax:  %tmfast(data=, clusters=, outstat=, vars=);
27263     +
27264     +  Required Parameters:  data=      The input data set.
27265     +                        clusters=  The maximum number of clusters
27266     +
27267     +  Optional Parameters:  vars=      Variables to be used
27268     +                        outstat=   The name of the OUTSTAT data set
27269     +                        outseed=   The name of the OUTSEED data set
27270     +
27271     +  Either outstat or outseed mut be given, but not both.
27272     +  History:
27273     +  2001/01/16 - Bill Wheeler - Initial Coding.
27274     +
27275     +*/
27276     +%MACRO tmfast(data=, clusters=, outstat=, outseed=,
27277     +                 id=, out=, vars=);
27278     + /* defaults */
27279     + %if (&id ne ) %then %let id = id &id;
27280     + %if (&out ne ) %then %let out = out = &out;
27281     + %if (&vars ne ) %then %let var = var &vars;
27282     + %else %let var = ;
27283     +
27284     + %if &outseed= %then
27285     + %do;
27286     +   proc fastclus data = &data
27287     +   maxclusters = &clusters noprint
27288     +   outstat = &outstat &out;
27289     +   &var;
27290     +   &id;
27291     + %end;
27292     + %else
27293     + %do;
27294     +   proc fastclus data = &data
27295     +   maxclusters = &clusters noprint
27296     +   outseed = &outseed &out;
27297     +   &var;
27298     +   &id;
27299     + %end;
27300     +%MEND tmfast;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   proc sql noprint;
MPRINT(SCORE):   select count(*) into :svdkeep from EMWS5.TextCluster3_svd_s where keep=1;
MPRINT(SCORE):   create table _clusterms as select key, term, role, keep, freq, numdocs, parent, _ispar, weight from EMWS5.TextCluster3_terms;
NOTE: Table WORK._CLUSTERMS created, with 2184 rows and 9 columns.
 
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(SCORE):   data _filter_tmout;
MPRINT(SCORE):   set EMWS5.TextFilter_tmout;
MPRINT(SCORE):   run;
 
NOTE: 3584개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._FILTER_TMOUT은(는) 3584개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   select cellwgt into: cellwgt from EMWS5.TextCluster3_tmconfig;
MPRINT(TMC_DOC_SCORE):   select clus_alg into: algorithm from EMWS5.TextCluster3_tmconfig;
MPRINT(TMC_DOC_SCORE):   select parseVar into :textvar from EMWS5.TextCluster3_tmconfig;
MPRINT(TMC_DOC_SCORE):   select count(*) into :nclus from EMWS5.TextCluster3_clusters;
MPRINT(TMC_DOC_SCORE):   select count(*) into :svdkeep from EMWS5.TextCluster3_svd_s where keep=1;
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   data _import_ds;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextTopic_TRAIN;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTTOPIC_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 WORK._IMPORT_DS은(는) 500개의 관측값과 23개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _clusterms(where=(keep='Y')) THREADS out = _terms(keep= KEY PARENT);
MPRINT(TMSORT):   by KEY;
MPRINT(TMSORT):   run;
 
NOTE: 입력 데이터셋이 이미 정렬되어 있습니다; 출력 데이터셋에 복사되었습니다.
NOTE: 2184개의 관측값을 데이터셋 WORK._CLUSTERMS.에서 읽었습니다.
      WHERE keep='Y';
NOTE: 데이터셋 WORK._TERMS은(는) 2184개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMSORT):   proc sort data = _filter_tmout THREADS out = _filter_tmout;
MPRINT(TMSORT):   by _termnum_;
MPRINT(TMSORT):   run;
 
NOTE: 3584개의 관측값을 데이터셋 WORK._FILTER_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._FILTER_TMOUT은(는) 3584개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data _svdm1;
MPRINT(TMC_DOC_SCORE):   merge _terms (where=(PARENT ne _termnum_) in=_b_ keep=KEY PARENT rename=(KEY=_TERMNUM_)) _filter_tmout (in = _A_ rename=(_COUNT_=COUNT));
MPRINT(TMC_DOC_SCORE):   by _termnum_;
MPRINT(TMC_DOC_SCORE):   if _B_;
MPRINT(TMC_DOC_SCORE):   if (_A_ and _B_ and (PARENT ne .)) then _TERMNUM_ = PARENT;
MPRINT(TMC_DOC_SCORE):   keep _TERMNUM_ _DOCUMENT_ COUNT;
MPRINT(TMC_DOC_SCORE):   if (_DOCUMENT_=.) or (COUNT=.) then delete;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 1869개의 관측값을 데이터셋 WORK._TERMS.에서 읽었습니다.
      WHERE PARENT not = _termnum_;
NOTE: 3584개의 관측값을 데이터셋 WORK._FILTER_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDM1은(는) 3584개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql ;
MPRINT(TMC_DOC_SCORE):   create table _scrout as select distinct _TERMNUM_, _DOCUMENT_, sum(COUNT) as _COUNT_ from _svdm1 group by _TERMNUM_, _DOCUMENT_;
NOTE: Table WORK._SCROUT created, with 3565 rows and 3 columns.
 
MPRINT(TMC_DOC_SCORE):   drop table _svdm1;
NOTE: 테이블 WORK._SVDM1 을(를) 삭제했습니다.
MPRINT(TMC_DOC_SCORE):   drop table _terms;
NOTE: 테이블 WORK._TERMS 을(를) 삭제했습니다.
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMSORT):   proc sort data = _clusterms(where=(KEEP='Y' and PARENT=.)) out = _weights (rename=(KEY=INDEX WEIGHT=GWGT) keep=KEY WEIGHT);
MPRINT(TMSORT):   by KEY;
MPRINT(TMSORT):   run;
 
NOTE: 입력 데이터셋이 이미 정렬되어 있습니다; 출력 데이터셋에 복사되었습니다.
NOTE: 1551개의 관측값을 데이터셋 WORK._CLUSTERMS.에서 읽었습니다.
      WHERE (KEEP='Y') and (PARENT=.);
NOTE: 데이터셋 WORK._WEIGHTS은(는) 1551개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMSORT):   proc sort data = _scrout out = _scrout;
MPRINT(TMSORT):   by _DOCUMENT_;
MPRINT(TMSORT):   run;
 
NOTE: 3565개의 관측값을 데이터셋 WORK._SCROUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._SCROUT은(는) 3565개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster3_svd_u;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster3_svd_u(keep= index col1-col44);
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 469개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_SVD_U.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_SVD_U은(는) 469개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql;
MPRINT(TMC_DOC_SCORE):   create table _inweights as select a.* from _weights a right join EMWS5.TextCluster3_svd_u b on a.index=b.index ;
NOTE: Table WORK._INWEIGHTS created, with 469 rows and 2 columns.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc spsvd data=_scrout IN_U=EMWS5.TextCluster3_svd_u local = LOG global = none in_global = _inweights ;
MPRINT(TMC_DOC_SCORE):   row _TERMNUM_;
MPRINT(TMC_DOC_SCORE):   col _DOCUMENT_;
MPRINT(TMC_DOC_SCORE):   entry _COUNT_;
MPRINT(TMC_DOC_SCORE):   output colpro=_COLPRO bigpro normcol prefix="TextCluster3_SVD";
MPRINT(TMC_DOC_SCORE):   run;
 
WARNING: There are entries to be projected that are not on the IN_U dataset.
NOTE: 3565개의 관측값을 데이터셋 WORK._SCROUT.에서 읽었습니다.
NOTE: 469개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_SVD_U.에서 읽었습니다.
NOTE: 469개의 관측값을 데이터셋 WORK._INWEIGHTS.에서 읽었습니다.
NOTE: 데이터셋 WORK._COLPRO은(는) 437개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: 프로시저 SPSVD 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sort data=_import_ds;
MPRINT(TMC_DOC_SCORE):   by _DOCUMENT_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._IMPORT_DS.에서 읽었습니다.
NOTE: 데이터셋 WORK._IMPORT_DS은(는) 500개의 관측값과 23개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sort data=_colpro;
MPRINT(TMC_DOC_SCORE):   by INDEX;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 437개의 관측값을 데이터셋 WORK._COLPRO.에서 읽었습니다.
NOTE: 데이터셋 WORK._COLPRO은(는) 437개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster3_TRAIN;
MPRINT(TMC_DOC_SCORE):   merge _import_ds (in=_C_ ) _colpro (rename=(INDEX=_DOCUMENT_));
MPRINT(TMC_DOC_SCORE):   by _DOCUMENT_;
MPRINT(TMC_DOC_SCORE):   if _C_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._IMPORT_DS.에서 읽었습니다.
NOTE: 437개의 관측값을 데이터셋 WORK._COLPRO.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN은(는) 500개의 관측값과 67개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster3_TRAIN;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster3_TRAIN;
MPRINT(TMC_DOC_SCORE):   array svd_array TextCluster3_SVD1 - TextCluster3_SVD44;
MPRINT(TMC_DOC_SCORE):   do i = 1 to dim(svd_array);
MPRINT(TMC_DOC_SCORE):   if svd_array(i)=. then svd_array(i)=0;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   drop i;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN은(는) 500개의 관측값과 67개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = EMWS5.TextCluster3_TRAIN ;
MPRINT(TMSORT):   by _document_;
MPRINT(TMSORT):   run;
 
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN은(는) 500개의 관측값과 67개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMEMCLUS):   proc emclus data = EMWS5.TextCluster3_TRAIN role = score clusters = 6 seed=EMWS5.TextCluster3_emoutstat out = EMWS5.TextCluster3_TRAIN ;
MPRINT(TMEMCLUS):   var TextCluster3_SVD1 - TextCluster3_SVD44;
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   run;
 
WARNING: Some variances for cluster 1 are less than the minimum allowable variance. Posterior probabilities will be computed using the minimum allowable variance.
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN.에서 읽었습니다.
NOTE: 13개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_EMOUTSTAT.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN은(는) 500개의 관측값과 74개의 변수를 가지고 있습니다.
NOTE: 프로시저 EMCLUS 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMPRED):   * set the optional arguments;
MPRINT(TMPRED):   data EMWS5.TextCluster3_TRAIN(compress=Y drop=_c1-_c6) ;
MPRINT(TMPRED):   set EMWS5.TextCluster3_TRAIN end=eof;
MPRINT(TMPRED):   * array for holding all probabilities;
MPRINT(TMPRED):   array _p prob1--prob6;
MPRINT(TMPRED):   array _c(6);
MPRINT(TMPRED):   retain _c 0;
MPRINT(TMPRED):   * get rid of working columns;
MPRINT(TMPRED):   drop _max_ _i _WARN_;
MPRINT(TMPRED):   _max_ = 0;
MPRINT(TMPRED):   do _i = 1 to 6;
MPRINT(TMPRED):   if _p(_i) > _max_ then do;
MPRINT(TMPRED):   _max_ = _p(_i);
MPRINT(TMPRED):   _CLUSTER_ = _i;
MPRINT(TMPRED):   end;
MPRINT(TMPRED):   end;
MPRINT(TMPRED):   if (_CLUSTER_ >= 1) and (_CLUSTER_ <= 6) then _c(_CLUSTER_) = _c(_CLUSTER_) + 1;
MPRINT(TMPRED):   else _CLUSTER_ = .;
MPRINT(TMPRED):   ;
MPRINT(TMPRED):   run;
 
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN은(는) 500개의 관측값과 74개의 변수를 가지고 있습니다.
NOTE: 데이터셋 'EMWS5.TEXTCLUSTER3_TRAIN'을(를) 압축해서 크기가 69.23%(으)로 줄었습니다.
      압축된 파일은 4페이지입니다. 압축되지 않은 파일은 13페이지가 필요합니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster3_TRAIN;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster3_TRAIN;
MPRINT(TMC_DOC_SCORE):   rename prob1-prob6 = TextCluster3_prob1-TextCluster3_prob6;
MPRINT(TMC_DOC_SCORE):   rename _cluster_=TextCluster3_cluster_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN은(는) 500개의 관측값과 74개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc tmutil data=_filter_tmout key=EMWS5.TextFilter_terms ;
MPRINT(TMC_DOC_SCORE):   control init memloc="_tmmem" release;
MPRINT(TMC_DOC_SCORE):   output keeponly out=_outtmutil;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 3584개의 관측값을 데이터셋 WORK._FILTER_TMOUT.에서 읽었습니다.
NOTE: 2184개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TERMS_DATA.에서 읽었습니다.
      WHERE KEEP='Y';
NOTE: 1870개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TERM_STRINGS.에서 읽었습니다.
NOTE: 데이터셋 WORK._OUTTMUTIL은(는) 3565개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 TMUTIL 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.07 초
 
 
MPRINT(TMC_DOC_SCORE):   data _docdata;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster3_TRAIN (rename=(TextCluster3_cluster_=cluster));
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCDATA은(는) 500개의 관측값과 74개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   data _terms_;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextFilter_terms;
MPRINT(TMC_DOC_SCORE):   by key _ispar;
MPRINT(TMC_DOC_SCORE):   if first.key then output;
MPRINT(TMC_DOC_SCORE):   else;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 2184개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TERMS_DATA.에서 읽었습니다.
      WHERE KEEP='Y';
NOTE: 1870개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TERM_STRINGS.에서 읽었습니다.
NOTE: 2184개의 관측값을 데이터셋 EMWS5.TEXTFILTER_TERMS.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 1869개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.17 초
      cpu 시간            0.06 초
 
 
MPRINT(TMC_DOC_SCORE):   data _terms_;
MPRINT(TMC_DOC_SCORE):   set _terms_;
MPRINT(TMC_DOC_SCORE):   if _ispar='+' then Term=_ispar || ' ' || term;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 1869개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 1869개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _outtmutil threads out = _tmout_;
MPRINT(TMSORT):   by _termnum_;
MPRINT(TMSORT):   run;
 
NOTE: 3565개의 관측값을 데이터셋 WORK._OUTTMUTIL.에서 읽었습니다.
NOTE: 데이터셋 WORK._TMOUT_은(는) 3565개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data _tmout_;
MPRINT(TMC_DOC_SCORE):   merge _tmout_ (in=_A_) _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
MPRINT(TMC_DOC_SCORE):   by _termnum_;
MPRINT(TMC_DOC_SCORE):   if _A_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 3565개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 1869개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TMOUT_은(는) 3565개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   data _docs_;
MPRINT(TMC_DOC_SCORE):   set _docdata (rename=(cluster=_cluster_) keep=_document_ cluster);
MPRINT(TMC_DOC_SCORE):   _SEGMNT_=_cluster_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;
 
NOTE: 3565개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3565개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 2071개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;
 
NOTE: 3565개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3565개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 7개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;
 
NOTE: 7개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;
 
NOTE: 2071개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 2071개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;
 
NOTE: 2071개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 157개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;
 
NOTE: 157개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 47개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 110개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 319 rows and 3 columns.
 
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;
 
NOTE: 319개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 110개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 6 ) 4 clus1 - clus6 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 6 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus6 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 3565 - 7;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 7 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 3565 - 551;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 551 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 3565 - 537;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 537 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 3565 - 376;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 376 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus5 = 0) or (clus5 < 0) then cdf5 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus5 ;
MPRINT(TMTERM1):   div = 3565 - 439;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf5 = CDF( 'binomial', clus5 , propor , 439 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf5 = 1;
MPRINT(TMTERM1):   else cdf5 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus6 = 0) or (clus6 < 0) then cdf6 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus6 ;
MPRINT(TMTERM1):   div = 3565 - 1655;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf6 = CDF( 'binomial', clus6 , propor , 1655 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf6 = 1;
MPRINT(TMTERM1):   else cdf6 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;
 
NOTE: 110개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 110개의 관측값과 14개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 6 ) cdf1 - cdf6 ;
MPRINT(TMTERM1):   array a_count ( 6 ) clus1 - clus6 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 6 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;
 
NOTE: 110개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 319개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;
 
NOTE: 319개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 319개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 319) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 319) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 319) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;
 
NOTE: 319개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMSORT):   proc sort data = _desc_ threads out = _desc_;
MPRINT(TMSORT):   by _cluster_;
MPRINT(TMSORT):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster3_clusters as select a.clus_desc, b.* from EMWS5.TextCluster3_clusters b left join _desc_ a on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 clus_desc이(가) 파일 EMWS5.TEXTCLUSTER3_CLUSTERS에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER3_CLUSTERS created, with 6 rows and 49 columns.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster3_TRAIN as select review , TextCluster3_cluster_, * from EMWS5.TextCluster3_TRAIN;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 Review이(가) 파일 EMWS5.TEXTCLUSTER3_TRAIN에 이미 존재합니다.
WARNING: 변수 TextCluster3_cluster_이(가) 파일 EMWS5.TEXTCLUSTER3_TRAIN에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER3_TRAIN created, with 500 rows and 74 columns.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   proc freq data =_docdata ;
MPRINT(TMC_DOC_SCORE):   tables cluster/out=_tempfreqtable;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._TEMPFREQTABLE은(는) 6개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 출력 결과 (프로시저: FREQ, 페이지: 2)
NOTE: 프로시저 FREQ 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster3_clusters as select a.*, b.count as freq, b.percent/100 as percent from EMWS5.TextCluster3_clusters (drop= freq percent _rmsstd_) a, _tempfreqtable b where a._cluster_=b.cluster;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS5.TEXTCLUSTER3_CLUSTERS created, with 6 rows and 48 columns.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sort data=_docdata (rename=(cluster=_cluster_));
MPRINT(TMC_DOC_SCORE):   by _cluster_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCDATA은(는) 500개의 관측값과 74개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   data _rmscalc;
MPRINT(TMC_DOC_SCORE):   merge _docdata(in=inhere) EMWS5.TextCluster3_clusters;
MPRINT(TMC_DOC_SCORE):   array _means(44) _mean1-_mean44;
MPRINT(TMC_DOC_SCORE):   array _svds(44) TextCluster3_SVD1 - TextCluster3_SVD44;
MPRINT(TMC_DOC_SCORE):   by _cluster_;
MPRINT(TMC_DOC_SCORE):   error=0;
MPRINT(TMC_DOC_SCORE):   do i = 1 to 44;
MPRINT(TMC_DOC_SCORE):   error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   drop i ;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 6개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 WORK._RMSCALC은(는) 500개의 관측값과 122개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   proc summary data=_rmscalc nway;
MPRINT(TMC_DOC_SCORE):   class _cluster_;
MPRINT(TMC_DOC_SCORE):   var error;
MPRINT(TMC_DOC_SCORE):   output out=_meanerr mean=meane sum=sume;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 500개의 관측값을 데이터셋 WORK._RMSCALC.에서 읽었습니다.
NOTE: 데이터셋 WORK._MEANERR은(는) 6개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   data _rmsse;
MPRINT(TMC_DOC_SCORE):   set _meanerr;
MPRINT(TMC_DOC_SCORE):   if _freq_ gt 1 then do;
MPRINT(TMC_DOC_SCORE):   _rmsstd_=sqrt(sume/((_freq_-1)*(44)));
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   else do;
MPRINT(TMC_DOC_SCORE):   _rmsstd_=0;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   keep _cluster_ _rmsstd_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK._MEANERR.에서 읽었습니다.
NOTE: 데이터셋 WORK._RMSSE은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table _clusstat2 as select a.*,b.* from EMWS5.TextCluster3_clusters a left join _rmsse b on a._cluster_=b._cluster_;
WARNING: 변수 _cluster_이(가) 파일 WORK._CLUSSTAT2에 이미 존재합니다.
NOTE: Table WORK._CLUSSTAT2 created, with 6 rows and 49 columns.
 
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster3_clusters as select * from _clusstat2;
NOTE: Table EMWS5.TEXTCLUSTER3_CLUSTERS created, with 6 rows and 49 columns.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMC_SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):   * path of the diagram ;
MPRINT(SCORE):   data _null_;
MPRINT(SCORE):   call symput("emwspath", strip(pathname("EMWS5")));
MPRINT(SCORE):   run;
 
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(SCORE):   filename pre "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\PRESCORECODE.sas";
MPRINT(SCORE):   data _null_;
MPRINT(SCORE):   file pre;
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmemclus.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmpred.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtxtext.tmc_doc_score.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmsort.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmsvd.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmfast.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp;';
MPRINT(SCORE):   run;
 
NOTE: 파일 PRE:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\PRESCORECODE.sas,
      RECFM=V,LRECL=32767,파일 크기 (바이트)=0,
      마지막 수정일=2018년 11월 17일 17시43분35초,
      생성 시간=2018년 11월 17일 17시43분35초
 
NOTE: 13개의 레코드를 파일 PRE에 기록했습니다.
      최소 레코드 길이는 14입니다.
      최대 레코드 길이는 62입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(SCORE):   filename tmpre "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextTopic\PRESCORECODE.sas";
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file pre MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("tmpre",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
 
NOTE: 파일 PRE:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\PRESCORECODE.sas,
      RECFM=V,LRECL=20000,파일 크기 (바이트)=452,
      마지막 수정일=2018년 11월 17일 17시43분35초,
      생성 시간=2018년 11월 17일 17시43분35초
 
NOTE: 28개의 레코드를 파일 PRE에 기록했습니다.
      최소 레코드 길이는 1입니다.
      최대 레코드 길이는 81입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(SCORE):  ;
MPRINT(SCORE):   filename tmpre;
NOTE: Fileref TMPRE을(를) 삭제했습니다.
MPRINT(SCORE):   data _codeclusters;
MPRINT(SCORE):   set EMWS5.TextCluster3_clusters (drop=clus_desc);
MPRINT(SCORE):   run;
 
NOTE: 6개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 WORK._CODECLUSTERS은(는) 6개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(SCORE):   libname termloc "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5";
NOTE: 라이브러리 참조 TERMLOC은(는) EMWS5과(와) 같은 물리적 라이브러리를 참조합니다.
NOTE: 라이브러리 참조 'TERMLOC'이(가) 다음과 같이 할당되었습니다.
      엔진:        V9
      물리적 경로: C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5
MPRINT(SCORE):   * Now save code, if necessary, for search phrase;
MPRINT(SCORE):   filename _tmscore "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMPUBLISHSCORE.sas";
MPRINT(SCORE):   data _NULL_;
MPRINT(SCORE):   file _tmscore;
MPRINT(SCORE):   length string $200;
MPRINT(SCORE):   string ='%tmc_doc_score(import='||'&em_score_output'||",export=work._newexport,";
MPRINT(SCORE):   put string;
MPRINT(SCORE):   string="      termds=termloc.TextFilter_filtterms, configds=termloc.TextCluster3_tmconfig,";
MPRINT(SCORE):   put string;
MPRINT(SCORE):   string= "      clusters=termloc.TextCluster3_clusters, emoutstat=termloc.TextCluster3_emoutstat, ";
MPRINT(SCORE):   put string;
MPRINT(SCORE):   string = "      _scrout=work.TextFilter_out, svd_u=termloc.TextCluster3_svd_u, svd_s=termloc.TextCluster3_svd_s, prefix=TextCluster3);";
MPRINT(SCORE):   put string;
MPRINT(SCORE):   string='data &em_score_output; set work._newexport;';
MPRINT(SCORE):   put string;
MPRINT(SCORE):   run;
 
NOTE: 파일 _TMSCORE:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMPUBLISHSCORE.sas,
      RECFM=V,LRECL=32767,파일 크기 (바이트)=0,
      마지막 수정일=2018년 11월 17일 17시43분35초,
      생성 시간=2018년 11월 17일 17시43분35초
 
NOTE: 5개의 레코드를 파일 _TMSCORE에 기록했습니다.
      최소 레코드 길이는 43입니다.
      최대 레코드 길이는 118입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(SCORE):   filename _tmscore;
NOTE: Fileref _TMSCORE을(를) 삭제했습니다.
MPRINT(SCORE):   filename temp;
NOTE: Fileref TEMP을(를) 삭제했습니다.
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End SCORE: TextCluster3;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
27301      *------------------------------------------------------------*;
27302      * End SCORE: TextCluster3;
27303      *------------------------------------------------------------*;
 
27305      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
27306      * TextCluster3: Computing metadata for TRAIN data;
MPRINT(EM_DIAGRAM):   * TextCluster3: Computing metadata for TRAIN data;
27307      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
 
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * &nodeid: Computing Metadata for TRAIN data;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   filename _delta "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\CDELTA_TRAIN.sas";
MPRINT(EMADVISECOLUMNS):   proc display c=sashelp.emmeta.advisecolumns.scl;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    options validvarname=any;
MPRINT(EMADVISECOLUMNS):   proc contents data=EMWS5.TextCluster3_TRAIN out=_tempAdvisor noprint;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):   options validvarname=V7;
MPRINT(EMADVISECOLUMNS):    data _null_;
MPRINT(EMADVISECOLUMNS):   dsid = open('EMWS5.TextCluster3_TRAIN');
MPRINT(EMADVISECOLUMNS):   call symput('_dsidTable', strip(put(dsid, best.)));
MPRINT(EMADVISECOLUMNS):   if dsid then do;
MPRINT(EMADVISECOLUMNS):   call symput('_engineTable', attrc(dsid, 'ENGINE'));
MPRINT(EMADVISECOLUMNS):   dsid = close(dsid);
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    options fmterr;
MPRINT(EMADVISECOLUMNS):   data _metaTestView;
MPRINT(EMADVISECOLUMNS):   set EMWS5.TextCluster3_TRAIN;
MPRINT(EMADVISECOLUMNS):   if _N_=1 then do;
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   stop;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    proc contents data=EMWS5.TextCluster3_TRAIN out=WORK.M2XAZ2VL noprint;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M2XAZ2VL;
MPRINT(EMADVISECOLUMNS):   length NAME $ 64 TYPE $ 1 LABEL $ 200 FORMAT $ 36 INFORMAT $36 INDEX $ 1 INDEXTYPE $ 9;
MPRINT(EMADVISECOLUMNS):   label NAME =;
MPRINT(EMADVISECOLUMNS):   set WORK.M2XAZ2VL(keep=name type length label format formatl formatd informat informl informd idxusage rename=(type=itype));
MPRINT(EMADVISECOLUMNS):   if itype = 1 then type = 'N';
MPRINT(EMADVISECOLUMNS):   else type = 'C';
MPRINT(EMADVISECOLUMNS):   if formatl > 0 then do;
MPRINT(EMADVISECOLUMNS):   if format ne '' then do;
MPRINT(EMADVISECOLUMNS):   if type='N' then format = strip(format)!!strip(put(formatl, best12.))!!'.'!!strip(put(formatd, best12.));
MPRINT(EMADVISECOLUMNS):   else format = strip(format)!!strip(put(formatl, best12.))!!'.';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else format = strip(put(formatl, best12.))!!'.'!!strip(put(formatd, best12.));
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if format ne '' then format = strip(format)!!'.';
MPRINT(EMADVISECOLUMNS):   if informl > 0 then do;
MPRINT(EMADVISECOLUMNS):   if informat ne ' ' then do;
MPRINT(EMADVISECOLUMNS):   if type='N' then informat = strip(informat)!!strip(put(informl, best12.))!!'.'!!strip(put(informd, best12.));
MPRINT(EMADVISECOLUMNS):   else informat = strip(informat)!!strip(put(informl, best12.))!!'.';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else informat = strip(put(informl, best12.))!!'.'!!strip(put(informd, best12.));
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if informat ne '' then informat = strip(informat)!!'.';
MPRINT(EMADVISECOLUMNS):   if idxusage = 'NONE' then index ="N";
MPRINT(EMADVISECOLUMNS):   else index = "Y";
MPRINT(EMADVISECOLUMNS):   indextype = idxusage;
MPRINT(EMADVISECOLUMNS):   drop idxusage itype formatl formatd informl informd;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M2XAZ2VL;
MPRINT(EMADVISECOLUMNS):   length UNAME $64;
MPRINT(EMADVISECOLUMNS):   set WORK.M2XAZ2VL;
MPRINT(EMADVISECOLUMNS):   UNAME = upcase(NAME);
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    proc sort data=WORK.M0X9W415 NOTHREADS;
MPRINT(EMADVISECOLUMNS):   by UNAME;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M0X9W415;
MPRINT(EMADVISECOLUMNS):   drop UNAME;
MPRINT(EMADVISECOLUMNS):   set WORK.M0X9W415;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M31PXQC0(keep=NAME ATTR);
MPRINT(EMADVISECOLUMNS):   length ATTR $ 20;
MPRINT(EMADVISECOLUMNS):   set WORK.M0X9W415;
MPRINT(EMADVISECOLUMNS):   if level ne "INTERVAL" then do;
MPRINT(EMADVISECOLUMNS):   if order = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'ORDER';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if format ne ' ' and formattype = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'FORMATTYPE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'ROLE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if level = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'LEVEL';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if type = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'TYPE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if index = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'INDEX';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if report = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'REPORT';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):   proc sort NOTHREADS;
MPRINT(EMADVISECOLUMNS):   by attr;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M0X9W415;
MPRINT(EMADVISECOLUMNS):   length NAME $64 ROLE $ 32 LEVEL $ 10 ORDER $ 8 CREATOR $32 FORMATTYPE $ 10 FAMILY $ 10 LOWERLIMIT 8 UPPERLIMIT 8 REPORT $1 DISTRIBUTION $ 20 COMMENT $64;
MPRINT(EMADVISECOLUMNS):   length levelAssigned 8 roleAssigned 8 PRICE 8;
MPRINT(EMADVISECOLUMNS):   set WORK.M0X9W415;
MPRINT(EMADVISECOLUMNS):   if formattype = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if format ne ' ' then do;
MPRINT(EMADVISECOLUMNS):   if type = 'N' then do;
MPRINT(EMADVISECOLUMNS):   pos = indexc(format,'.1234567890');
MPRINT(EMADVISECOLUMNS):   if pos > 1 then tempfmt = substr(format,1, pos-1);
MPRINT(EMADVISECOLUMNS):   else tempfmt = ' ';
MPRINT(EMADVISECOLUMNS):   flen = length(tempfmt);
MPRINT(EMADVISECOLUMNS):   select;
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("DATE" "DAY" "DDMMYY" "DOWNAME" "JULDAY" "JULIAN" "MMDDYY" "MMDDYYD" "MMDDYYC" "MMDDYYN" "MMDDYYP" "MMDDYYS" "MONNAME" "MONTH" "MONYY" "NENGO" "QTR" "QTRR" "WEEKDATE" "WEEKDATX" "WEEKDAY" "WORDDATE" "WORDDATX"
"YEAR" "YYMMDD" "YYMON" "YYMMDDC" "YYMMDDD" "YYMMDDN" "YYMMDDP" "YYMMDDS" "EURDFDE" "NJDATE" "NLDATE" "EURDFDD" "EURDFDWN" "EURDFMN" "EURDFMY" "EURDFWK" "EURDFWKX" "EURDFWDX" "EURDFDN" "EURDFDE" )) formattype = 'DATE';
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("DATETIME" "EURDFDT" "TOD" )) formattype = "DATETIME";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("HHMM" "HOUR" "MMSS" "TIME" "TIMEAMPM" )) formattype = "TIME";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("COMMA" "COMMAX" "DOLLAR" "DOLLARX" "E" "FRACT" "NEGPAREN" "PERCENT")) formattype="QUANTITY";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("BINARY" "HEX" "IB" "OCTAL" "PD" "PIB" "PK" "RB" "SSN" "Z" "ZD")) formattype = "CODING";
MPRINT(EMADVISECOLUMNS):   otherwise do;
MPRINT(EMADVISECOLUMNS):   formattype = "USER";
MPRINT(EMADVISECOLUMNS):   if compress(tempfmt, '0123456789.', '') = '' then formattype='NUM';
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 6)='NLDATE' then formattype = "DATE";
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 6)='NLDATM' then formattype = "DATETIME";
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 4)='NLTIM' then formattype = "TIME";
MPRINT(EMADVISECOLUMNS):   else if flen >= 4 then do;
MPRINT(EMADVISECOLUMNS):   str = substr(tempfmt,1,4);
MPRINT(EMADVISECOLUMNS):   if str in ("MMYY" "YYMM" "YYQR") then formattype ="DATE";
MPRINT(EMADVISECOLUMNS):   else if str = "S370" then formattype = "CODING";
MPRINT(EMADVISECOLUMNS):   else if str = "BEST" then formattype = "NUM";
MPRINT(EMADVISECOLUMNS):   drop str;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if flen >=3 and substr(tempfmt,1,3) = "YYQ" then formatType = "DATE";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   drop flen tempfmt pos;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   formatType = "CATEGORY";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if formatType = "NUM" then do;
MPRINT(EMADVISECOLUMNS):   if index = "Y" then formatType = "DISCRETE";
MPRINT(EMADVISECOLUMNS):   else formatType = "QUANTITY";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if level = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if formatType in ("CATEGORY", "CODING", "ID") or type = "C" then level = "NOMINAL";
MPRINT(EMADVISECOLUMNS):   else level = "INTERVAL";
MPRINT(EMADVISECOLUMNS):   levelAssigned = 1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else level = upcase(level);
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   length name_prefix $8 _uname $64;
MPRINT(EMADVISECOLUMNS):   drop name_prefix _uname _freqflag;
MPRINT(EMADVISECOLUMNS):   retain _freqflag;
MPRINT(EMADVISECOLUMNS):   if LENGTH> 80 then ROLE = 'TEXT';
MPRINT(EMADVISECOLUMNS):   _uname = upcase(NAME);
MPRINT(EMADVISECOLUMNS):   select(_uname);
MPRINT(EMADVISECOLUMNS):   when('_PARTIND_') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'ID';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('_WARN_') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_SEGMENT') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('_NODE_') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('EM_CLASSTARGET') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_VALUETARGET') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_PREDICTION') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_PROBABILITY') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_EVENTPROBABILITY') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_CLASSIFICATION') ROLE = 'CLASSIFICATION';
MPRINT(EMADVISECOLUMNS):   when('EM_DECISION') ROLE = 'DECISION';
MPRINT(EMADVISECOLUMNS):   when('EM_PROFIT') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_LOSS') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_ROI') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('URI') ROLE = 'URL';
MPRINT(EMADVISECOLUMNS):   when('FILTERED') ROLE = 'TEXTLOC';
MPRINT(EMADVISECOLUMNS):   otherwise do;
MPRINT(EMADVISECOLUMNS):   if upcase(NAME) =: 'ZIP' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'REJECTED';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   COMMENT = 'Rejected by: Exceed the maximum class level of %s';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if upcase(NAME) in('FREQ', 'FREQUENCY') then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'FREQ';
MPRINT(EMADVISECOLUMNS):   if TYPE = 'C' then ROLE = 'INPUT';
MPRINT(EMADVISECOLUMNS):   else if _freqflag =1 then ROLE='REJECTED';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   name_prefix = scan(_uname, 1, '_');
MPRINT(EMADVISECOLUMNS):   if scan(_uname, 2, '_') = '' then name_prefix='';
MPRINT(EMADVISECOLUMNS):   if name_prefix in('F', 'I', 'U') then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'CLASSIFICATION';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('Q') then ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('P', 'V') then ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('R', 'RS', 'RT', 'RD', 'RDS', 'RDT', 'RA', 'RAS', 'RAT') then ROLE = 'RESIDUAL';
MPRINT(EMADVISECOLUMNS):   else if name_prefix ='D' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'DECISION';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix ='B' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('EP', 'BP', 'CP', 'EL', 'CL', 'BL', 'W', 'ROI', 'IC') then ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   array _ROLE_ (19) $32 _TEMPORARY_ ('ASSESS','CLASSIFICATION','CENSOR', 'COST', 'CROSSID', 'DECISION', 'ID','INPUT', 'LABEL', 'MISSING','PREDICT','REFERRER','REJECTED', 'RESIDUAL','SEGMENT', 'SEQUENCE','TARGET', 'TEXT', 'TIMEID');
MPRINT(EMADVISECOLUMNS):   drop _found_ i;
MPRINT(EMADVISECOLUMNS):   _found_=0;
MPRINT(EMADVISECOLUMNS):   do i=1 to 19 until(_found_=1);
MPRINT(EMADVISECOLUMNS):   if index(_uname, trim(_ROLE_{i}))=1 then do;
MPRINT(EMADVISECOLUMNS):   ROLE=_ROLE_{i};
MPRINT(EMADVISECOLUMNS):   if ROLE = 'ID' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'SEGMENT' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'TIMEID' and TYPE='N' then LEVEL = 'INTERVAL';
MPRINT(EMADVISECOLUMNS):   _found_=1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if length(_uname)>2 then do;
MPRINT(EMADVISECOLUMNS):   if substr(reverse(trim(_uname)), 1, 3) = 'DI_' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'ID';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if ROLE='FREQ' then _freqflag=1;
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'CLASSIFICATION' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   if symexist('RATEMKG_ROLE') then do;
MPRINT(EMADVISECOLUMNS):   if upcase(symget('RATEMKG_ROLE')) in('Y', 'YES') then do;
MPRINT(EMADVISECOLUMNS):   if _uname =: 'POLICY' then ROLE = 'POLICYID';
MPRINT(EMADVISECOLUMNS):   else if _uname in ('PARTITION', '_PARTIND_') then ROLE = 'PARTITION';
MPRINT(EMADVISECOLUMNS):   else if type = 'N' then do;
MPRINT(EMADVISECOLUMNS):   if _uname = 'EXPOSURE' then ROLE = 'EXPOSURE';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'YEAR' then ROLE = 'YEAR';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'WEIGHT' then ROLE = 'WEIGHT';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'OFFSET' then ROLE = 'OFFSET';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if formattype in('DATE', 'DATETIME', 'TIME') then role = 'TIMEID';
MPRINT(EMADVISECOLUMNS):   else role = 'INPUT';
MPRINT(EMADVISECOLUMNS):   roleAssigned = 1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else role = upcase(role);
MPRINT(EMADVISECOLUMNS):   if REPORT = '' then REPORT = 'N';
MPRINT(EMADVISECOLUMNS):   if symexist('dmwb_product') then do;
MPRINT(EMADVISECOLUMNS):   if upcase(symget('dmwb_product')) = 'FACTORYMINER_DATASOURCE' then do;
MPRINT(EMADVISECOLUMNS):   if ROLE ^in('INPUT', 'TARGET', 'REJECTED', 'SEGMENT', 'FREQ', 'ID', 'KEY') then ROLE='REJECTED';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M0X9W415;
MPRINT(EMADVISECOLUMNS):   set WORK.M0X9W415;
MPRINT(EMADVISECOLUMNS):   label NAME = "변수 이름" TYPE = "유형" ROLE = "역할" LEVEL= "측도 레벨" ORDER= "순서" CREATOR= "생성자" FORMATTYPE= "출력형식 유형" FAMILY= "군" DISTRIBUTION= "분포" PRICE= "가격" LOWERLIMIT= "하한" UPPERLIMIT= "상한" REPORT=
"리 포트" COMMENT= "주석" INDEX= "인덱스" INDEXTYPE= "인덱스 유형" LABEL= "레이블" LENGTH= "길이";
MPRINT(EMADVISECOLUMNS):   drop levelAssigned roleAssigned;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   proc sort data=WORK.COLUMNMETA;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * &nodeid: Merge incoming metadata;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   proc contents data=EMWS5.TextTopic_TRAIN noprint out=_temp2(keep=NAME);
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc sort data=_temp2;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc sort data=EMWS5.TextTopic_CMeta_TRAIN out=_temp;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data EMWS5.TextCluster3_CMeta_TRAIN;
MPRINT(EM_DIAGRAM):   merge WORK.COLUMNMETA(in=_a) _temp2(in=_b) _temp(drop=FORMAT INFORMAT LENGTH INDEX INDEXTYPE in=_c) end=_eof_;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   if (^_a and _b) or (^_c and _a and _b) then delete;
MPRINT(EM_DIAGRAM):   if ^_b then CREATOR = "TextCluster3";
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextCluster3: Apply Delta Code;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   if upcase(NAME) = "TEXTCLUSTER3_CLUSTER_" then do;
MPRINT(EM_DIAGRAM):   ROLE = "SEGMENT";
MPRINT(EM_DIAGRAM):   LEVEL = "NOMINAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_PROB1" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_PROB2" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_PROB3" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_PROB4" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_PROB5" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_PROB6" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD1" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD10" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD11" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD12" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD13" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD14" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD15" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD16" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD17" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD18" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD19" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD2" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD20" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD21" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD22" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD23" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD24" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD25" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD26" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD27" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD28" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD29" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD3" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD30" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD31" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD32" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD33" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD34" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD35" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD36" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD37" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD38" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD39" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD4" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD40" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD41" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD42" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD43" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD44" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD5" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD6" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD7" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD8" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER3_SVD9" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _delta;
27901      proc sort data = EMWS5.TextTopic_EMINFO OUT=WORK.SORTEDEMINFO NOTHREADS;
MPRINT(EM_DIAGRAM):    proc sort data = EMWS5.TextTopic_EMINFO OUT=WORK.SORTEDEMINFO NOTHREADS;
27902      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
27903      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 8개의 관측값을 데이터셋 EMWS5.TEXTTOPIC_EMINFO.에서 읽었습니다.
NOTE: 데이터셋 WORK.SORTEDEMINFO은(는) 8개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
27904      proc sort data = EMWS5.TextCluster3_EMINFO OUT=WORK.TEMP_INFO NOTHREADS;
MPRINT(EM_DIAGRAM):   proc sort data = EMWS5.TextCluster3_EMINFO OUT=WORK.TEMP_INFO NOTHREADS;
27905      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
27906      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 4개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_EMINFO.에서 읽었습니다.
NOTE: 데이터셋 WORK.TEMP_INFO은(는) 4개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
27907      data EMWS5.TextCluster3_EMINFO;
MPRINT(EM_DIAGRAM):   data EMWS5.TextCluster3_EMINFO;
27908      merge WORK.SORTEDEMINFO WORK.TEMP_INFO;
MPRINT(EM_DIAGRAM):   merge WORK.SORTEDEMINFO WORK.TEMP_INFO;
27909      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
27910      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 8개의 관측값을 데이터셋 WORK.SORTEDEMINFO.에서 읽었습니다.
NOTE: 4개의 관측값을 데이터셋 WORK.TEMP_INFO.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_EMINFO은(는) 9개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
27911      proc datasets lib=work nolist;
MPRINT(EM_DIAGRAM):   proc datasets lib=work nolist;
27912      delete TEMP_INFO SORTEDEMINFO;
MPRINT(EM_DIAGRAM):   delete TEMP_INFO SORTEDEMINFO;
27913      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: WORK.TEMP_INFO(memtype=DATA)을(를) 삭제하는 중입니다.
NOTE: WORK.SORTEDEMINFO(memtype=DATA)을(를) 삭제하는 중입니다.
27914      quit;
MPRINT(EM_DIAGRAM):   quit;
 
NOTE: 프로시저 DATASETS 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 17일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "17시43분36초" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 리포트 로그";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* 리포트 로그
날짜:                2018년 11월 17일
시간:                17시43분36초
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O04_5PZW "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster3\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O04_5PZW new;
MPRINT(EM_DIAGRAM):   run;
27938      %let EMEXCEPTIONSTRING=;
27939      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
27940      * REPORT: TextCluster3;
MPRINT(EM_DIAGRAM):   * REPORT: TextCluster3;
27941      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
27942      %let EM_ACTION = REPORT;
27943      %let syscc = 0;
27944      %macro main();
27945
27946         %if %upcase(&EM_ACTION) eq CREATE %then %do;
27947            filename temp catalog 'sashelp.emtxtext.cluster_create.source';
27948            %include temp;
27949            %create();
27950         %end;
27951         %if %upcase(&EM_ACTION) eq TRAIN %then %do;
27952            filename temp catalog 'sashelp.emtxtext.cluster_train.source';
27953            %include temp;
27954            %train();
27955         %end;
27956         %if %upcase(&EM_ACTION) eq REPORT %then %do;
27957            filename temp catalog 'sashelp.emtxtext.cluster_report.source';
27958            %include temp;
27959            %report();
27960         %end;
27961         %if %upcase(&EM_ACTION) eq SCORE %then %do;
27962            filename temp catalog 'sashelp.emtxtext.cluster_score.source';
27963            %include temp;
27964            %score();
27965         %end;
27966      %mend main;
27967
27968      %main();
MPRINT(EM_DIAGRAM):
MPRINT(MAIN):   filename temp catalog 'sashelp.emtxtext.cluster_report.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.CLUSTER_REPORT.SOURCE입니다.
27969     +%macro report();
27970     +
27971     +    %EM_GETNAME(KEY=GRAPH_TABLE, TYPE=DATA);
27972     +    %EM_GETNAME(KEY=clusters, TYPE=DATA);
27973     +    %EM_GETNAME(KEY=prescorecode, type=file, extension=sas);
27974     +    %em_getname(key=svd_s, type=data);
27975     +    %em_getname(key=hierds, type=data);
27976     +
27977     +    proc sql noprint;
27978     +        select count(*) into :svdkeep
27979     +            from &em_user_svd_s
27980     +            where keep=1;
27981     +        select count(*) into :nclus
27982     +            from &em_user_clusters;
27983     +    quit;
27984     +    %let svdkeep=%left(&svdkeep);
27985     +    %let nclus=%left(&nclus);
27986     +    %let clusterid=%sysfunc(sasmsg(sashelp.tmine, rpt_text_clusterid_vlabel, NOQUOTE));
27987     +    %let frequency=%sysfunc(sasmsg(sashelp.tmine, rpt_text_frequency_vlabel, NOQUOTE));
27988     +    %let percentage=%sysfunc(sasmsg(sashelp.tmine, rpt_text_percentage_vlabel, NOQUOTE));
27989     +    %let descterms=%sysfunc(sasmsg(sashelp.tmine, rpt_text_descterms_vlabel, NOQUOTE));
27990     +    %let rmsstd=%sysfunc(sasmsg(sashelp.tmine, rpt_text_rmsstd_vlabel, NOQUOTE));
27991     +    %let coordinate=%sysfunc(sasmsg(sashelp.tmine, rpt_text_coordinate_vlabel, NOQUOTE));
27992     +    %let parent=%sysfunc(sasmsg(sashelp.tmine, rpt_text_parent_vlabel, NOQUOTE));
27993     +    %let hierlevel=%sysfunc(sasmsg(sashelp.tmine, rpt_text_hierlevel_vlabel, NOQUOTE));
27994     +    %let graphdesc=%sysfunc(sasmsg(sashelp.tmine, rpt_text_graphdesc_vlabel, NOQUOTE));
27995     +    %let descshort=%sysfunc(sasmsg(sashelp.tmine, rpt_text_descshort_vlabel, NOQUOTE));
27996     +
27997     +    data &em_user_graph_table;
27998     +        set &em_user_clusters;
27999     +        label _cluster_="&clusterid"
28000     +              clus_desc="&DescTerms"
28001     +              freq="&Frequency"
28002     +              percent="&Percentage"
28003     +              _rmsstd_="&rmsstd"
28004     +              %do i=1 %to &svdkeep;
28005     +                _mean&i="&Coordinate &i"
28006     +              %end;
28007     +              ;
28008     +        format percent percent10.;
28009     +        desc_short = clus_desc;
28010     +        if COUNTW(clus_desc, ' ') > 5 then do;
28011     +            call scan(clus_desc, 6, position, len, ' ');
28012     +            desc_short=substr(clus_desc, 1, position-1) || '...';
28013     +            drop position len;
28014     +            label desc_short="&descshort";
28015     +        end;
28016     +    run;
28017     +
28018     +    proc sql noprint;
28019     +        create table &em_user_graph_table as
28020     +        select _cluster_, clus_desc, freq, percent, *
28021     +        from &em_user_graph_table;
28022     +    quit;
28023     +
28024     +    %let block = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusters_title, NOQUOTE));
28025     +
28026     +    %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_prescore_title, NOQUOTE));
28027     +    %EM_REPORT(KEY=PRESCORECODE, VIEWTYPE=SOURCE, DESCRIPTION=%nrbquote(&desc),
28028     +              BLOCK=Scoring, AUTODISPLAY=N);
28029     +
28030     +    %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusfreqbyrms_title, NOQUOTE));
28031     +    %EM_REPORT(KEY=GRAPH_TABLE, VIEWTYPE=SCATTER, X=FREQ, Y=_RMSSTD_, DESCRIPTION=%nrbquote(&desc),
28032     +            BLOCK=%nrbquote(&block), AUTODISPLAY=Y, TIP=%if &em_property_nDescTerms > 5 %then desc_short; %else clus_desc;);
28033     +
28034     +    %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusters_title, NOQUOTE));
28035     +    %EM_REPORT(KEY=GRAPH_TABLE, VIEWTYPE=DATA, DESCRIPTION=%nrbquote(&desc), BLOCK=%nrbquote(&block), AUTODISPLAY=Y);
28036     +
28037     +    %if &nclus > 2 %then %do;
28038     +        data work.graph_table(drop=_cluster_);
28039     +            set &em_user_graph_table;
28040     +            cluster=put(_cluster_,best12.);
28041     +        run;
28042     +        proc distance data=work.graph_table out=work.graph_table method=EUCLID nostd;
28043     +            var RATIO(_mean1-_mean&svdkeep);
28044     +            id cluster;
28045     +        run;
28046     +        proc mds data=work.graph_table out=work.graph_table
28047     +            level=ratio dimension=2 noprint;
28048     +        run;
28049     +        data work.graph_table;
28050     +            set work.graph_table;
28051     +            if _name_ ne '';
28052     +            Cluster=input(substr(_name_,2),8.);
28053     +            LABEL dim1='X' dim2='Y';
28054     +        run;
28055     +        proc sql noprint;
28056     +            create table &em_user_graph_table as
28057     +            select a.*, b.dim1, b.dim2
28058     +            from &em_user_graph_table a, work.graph_table b
28059     +            where a._cluster_=b.cluster;
28060     +        quit;
28061     +
28062     +        %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusterdist_title, NOQUOTE));
28063     +        %EM_REPORT(KEY=GRAPH_TABLE, VIEWTYPE=SCATTER, X=DIM1, Y=DIM2, BLOCK=%nrbquote(&BLOCK),
28064     +            DESCRIPTION=%nrbquote(&desc), AUTODISPLAY=Y, TIP=%if &em_property_nDescTerms > 5 %then desc_short; %else clus_desc;,
28065     +            GROUP=_CLUSTER_, LEGEND=N);
28066     +    %end;
28067     +    %else %do;
28068     +        %put &em_codebar;
28069     +        %let errormsg=%sysfunc(sasmsg(sashelp.tmine, EMTOOL.NODISTANCEREPORT_NOTE, NOQUOTE));
28070     +        %put &errormsg;
28071     +        %put &em_codebar;
28072     +    %end;
28073     +
28074     +    %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusterfreq_title, NOQUOTE));
28075     +    %EM_REPORT(KEY=GRAPH_TABLE, VIEWTYPE=PIE, X=_cluster_, Y=freq, DESCRIPTION=%nrbquote(&desc),
28076     +        TOOLTIP=clus_desc, BLOCK=%nrbquote(&block), AUTODISPLAY=Y);
28077     +
28078     +    %if &EM_PROPERTY_ALGORITHM=2.0 %then %do;
28079     +
28080     +        proc sql noprint;
28081     +            create table &em_user_hierds as
28082     +            select level, _cluster_, parent, clus_desc, *
28083     +            from &em_user_hierds;
28084     +        quit;
28085     +        filename temp catalog 'sashelp.emtext.tmsort.source';
28086     +        %include temp;
28087     +        %tmsort(data=&em_user_hierds, out=, by=level parent _cluster_);
28088     +
28089     +        data &em_user_hierds;
28090     +            set &em_user_hierds;
28091     +            label _cluster_="&clusterid"
28092     +                  clus_desc="&descterms"
28093     +                  freq="&frequency"
28094     +                  parent="&parent"
28095     +                  level="&hierlevel"
28096     +                  graphdesc="&graphdesc";
28097     +        run;
28098     +        %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusterhierarchy_title, NOQUOTE));
28099     +        %em_report(viewtype=constellation, linkkey=hierds, nodekey=hierds, method=HIERARCHY,
28100     +            linkfrom=_CLUSTER_,linkto=PARENT,linkid=_cluster_,nodeid=_CLUSTER_,nodesize=FREQ,nodelabel=graphdesc,
28101     +            nodetip=clus_desc, BLOCK=%nrbquote(&block), DESCRIPTION=%nrbquote(&desc), AUTODISPLAY=Y);
28102     +
28103     +        %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_hierarchydata_title, NOQUOTE));
28104     +        %em_report(KEY=hierds, VIEWTYPE=data, DESCRIPTION=%nrbquote(&DESC), AUTODISPLAY=Y, BLOCK=%nrbquote(&BLOCK));
28105     +    %end;
28106     +
28107     +    proc sql noprint;
28108     +        drop table work.graph_table;
28109     +    quit;
28110     +
28111     +%mend report;
28112     +
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(REPORT):  ;
MPRINT(REPORT):  ;
MPRINT(REPORT):  ;
MPRINT(REPORT):  ;
MPRINT(REPORT):  ;
MPRINT(REPORT):   proc sql noprint;
MPRINT(REPORT):   select count(*) into :svdkeep from EMWS5.TextCluster3_svd_s where keep=1;
MPRINT(REPORT):   select count(*) into :nclus from EMWS5.TextCluster3_clusters;
MPRINT(REPORT):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(REPORT):   data EMWS5.TextCluster3_GRAPH_TABLE;
MPRINT(REPORT):   set EMWS5.TextCluster3_clusters;
MPRINT(REPORT):   label _cluster_= "클러스터 ID" clus_desc= "기술 용어" freq= "빈도" percent= "비율" _rmsstd_= "RMS 표준편차" _mean1= "조합 1" _mean2= "조합 2" _mean3= "조합 3" _mean4= "조합 4" _mean5= "조합 5" _mean6= "조합 6" _mean7= "조합 7" _mean8=
"조 합 8" _mean9= "조합 9" _mean10= "조합 10" _mean11= "조합 11" _mean12= "조합 12" _mean13= "조합 13" _mean14= "조합 14" _mean15= "조합 15" _mean16= "조합 16" _mean17= "조합 17" _mean18= "조합 18" _mean19= "조합 19" _mean20= "조합 20" _mean21= "조합 21"
_mean22= "조합 22" _mean23= "조합 23" _mean24= "조합 24" _mean25= "조합 25" _mean26= "조합 26" _mean27= "조합 27" _mean28= "조합 28" _mean29= "조합 29" _mean30= "조합 30" _mean31= "조합 31" _mean32= "조합 32" _mean33= "조합 33" _mean34= "조합 34" _mean35=
"조합 35" _mean36= "조합 36" _mean37= "조합 37" _mean38= "조합 38" _mean39= "조합 39" _mean40= "조합 40" _mean41= "조합 41" _mean42= "조합 42" _mean43= "조합 43" _mean44= "조합 44" ;
MPRINT(REPORT):   format percent percent10.;
MPRINT(REPORT):   desc_short = clus_desc;
MPRINT(REPORT):   if COUNTW(clus_desc, ' ') > 5 then do;
MPRINT(REPORT):   call scan(clus_desc, 6, position, len, ' ');
MPRINT(REPORT):   desc_short=substr(clus_desc, 1, position-1) || '...';
MPRINT(REPORT):   drop position len;
MPRINT(REPORT):   label desc_short= "기술 용어 샘플";
MPRINT(REPORT):   end;
MPRINT(REPORT):   run;
 
NOTE: 6개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER3_GRAPH_TABLE은(는) 6개의 관측값과 50개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.00 초
 
 
MPRINT(REPORT):   proc sql noprint;
MPRINT(REPORT):   create table EMWS5.TextCluster3_GRAPH_TABLE as select _cluster_, clus_desc, freq, percent, * from EMWS5.TextCluster3_GRAPH_TABLE;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 clus_desc이(가) 파일 EMWS5.TEXTCLUSTER3_GRAPH_TABLE에 이미 존재합니다.
WARNING: 변수 _CLUSTER_이(가) 파일 EMWS5.TEXTCLUSTER3_GRAPH_TABLE에 이미 존재합니다.
WARNING: 변수 freq이(가) 파일 EMWS5.TEXTCLUSTER3_GRAPH_TABLE에 이미 존재합니다.
WARNING: 변수 percent이(가) 파일 EMWS5.TEXTCLUSTER3_GRAPH_TABLE에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER3_GRAPH_TABLE created, with 6 rows and 50 columns.
 
MPRINT(REPORT):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   retain id 0;
MPRINT(EM_REPORT):   id + 1;
MPRINT(EM_REPORT):   length VIEW 8 NAME $32 VALUE $400;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "PRESCORECODE";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "SOURCE";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "SAS Prescore 코드";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "Scoring";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46272292568475;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   run;
 
SAS 시스템
 
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 132개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
 
MPRINT(REPORT):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   set WORK.EM_USER_REPORT end=eof;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   if eof then do;
MPRINT(EM_REPORT):   id+1;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "GRAPH_TABLE";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "SCATTER";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "RMS별 클러스터 빈도";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "FREQ";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y";
MPRINT(EM_REPORT):   VALUE = "_RMSSTD_";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "desc_short";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.46964102632815;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   end;
MPRINT(EM_REPORT):   run;
 
NOTE: 132개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 265개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.09 초
 
 
MPRINT(REPORT):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   set WORK.EM_USER_REPORT end=eof;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   if eof then do;
MPRINT(EM_REPORT):   id+1;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "GRAPH_TABLE";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "DATA";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.36790322995181;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   end;
MPRINT(EM_REPORT):   run;
 
NOTE: 265개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 397개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.09 초
 
 
MPRINT(REPORT):  ;
MPRINT(REPORT):   data work.graph_table(drop=_cluster_);
MPRINT(REPORT):   set EMWS5.TextCluster3_GRAPH_TABLE;
MPRINT(REPORT):   cluster=put(_cluster_,best12.);
MPRINT(REPORT):   run;
 
NOTE: 6개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER3_GRAPH_TABLE.에서 읽었습니다.
NOTE: 데이터셋 WORK.GRAPH_TABLE은(는) 6개의 관측값과 50개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(REPORT):   proc distance data=work.graph_table out=work.graph_table method=EUCLID nostd;
MPRINT(REPORT):   var RATIO(_mean1-_mean44);
MPRINT(REPORT):   id cluster;
MPRINT(REPORT):   run;
 
WARNING: Found negative value(s) in the ratio variable(s). The distance matrix may be meaningless.
NOTE: 데이터셋 WORK.GRAPH_TABLE은(는) 6개의 관측값과 7개의 변수를 가지고 있습니다.
NOTE: 프로시저 DISTANCE 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(REPORT):   proc mds data=work.graph_table out=work.graph_table level=ratio dimension=2 noprint;
MPRINT(REPORT):   run;
 
NOTE: Convergence reached in 7 iterations.
NOTE: 데이터셋 WORK.GRAPH_TABLE은(는) 8개의 관측값과 7개의 변수를 가지고 있습니다.
NOTE: 프로시저 MDS 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(REPORT):   data work.graph_table;
MPRINT(REPORT):   set work.graph_table;
MPRINT(REPORT):   if _name_ ne '';
MPRINT(REPORT):   Cluster=input(substr(_name_,2),8.);
MPRINT(REPORT):   LABEL dim1= 'X' dim2= 'Y';
MPRINT(REPORT):   run;
 
NOTE: 8개의 관측값을 데이터셋 WORK.GRAPH_TABLE.에서 읽었습니다.
NOTE: 데이터셋 WORK.GRAPH_TABLE은(는) 6개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(REPORT):   proc sql noprint;
MPRINT(REPORT):   create table EMWS5.TextCluster3_GRAPH_TABLE as select a.*, b.dim1, b.dim2 from EMWS5.TextCluster3_GRAPH_TABLE a, work.graph_table b where a._cluster_=b.cluster;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS5.TEXTCLUSTER3_GRAPH_TABLE created, with 6 rows and 52 columns.
 
MPRINT(REPORT):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   set WORK.EM_USER_REPORT end=eof;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   if eof then do;
MPRINT(EM_REPORT):   id+1;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "GRAPH_TABLE";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "SCATTER";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "클러스터 간 거리";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "DIM1";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y";
MPRINT(EM_REPORT):   VALUE = "DIM2";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "_CLUSTER_";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "desc_short";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.1326837284177;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   end;
MPRINT(EM_REPORT):   run;
 
NOTE: 397개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 530개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.10 초
 
 
MPRINT(REPORT):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   set WORK.EM_USER_REPORT end=eof;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   if eof then do;
MPRINT(EM_REPORT):   id+1;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "GRAPH_TABLE";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "PIE";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "클러스터 빈도";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "_cluster_";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y";
MPRINT(EM_REPORT):   VALUE = "freq";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "clus_desc";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.13469459402127;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   end;
MPRINT(EM_REPORT):   run;
 
NOTE: 530개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 663개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.32 초
      cpu 시간            0.31 초
 
 
MPRINT(REPORT):  ;
MPRINT(REPORT):   proc sql noprint;
MPRINT(REPORT):   drop table work.graph_table;
NOTE: 테이블 WORK.GRAPH_TABLE 을(를) 삭제했습니다.
MPRINT(REPORT):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End REPORT: TextCluster3;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
28113      *------------------------------------------------------------*;
28114      * End REPORT: TextCluster3;
28115      *------------------------------------------------------------*;
 
28116      /* Reset EM Options */
28117      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):    options formchar="|----|+|---+=|-/\<>*";
28118      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
28119      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
28120      proc sort data=WORK.EM_USER_REPORT;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_USER_REPORT;
28121      by ID VIEW;
MPRINT(EM_DIAGRAM):   by ID VIEW;
28122      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 663개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 663개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.03 초
 
 
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
