*------------------------------------------------------------*
사용자:                Administrator
날짜:                2018년 11월 28일
시간:                18시15분08초
사이트:                10503192
플랫폼:            X64_10HOME
관리 릴리스: 9.04.01M4P110916
EM 버전:          14.2
* 
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 28일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "18시14분29초" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 분석 로그";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* 분석 로그
날짜:                2018년 11월 28일
시간:                18시14분29초
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O3DL0Q84 "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O3DL0Q84 new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 28일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "18시14분29초" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "사용자:                Administrator";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "사이트:                10503192";
MPRINT(EM_DIAGRAM):   put "플랫폼:            X64_10HOME";
MPRINT(EM_DIAGRAM):   put "관리 릴리스: 9.04.01M4P110916";
MPRINT(EM_DIAGRAM):   put "EM 버전:          14.2";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 28일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "18시14분29초" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "사용자:                Administrator";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 분석 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 스코어 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 리포트 출력";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
23048      proc freq data=EMWS5.TextCluster5_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS5.TextCluster5_VariableSet noprint;
23049      table ROLE*LEVEL/out=WORK.TextCluster5META;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.TextCluster5META;
23050      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_VARIABLESET.에서 읽었습니다.
NOTE: 데이터셋 WORK.TEXTCLUSTER5META은(는) 1개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 FREQ 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
 
 
23051      proc print data=WORK.TextCluster5META label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.TextCluster5META label noobs;
23052      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
23053      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "역할" LEVEL = "측도 레벨" COUNT = "빈도 개수";
23054      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
23055      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "변수 요약";
MPRINT(EM_DIAGRAM):   run;
23056      run;
 
NOTE: 1개의 관측값을 데이터셋 WORK.TEXTCLUSTER5META.에서 읽었습니다.
NOTE: 출력 결과 (프로시저: PRINT, 페이지: 1)
NOTE: 프로시저 PRINT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
 
23057      title10;
MPRINT(EM_DIAGRAM):   title10;
23058      %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextCluster5: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextCluster5: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'DataMining2018';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'Beekman';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   set EMWS5.TextFilter5_EMINFO;
MPRINT(EM_DIAGRAM):   where key in('HPDMSAMPLE', 'IDSTABLE');
MPRINT(EM_DIAGRAM):   if key = 'HPDMSAMPLE' then call symput('_ForceGrid', '1');
MPRINT(EM_DIAGRAM):   else call symput('_IDS_TABLE', DATA);
MPRINT(EM_DIAGRAM):   run;
MPRINT(HPDM_PERFORMANCE):  ;
PERFORMANCE  DETAILS
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
23372      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
23373      * TextCluster5: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * TextCluster5: Generation of macros and macro variables;
23374      * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
23375      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
 
23376      %let EMEXCEPTIONSTRING=;
23377      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
23378      * TRAIN: TextCluster5;
MPRINT(EM_DIAGRAM):   * TRAIN: TextCluster5;
23379      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
23380      %let EM_ACTION = TRAIN;
23381      %let syscc = 0;
23382      %macro main();
23383
23384         %if %upcase(&EM_ACTION) eq CREATE %then %do;
23385            filename temp catalog 'sashelp.emtxtext.cluster_create.source';
23386            %include temp;
23387            %create();
23388         %end;
23389         %if %upcase(&EM_ACTION) eq TRAIN %then %do;
23390            filename temp catalog 'sashelp.emtxtext.cluster_train.source';
23391            %include temp;
23392            %train();
23393         %end;
23394         %if %upcase(&EM_ACTION) eq REPORT %then %do;
23395            filename temp catalog 'sashelp.emtxtext.cluster_report.source';
23396            %include temp;
23397            %report();
23398         %end;
23399         %if %upcase(&EM_ACTION) eq SCORE %then %do;
23400            filename temp catalog 'sashelp.emtxtext.cluster_score.source';
23401            %include temp;
23402            %score();
23403         %end;
23404      %mend main;
23405
23406      %main();
MPRINT(EM_DIAGRAM):
MPRINT(MAIN):   filename temp catalog 'sashelp.emtxtext.cluster_train.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.CLUSTER_TRAIN.SOURCE입니다.
23407     +%macro train();
23408     +
23409     +    %global last_parse_node last_filter_node last_prescore_node server_err
23410     +      parsevar EM_SASMSG;
23411     +    %if ^%symexist(tm_debug) %then %let tm_debug=0;
23412     +    %let EM_SASMSG=TMINE;
23413     +    %let syscc=0;
23414     +
23415     +    filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
23416     +    %include temp;
23417     +    filename temp catalog 'sashelp.emtxtext.tm_cluster.source';
23418     +    %include temp;
23419     +    filename temp catalog 'sashelp.emtxtext.tm_apply_tmutil.source';
23420     +    %include temp;
23421     +    filename temp catalog 'sashelp.emtxtext.tm_svd_do_samp.source';
23422     +    %include temp;
23423     +    filename temp;
23424     +
23425     +    %tm_get_last_filter(eminfo=&EM_IMPORT_DATA_EMINFO,em_lib=&em_lib,
23426     +                        em_variableset=&em_data_variableset);
23427     +    %if &EMEXCEPTIONSTRING ne %then %goto end_cluster_train;
23428     +    %let lastparsenode=&last_parse_node;
23429     +    %let lastfilternode=&last_filter_node;
23430     +    %let lastprescore=&last_prescore_node;
23431     +    %if &lastfilternode=&lastparsenode %then %do;
23432     +        %let EMEXCEPTIONSTRING = EMTOOL.NOFILTERNODE;
23433     +        %goto end_cluster_train;
23434     +    %end;
23435     +
23436     +    /*populate last tm node dataset so tm_get_last_filter is not called in score*/
23437     +    %em_getname(key=last_tm_nodes, type=data);
23438     +    data &em_user_last_tm_nodes;
23439     +        set &EM_IMPORT_DATA_EMINFO;
23440     +    run;
23441     +
23442     +
23443     +    %em_getname(key=tmconfig, type=data);
23444     +    %em_getname(key=terms, type=data);
23445     +    %em_getname(key=docs, type=data);
23446     +    %em_getname(key=clusters, type=data);
23447     +    %em_getname(key=graph_table, type=data);
23448     +    %em_getname(key=svd_u, type=data);
23449     +    %em_getname(key=tmconfig, type=data);
23450     +    %em_getname(key=svd_s, type=data);
23451     +    %em_getname(key=emoutstat, type=data);
23452     +    %em_getname(key=hierds, type=data);
23453     +
23454     +
23455     +
23456     +    /* get target variable info */
23457     +    %let targetvar = ;
23458     +    data _null_;
23459     +       set &em_data_variableset(where=(ROLE='TARGET' and USE in('Y' 'D')
23460     +                                       and LEVEL ne 'INTERVAL'));
23461     +       if _N_=1 then call symput('targetvar', strip(NAME));
23462     +    run;
23463     +
23464     +
23465     +
23466     +    /* set up terms strings and initial config table */
23467     +    proc sql noprint;
23468     +      create table &EM_USER_tmconfig as
23469     +         select *
23470     +         from &EM_LIB..&last_filter_node._tmconfig;
23471     +    quit;
23472     +
23473     +
23474     +    proc sql noprint;
23475     +       select  cellwgt into: _cellweight
23476     +       from &em_user_tmconfig;
23477     +       select termwgt into: _termwgt
23478     +       from &em_user_tmconfig;
23479     +    quit;
23480     +
23481     +    data _keepdocs (keep=_DOCUMENT_ %if &targetvar ne %then &targetvar; );
23482     +        set &EM_IMPORT_DATA;
23483     +    run;
23484     +
23485     +    %tm_apply_tmutil(data=&EM_LIB..&last_filter_node._tmout,
23486     +                       terms=&EM_LIB..&last_filter_node._terms,
23487     +                       docs=&EM_IMPORT_DATA,
23488     +                       keepdocs=_keepdocs,
23489     +                       reduceF=2,
23490     +                       termweight=&_termwgt,
23491     +                       cellweight=&_cellweight,
23492     +                       outdata=_outtmutil_,
23493     +                       outterms=_newkey,
23494     +                       outweights=_weights,
23495     +                       targetvar=&targetvar,
23496     +                       memloc=_tmmem);
23497     +
23498     +                       /* get the svd dimensions on the documents */
23499     +    %tm_svd_do_samp(data=_outtmutil_,docs=_keepdocs, maxK=&em_property_maxK, res=&em_property_resolution,cellwgt=&_cellweight,in_global=_weights,
23500     +                     rowVar=_termnum_,colVar=_document_,entryVar=_count_,u=&EM_USER_SVD_U,v=_svdv,s=&EM_USER_svd_S,
23501     +                     colpro=_svdcolpro,rowpro=_svdrowpro, normcol=normcol, normrow=normrow,prefix=&EM_NODEID);
23502     +
23503     +    %if(&syscc >4 ) %then %do;
23504     +        %goto end_cluster_train;
23505     +    %end;
23506     +
23507     +    proc sql noprint;
23508     +       create table &EM_USER_TERMS(drop=index) as
23509     +       select a.*,b.*
23510     +       from &EM_LIB..&last_filter_node._terms a left join _svdrowpro b
23511     +       on a.key = b.index;
23512     +    quit;
23513     +
23514     +    %tm_cluster(data=&EM_LIB..&last_filter_node._tmout,
23515     +        terms=&EM_LIB..&last_filter_node._terms,
23516     +        docs=&EM_IMPORT_DATA,
23517     +        svdColPro=_svdcolpro,
23518     +        maxNumTerms=&em_property_ndescterms,
23519     +        numClus=&em_property_nclusters,
23520     +        numType=&em_property_exactormaximum,
23521     +        algorithm=&em_property_algorithm,
23522     +        outdocs=&EM_USER_DOCS,
23523     +        outclusters=&EM_USER_CLUSTERS,
23524     +        hierds=&EM_USER_HIERDS,
23525     +        emoutstat=&EM_USER_emoutstat,
23526     +        prefixstring= &EM_NODEID);
23527     +
23528     +    %if &emexceptionstring ne %then %goto end_cluster_train;
23529     +
23530     +    %if &em_property_algorithm=2.0 %then %do;
23531     +
23532     +        data &em_user_hierds(drop=plus);
23533     +            set &em_user_hierds;
23534     +            plus='';
23535     +            if substr(CLUS_DESC, 1, 1) = "+" then plus="+ ";
23536     +            graphdesc=_CLUSTER_ || ': ' || plus || scan(CLUS_DESC, 1);
23537     +        run;
23538     +    %end;
23539     +
23540     +
23541     +    * add the info to EMINFO to forward on to other nodes ;
23542     +   data &EM_DATA_EMINFO;
23543     +      length TARGET KEY $32 DATA $43;
23544     +
23545     +      key="LastTMNode";
23546     +      data="&EM_NODEID";
23547     +      output;
23548     +
23549     +      key="LastTMNodeType";
23550     +      data="TextCluster";
23551     +      output;
23552     +
23553     +      key="LastTextCluster";
23554     +      data="&EM_NODEID";
23555     +      output;
23556     +
23557     +      key="PRESCORECODE";
23558     +      data="&EM_NODEID";
23559     +      output;
23560     +   run;
23561     +
23562     +    proc sql noprint;
23563     +        select count(*) into :svdkeep
23564     +            from &em_user_svd_s
23565     +            where keep=1;
23566     +        select count(*) into :cluscnt
23567     +            from &em_user_clusters;
23568     +    quit;
23569     +   data &EM_USER_tmconfig;
23570     +         set &EM_USER_TMCONFIG;
23571     +         clus_alg = "&em_property_algorithm";
23572     +         maxsvd = &em_property_maxk;
23573     +         svdkeep=&svdkeep;
23574     +         last_prescore = "&last_prescore_node";
23575     +      run;
23576     +
23577     +    %em_metachange(name=&EM_NODEID._CLUSTER_, role=SEGMENT, level=NOMINAL);
23578     +    %do i=1 %to &svdkeep;
23579     +         %em_metachange(name=&EM_NODEID._SVD&i, role=INPUT, level=INTERVAL);
23580     +    %end;
23581     +    %do i=1 %to &cluscnt;
23582     +         %em_metachange(name=&EM_NODEID._PROB&i, role=REJECTED);
23583     +    %end;
23584     +
23585     +%end_cluster_train:
23586     +    filename temp;
23587     +    %if &tm_debug =0 %then %do;
23588     +        proc sql noprint;
23589     +              drop table _svdcolpro;
23590     +              drop table _svdrowpro;
23591     +              drop table _newkey ;
23592     +              drop table _keepdocs ;
23593     +        quit;
23594     +    %end;
23595     +
23596     +%mend train;
23597     +
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_GET_LAST_FILTER.SOURCE입니다.
23598     +/* ****************************************************************
23599     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
23600     + *
23601     + * Name:             tm_get_last_filter.sas
23602     + * Product:          SAS Text Miner
23603     + * Language:         Sas
23604     + * Script:
23605     + *
23606     + * Usage:
23607     + *
23608     + * Purpose:  macro to get the last filter node and the last parse node in the
23609     + *   diagram that corresponds to the current parse variable.  If there is no filter
23610     + *   node, the filter node is set to the last parse node.
23611     + *
23612     + *
23613     + *
23614     + * History:
23615     + * 14Aug09 Initial Coding
23616     + *
23617     + * Notes:
23618     + *    Returns an error in the following cases:
23619     + *      1. There is no preceding parse node.
23620     + *      2. There is no parse node with the current parse variable.
23621     + *
23622     + * Last Modified By:
23623     + * Last Modified On: Wed Sep 23 15:35:04 2009
23624     + *
23625     + * End
23626     + * ************************************************************** */
23627     +%macro tm_get_last_filter(eminfo=,em_lib=, em_variableset=);
23628     +   %let last_parse_node=;
23629     +   %let last_filter_node=;
23630     +   %let last_prescore_node=;
23631     +   %let server_err=;
23632     +   %let EMEXCEPTIONSTRING=;
23633     +   %let syscc=0;
23634     +
23635     +    /* verify that setinit for SAS Text Miner is currently active */
23636     +    %if %sysfunc(sysprod(PRODNUM107)) ne 1 %then %do;
23637     +       %let EMEXCEPTIONSTRING = EMTOOL.NOTMLICENSE;
23638     +        %goto end_macro;
23639     +        %end;
23640     +
23641     +
23642     +    * find last filter or text parse node if no filter node. ;
23643     +   %if %sysfunc(exist(&eminfo)) %then %do;
23644     +      proc sql noprint;
23645     +      select data into :last_parse_node from &eminfo where key="LastTextParsing";
23646     +         select data into :last_filter_node from &eminfo where key="LastTextFilter";
23647     +         select data into :last_prescore_node from &eminfo where kupcase(key)="PRESCORECODE";
23648     +      quit;
23649     +
23650     +   %end;
23651     +
23652     +   %if &last_parse_node= %then %do;
23653     +      %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGNODE;
23654     +      %goto end_macro;
23655     +      %end;
23656     +
23657     +   %else %if &last_filter_node= %then %let last_filter_node = %ktrim(&last_parse_node);
23658     +   %else %let last_filter_node = %ktrim(&last_filter_node);
23659     +   %let last_parse_node = %ktrim(&last_parse_node);
23660     +
23661     +   * Check to make sure parse variable is present and still exists;
23662     +   %let parsevar = ;
23663     +   proc sql noprint;
23664     +    select parsevar into :parsevar
23665     +    from &em_lib..&last_filter_node._tmconfig;
23666     +    quit;
23667     +
23668     +    *check for dropped parsevar on input dataset;
23669     +       %let parsevarOK= ;
23670     +       %let parsevarN=%kupcase(%ktrim(&parsevar));
23671     +       data _null_;
23672     +         set &em_variableset(where=(kupcase(NAME)="&parsevarN" and USE in('Y' 'D')));
23673     +         if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
23674     +         run;
23675     +       %if(&parsevarOK eq ) %then %do;
23676     +          %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGVAR;
23677     +          %goto end_macro;
23678     +          %end;
23679     +%end_macro:
23680     +
23681     +%mend tm_get_last_filter;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_cluster.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_CLUSTER.SOURCE입니다.
23683     +   /* ****************************************************************
23684     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
23685     + *
23686     + * Name:             tm_cluster.sas
23687     + * Support:          rualbr Russell Albright
23688     + * Product:
23689     + * Language:         Sas
23690     + * Script:
23691     + *
23692     + * Usage:
23694     + !Inputs into %tm_train_cluster
23695     + * doc = doc datset from a tm node
23696     + * data =  out datset from a tm node
23697     + * terms = terms dataset from  tm node
23698     + * svdcolpro = column projections data set
23699     + * cellweight setting
23700     + * termweight setting
23701     + * maxSvddim = Maximum number of dimension to calculate
23702     + * svdres= <HIGH, MED, or LOW>
23703     + * maxNumTerms - maximum number of term to use for descriptive terms
23704     + * numClus = number of clusters to use
23705     + * numType=<MAXIMUM or EXACT> Max means that <= maximum will actually be used.
23706     + * threads = the number of threads you would like emclus to use
23709     + !Outputs from %tm_train_cluster
23710     + * outdocs - a doc table with the cluster restults on it.
23711     + * outclusters- an output cluster table with the descriptive terms on it (future story)
23712     + *
23713     + * Example call
23714     + *
23715     + *%tm_cluster(data=tmn.text_out_t,
23716     + *             terms=tmn.terms,
23717     + *             docs=testdata._train,
23718     + *             svdcolpro=tmn._svdcolpro,
23719     + *             maxNumTerms=5,
23720     + *             numClus=40,
23721     + *             numType=MAXIMUM,
23722     + *             outdocs=docsresult,
23723     + *             hierds=_hierds,
23724     + *             emoutstat=_emoutstat,
23725     + *             outclusters= clusterResult);
23726     + *
23727     + *
23728     + * Purpose: Perform the clustering on out,term, doc from parse or filter node
23729     + *
23730     + * History:
23731     + *
23732     + *
23733     + * Notes:
23734     + *
23735     + * Last Modified By:
23736     + * Last Modified On: Thu Jan 08 17:22:43 2009
23737     + *
23738     + * End
23739     + * ************************************************************** */
23741     +%macro tm_cluster(data=,
23742     +                     terms=,
23743     +                     docs=,
23744     +                     svdColPro=,
23745     +                     maxNumTerms=,
23746     +                     numClus=,
23747     +                     numType=MAXIMUM,
23748     +                     algorithm=,
23749     +                     outdocs=,
23750     +                     hierds=_hierds,
23751     +                     emoutstat=_emoutstat,
23752     +                     outclusters=,
23753     +                     prefixString=,
23754     +                     threads=);
23757     +    %local _cleanedout ;
23758     +    %local _numRepDocs;
23759     +    %global systmutil;
23760     +    %let systmutil = ;
23761     +    %if ^%symexist(tm_debug) %then %let tm_debug=0;
23763     +    filename temp catalog 'sashelp.emtext.tmgetncl.source';
23764     +    %include temp;
23765     +    filename temp catalog 'sashelp.emtext.tmfast.source';
23766     +    %include temp;
23768     +    filename temp catalog 'sashelp.emtext.tmemclus.source';
23769     +    %include temp;
23771     +    filename temp catalog 'sashelp.emtext.tmpred.source';
23772     +    %include temp;
23774     +    filename temp catalog 'sashelp.emtext.tmsort.source';
23775     +    %include temp;
23777     +    %let tmdata=&data;
23778     +    %let tmterms=&terms;
23779     +    %let tmdocs=&docs;
23780     +    %let emexceptionstring=;
23783     +    /* check some basic size requirements to proceed.*/
23784     +    proc sql noprint;
23785     +       select count(*) into: numTerms
23786     +       from &terms a
23787     +       where a.numdocs>=2 and _ispar in('+',' ')
23788     +       ;
23789     +       select count (*) into: numdocs
23790     +       from &docs a;
23791     +    quit;
23793     +    %if (&numterms < 10)  OR (&numdocs< 8) %then %do;
23794     +        %let emexceptionstring=EMTOOL.INSUFFICIENTDATA;
23795     +        %goto end_train_cluster;
23796     +    %end;
23798     +    /* Get number of kept svd variables */
23799     +    %let pid = %sysfunc(open(&svdcolpro));
23800     +    %let svdkeep=%eval(%sysfunc(attrn(&pid,nvars))-1);
23801     +    %let rc = %sysfunc(close(&pid));
23804     +   /************************ Find clusters *************************************/
23806     +   %if %upcase(&numType) = MAXIMUM %then %do;   /* numClus = MAXIMUM */
23808     +      /* Call tmgetncl to find the recommended number of clusters. */
23810     +      %tmGetNcl(data=&svdcolpro,
23811     +               maxclusters=&numClus,
23812     +               vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep),
23813     +               tempDS=_clusTemp1,
23814     +               clusDS=_clusTemp,
23815     +               threads=
23816     +            );
23818     +      /* error returned in above macro */
23819     +      %if (&syscc >4 ) %then %do;
23820     +         %let emexceptionstring= &SYSERRORTEXT;
23821     +         %goto end_train_cluster;
23822     +      %end;
23824     +      /* Store the recommended number into a macro variable. */
23826     +      proc sql noprint;
23827     +         select max(nclus) into: numClus
23828     +         from _clusTemp
23829     +         ;
23830     +      quit;
23833     +      %if not (&numClus > 1) %then %do;
23834     +        %let numClus = 2;
23835     +      %end;
23838     +       %if &tm_debug =0  %then %do;
23839     +          proc sql nowarn noprint;
23840     +              drop table _clustemp;
23841     +              drop table _clustemp1;
23842     +           quit;
23843     +       %end;
23845     +   %end;  /* &numtype = MAXIMUM */
23847     +   %else  %do;
23848     +       %let numClus = %left(&numClus);/*&numtype=EXACT*/
23849     +   %end;
23851     +    proc sql noprint;
23852     +        select count(*) into: nobs
23853     +        from &svdcolpro;
23854     +    quit;
23856     +   %if %left(&algorithm)=2.0 %then %do; /* Hierarchical clustering */
23857     +        filename temp catalog 'sashelp.emtxtext.tmgethclus.source';
23858     +        %include temp;
23860     +        filename temp catalog 'sashelp.emtext.tmhclus.source';
23861     +        %include temp;
23862     +        filename temp catalog 'sashelp.emtext.tmtree.source';
23863     +        %include temp;
23865     +        %if &nobs < &numClus and  %upcase(&numType) = EXACT %then %do;
23866     +            %let emexceptionstring=EMTOOL.TOOFEWOBSTOCLUS;
23867     +            %goto end_train_cluster;
23868     +        %end;
23870     +        %tmgethclus(outtree=_outtree,
23871     +                    idvar=index,
23872     +                    inDS=&svdcolpro,
23873     +                    outDS=&outdocs,
23874     +                    fastOut=_fastclusstat,
23875     +                    textClusDS=_clusstat,
23876     +                    vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep),
23877     +                    nobs=&nobs,
23878     +                    nclus=&numClus,
23879     +                    hierds=&hierds,
23880     +                    svdkeep=&svdkeep,
23881     +                    prefix=&prefixString);
23882     +        %if &EMEXCEPTIONSTRING ne %then %goto end_train_cluster;
23884     +        data _clusstat;
23885     +            set _clusstat(rename=(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep.=_mean1-_mean&svdkeep.));
23886     +        run;
23888     +        data _clustermean;
23889     +          set _clusstat(keep=_cluster_ _mean1-_mean&svdkeep. rename=(_cluster_=cluster));
23890     +        run;
23892     +        proc sql noprint;
23893     +            drop table _outtree;
23894     +        quit;
23895     +   %end;
23896     +   %else %do; /* Expectation-maximization */
23897     +       /* Call %anl_tmfast to create cluster stat data set that will be used as an input for %anl_tmemclus. */
23898     +          %tmFast(data=&svdcolpro,
23899     +             clusters=&numClus,
23900     +             outstat=_fastclusstat,
23901     +             outseed=,
23902     +                id=,
23903     +             out=,
23904     +             vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep)
23905     +             );
23906     +          run;
23908     +          /* If some of the clusters are too small (frequency less than 5) and &g_numClusFlag=MAXIMUM, */
23909     +          /* reassign value for &cluster macro var from WORK.&s_reportID._fastclusstat data set. */
23911     +       %if %upcase(&numType) = MAXIMUM %then
23912     +       %do;   /* &ClusType = MAXIMUM */
23914     +          proc sql noprint;
23915     +             select max(CLUSTER) into :numClus
23916     +             from _fastclusstat
23917     +             where upcase(_TYPE_)='SEED'
23918     +             ;
23919     +          quit;
23921     +          %let numClus = %left(&numClus);
23923     +       %end;  /* &ClusType = MAXIMUM */
23924     +       %else %do; /* &ClusType = EXACT */
23925     +          %if &nobs < &numClus %then %do;
23926     +            %let emexceptionstring=EMTOOL.TOOFEWOBSTOCLUS;
23927     +            %goto end_train_cluster;
23928     +          %end;
23929     +       %end;
23931     +       %tmEMClus(data=&svdcolpro,
23932     +                role=TRAIN,
23933     +                clusters=&numClus,
23934     +                seed=_fastclusstat,
23935     +                outstat=&emoutstat,
23936     +                out=_tmutildoc,
23937     +                vars=%str(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep),
23938     +                cov=,
23939     +                iter=5,
23940     +                secclus=,
23941     +                seciter=,
23942     +                min=,
23943     +                method=,
23944     +                eps=.1,
23945     +                init=FASTCLUS,
23946     +                print=NONE,
23947     +                p=,
23948     +                outliers=,
23949     +                decvar=0,
23950     +                initstd=,
23951     +                dist=,
23952     +                secstd=,
23953     +                nobs=,
23954     +                threads=&threads.
23955     +             );
23956     +       run;
23959     +       /* Run %anl_tmpred macro to assign documents to clusters with the largest posterior probability */
23960     +       /* and to calculate cluster frequency. */
23962     +       %tmPred (inds=_tmutildoc,
23963     +                outds=&outdocs,
23964     +              clusters=&numClus,
23965     +              type=max,
23966     +              freqds=_clusstat,
23967     +              compress=1
23968     +              );
23969     +        data &outdocs;
23970     +           set &outdocs;
23971     +           rename prob1-prob&numClus = &prefixString._prob1-&prefixString._prob&numclus;
23972     +        run;
23976     +       /* Transpose the output data set to contain cluster ID and cluster frequency. */
23978     +        data _clusstat;
23979     +            array c(&numClus) _c1-_c&numClus;
23980     +            set _clusstat;
23981     +            /*keep _CLUSTER_ Freq;*/
23982     +            totalobs=0;
23983     +            do _CLUSTER_ = 1 to &numClus;
23984     +                Freq = c(_CLUSTER_);
23985     +                totalobs=totalobs+c(_CLUSTER_);
23986     +                output;
23987     +            end;
23988     +            call symput ('totNumDocs', totalobs);
23989     +        run;
23991     +       %if &totNumDocs = 0 %then
23992     +       %do;   /*&totNumDocs = 0 */
23993     +           goto end_train_cluster;
23994     +       %end; /*&totNumDocs = 0 */
23996     +       /* Calculate cluster percentage. */
23997     +       data _clusstat;
23998     +          set _clusstat;
23999     +          Percent = Freq/&totNumDocs;
24000     +       run;
24002     +       data _clustermean(rename=(&prefixstring._SVD1 - &prefixstring._SVD&svdkeep. = _mean1-_mean&svdkeep.));
24003     +          set &emoutstat(keep=cluster _TYPE_ &prefixstring._SVD1 - &prefixstring._SVD&svdkeep.);
24004     +          if _TYPE_ = "MEAN";
24005     +            keep cluster &prefixstring._SVD1 - &prefixstring._SVD&svdkeep. ;
24006     +      run;
24007     +  %end;
24009     +      proc sql;
24010     +      create table _meandocs(drop=cluster) as
24011     +      select a.*, b.*
24012     +      from &outdocs a left join _clustermean b
24013     +      on a._cluster_=b.cluster
24014     +      ;
24015     +      quit;
24016     +       /*calulate residual for each doc */
24017     +      data _rmscalc;
24018     +          merge _meandocs(in=inhere) _clusstat;
24019     +          array _means(&svdkeep) _mean1-_mean&svdkeep.;
24020     +          array _svds(&svdkeep) &prefixstring._SVD1 - &prefixstring._SVD&svdkeep.;
24021     +          by _cluster_;
24022     +          error=0;
24023     +          do i = 1 to &svdkeep;
24024     +             error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
24025     +          end;
24026     +         /*error=sqrt(error);*/
24027     +          drop i;
24028     +       run;
24029     +    /*calc standardized residual for clusters*/
24030     +       proc summary data=_rmscalc nway;
24031     +          class _cluster_;
24032     +          var error;
24033     +          output out=_meanerr mean=meane sum=sume;
24034     +       run;
24036     +       data _rmsse;
24037     +          set _meanerr;
24038     +          /* original code divides by number of svd dims*/
24039     +          if _freq_ gt 1 then do;
24040     +              _rmsstd_=sqrt(sume/((_freq_-1)*(&svdkeep.)));
24041     +          end;
24042     +          else do;
24043     +              _rmsstd_=0;
24044     +          end;
24045     +          keep _cluster_  _rmsstd_;
24046     +       run;
24049     +       proc sql;
24050     +           create table _clusstat2(drop=cluster) as
24051     +           select a.*,b.*
24052     +           from _clustermean a left join _rmsse b
24053     +           on a.cluster=b._cluster_;
24055     +           create table &outclusters as
24056     +           select  a.*, b.freq, b.percent
24057     +           from _clusstat2(keep=_cluster_ %str(_mean1-_mean&svdkeep) _rmsstd_) a right join _clusstat b
24058     +           on a._cluster_=b._cluster_
24059     +           where b.freq>0 ;
24060     +       quit;
24063     +    filename temp catalog 'sashelp.emtext.tmterm1.source';
24064     +    %include temp / nosource2;
24066     +   /****************** Find descriptive terms for clusters ***************************/
24069     +   /* Add _term_ variable to WORK._terms data set to prepare it as an
24070     +   /* input to %tmterm1 macro. The variable is added from &EM_LIB..&last_filter_node._terms data set. */
24072     +   proc sort data=&tmterms out=_terms_;
24073     +        by key _ispar;
24074     +   run;
24076     +   data _terms_;
24077     +       set _terms_;
24078     +       by key _ispar;
24079     +       if first.key then
24080     +          output;
24081     +       else;
24082     +   run;
24084     +    /* Concatenate + to terms */
24085     +    data _terms_;
24086     +        set _terms_;
24087     +        if _ispar='+' then
24088     +            Term=_ispar || ' ' || term;
24089     +    run;
24091     +   %tmsort(data=&tmdata,
24092     +         out=_tmout_,
24093     +         by=_termnum_,
24094     +            options=,
24095     +         threads=threads);
24098     +   data _tmout_;
24099     +      merge _tmout_ (in=_A_)
24100     +            _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
24101     +      by _termnum_;
24102     +      if _A_;
24103     +   run;
24105     +   /* Create _segmnt_ variable in WORK._docs data set to prepare it to be an */
24106     +   /* input to %tmterm1 macro. Set it equal to _cluster_ variable. */
24108     +   %if &algorithm=2.0 %then %do;
24109     +        data _docs_;
24110     +            set &outdocs (rename=(index=_document_) keep=index _cluster_ _finalcluster_);
24111     +            _SEGMNT_=_finalcluster_;
24112     +        run;
24113     +        proc sql noprint;
24114     +            select max(_cluster_) into :numclus from &outclusters;
24115     +        quit;
24116     +   %end;
24117     +   %else %do;
24118     +       data _docs_;
24119     +        set &outdocs (rename=(index=_document_) keep=index _cluster_);
24120     +         _SEGMNT_=_cluster_;;
24121     +       run;
24123     +   %end;
24125     +   /* Run %tmterm1 macro to determine descriptive terms for clusters. */
24126     +   %tmterm1(DSN_TPARS=_tmout_,
24127     +        DSN_CLUS=_docs_,
24128     +        DSN_DESC=_desc_,
24129     +        N_DESC_TERMS=&maxnumterms,
24130     +        N_CLUS=&numclus,
24131     +        top_freq=%eval(&maxnumterms*2),
24132     +        key=);
24134     +    /* Add cluster descriptive terms to clusters table. */
24135     +   %tmsort(data=&outclusters,
24136     +         out=&outclusters,
24137     +         by=_cluster_,
24138     +            options=,
24139     +         threads=threads);
24141     +   %tmsort(data=_desc_,
24142     +         out=_desc_,
24143     +         by=_cluster_,
24144     +            options=,
24145     +         threads=threads);
24147     +   data _desc_;
24148     +      merge &outclusters _desc_;
24149     +      by _cluster_;
24150     +   run;
24152     +   %tmsort(data=_desc_,
24153     +         out=&outclusters,
24154     +         by=_cluster_,
24155     +            options=,
24156     +         threads=threads);
24158     +   %if &algorithm=2.0 %then %do;
24160     +        %tmsort(data=&HIERDS,
24161     +         out=&HIERDS,
24162     +         by=_cluster_,
24163     +            options=,
24164     +         threads=threads);
24166     +        data &HIERds;
24167     +            merge &outCLUSTERS &HIERds (keep=_cluster_ parent level in=P);
24168     +            by _cluster_;
24169     +            clust=_cluster_;
24170     +            drop _cluster_;
24171     +            if P;
24172     +        run;
24174     +        %let empty=1;
24176     +        /* Be sure that all parent clusters are on outclusters ds */
24177     +        proc sql noprint;
24178     +            create table &outclusters as
24179     +                select a._cluster_, b.* from &hierds (rename=(clust=_CLUSTER_)) a
24180     +                left join &outclusters b
24181     +                on a._cluster_=b._cluster_;
24182     +        quit;
24184     +        %do %while (&empty);
24185     +            proc sql noprint;
24186     +                update &outclusters set freq=
24187     +                    (select sum(freq) from &HIERDS
24188     +                    where parent=_cluster_), percent=
24189     +                    (select sum(percent) from &HIERDS
24190     +                    where parent=_cluster_)
24191     +                    where freq=. and _cluster_ not in
24192     +                    (select parent from &hierds where freq=.);
24193     +                select count(*) into :empty from &outclusters
24194     +                    where freq=.;
24195     +                update &hierds set freq=(select freq from &outclusters where _cluster_=clust);
24196     +            quit;
24197     +            data &HIERds;
24198     +                merge &OUTCLUSTERS &HIERds (
24199     +                    rename=(clust=_cluster_) keep=clust parent level in=P);
24200     +                by _cluster_;
24201     +                clust=_cluster_;
24202     +                drop _cluster_;
24203     +                if P;
24204     +            run;
24205     +        %end;
24207     +        data &hierds;
24208     +            set &hierds(rename=(CLUST=_CLUSTER_) keep=clust FREQ CLUS_DESC PARENT level);
24209     +        run;
24210     +        data &outclusters;
24211     +            set &outclusters;
24212     +            if _rmsstd_ ne .;
24213     +        run;
24215     +        data &outdocs;
24216     +            set &outdocs (drop=_FINALCLUSTER_ _SUBCLUSTER_);
24217     +            label _CLUSTER_=Cluster ID;
24218     +        run;
24220     +    %end;
24222     +   %end_train_cluster:
24224     +       filename temp;
24226     +       %if &tm_debug =0  %then %do;
24227     +          proc sql nowarn noprint;
24228     +              drop table _clusstat;
24229     +              drop table _clusstat2;
24230     +              drop table _fastclusstat;
24231     +              drop table _clustermean;
24232     +              drop table _meandocs;
24233     +              drop table _rmscalc;
24234     +              drop table _rmsse;
24235     +              drop table _meanerr;
24236     +              drop table _tmutildoc;
24237     +              drop table _desc_;
24238     +              drop table _terms_;
24239     +              drop table _docs_;
24240     +              drop table _tmout_;
24241     +           quit;
24242     +       %end;
24245     +%mend;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_apply_tmutil.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_APPLY_TMUTIL.SOURCE입니다.
24247     + /*****************************************************************
24248     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
24249     + *
24250     + * Name:             tm_apply_tmutil.sas
24251     + * Support:          rualbr Russell Albright
24252     + * Product:
24253     + * Language:         Sas
24254     + * Script:
24255     + *
24256     + * Usage:
24257     + *
24258     + * data= out data set from tgparse
24259     + * terms= terms from tgparse
24260     + * offsets=  addoffset data set form tgparse
24261     + * docs=  data set of document id's and potentially target, not required unless target weighting is used.
24262     + * keepdocs= list of docs to keep. This is a subset of the original docs data set. Not required.
24263     + * reduceF=defaults to log(n) if not specified, eliminates terms if not in at least that many docs
24264     + *     use reduceF=1 to retain all terms.
24265     + * termweight= none, entropy, mi,
24266     + * cellweight= none, log, bin,
24267     + * synnum= Input synonym data set of _termnum_, parent ID pairs
24268     + * synchar= Input synonym data set of term,termrole, parent, parentrole. This data set will
24269     + * get converted to synnym format by the macro tm_convert_syns.
24270     + * targetvar= name of variable on doc dataset contining targetvar.
24271     + * outdata= output out dataset with no more children on this dataset
24272     + * outterms= output terms dataset with dup terms eliminated
24273     + * outweights= weight vector for the terms
24274     + * outoffsets= subsetted outtable with childterms replaced with parents
24275     + * applyweight = , indicates if the weight settings are to be applied to the output OUT table. 0 no, 1 yes.
24276     + * memloc= string for tmutil to use to store its memory pointer. Normally the default can just be used.
24277     + * keeponly=Y  If set to Y (default), then only kept terms are output in terms table.
24278     + *
24279     + * Purpose: Massage the out and key from docparse so that they can bes used
24280     + * in data mining applications.
24281     + *
24282     + * History:
24283     + *
24284     + * Notes:
24285     + *
24286     + * Last Modified By:
24287     + * Last Modified On: Tue Mar 05 16:32:57 2013
24288     + *
24289     + * End
24290     + * ************************************************************** */
24293     +%macro tm_apply_tmutil(data=, terms=,docs=,offsets=,keepdocs=,termweight=none,
24294     +                            cellweight=none,reduceF=,outdata=,outterms=,outweights=,
24295     +                            outoffsets=, synnum=,synchar=, targetvar=, applyweight = 0,
24296     +                            memloc=tmutil_loc,keeponly=Y,repOnly=N);
24297     +     %local keepdocs tempF reduceF synnum  terms  paraExist sentExist;
24300     +    %let EMEXCEPTIONSTRING=;
24301     +    %let syscc=0;
24302     +    %let systmutil=0;
24306     +    /* Find terms to drop */
24307     +        %if &keepdocs ne %then %do;
24308     +          proc sql noprint;
24309     +                create view _keepdata as
24310     +                select * from &data where _DOCUMENT_ in
24311     +                (select _DOCUMENT_ from &keepdocs);
24312     +          quit;
24313     +        %end;
24314     +          %else %do;
24316     +             proc sql noprint;
24317     +                 create view _keepdata as
24318     +                 select * from &data;
24319     +             quit;
24321     +           %let keepdocs=&docs;
24322     +        %end;
24325     +    /* set default on reduceF*/
24326     +         %if &reduceF = %then %do;
24327     +            proc sql noprint;
24328     +           select count(*) into :numdocs from &docs;
24329     +        quit;
24330     +        %let tempF = %sysfunc(log10(%eval(&numdocs+1)));
24331     +        %let reduceF= %sysfunc(floor(&tempF));
24332     +         %end;
24335     +    /* find synnum if synchar supplied */
24337     +    %if &synchar ne %then %do;
24338     +            filename temp catalog 'sashelp.emtxtext.tm_convert_syns.source';
24339     +            %include temp;
24340     +            %tm_convert_syns(insyns= &synchar, outsyns=_myOutsyns ,
24341     +                         interms=&terms,
24342     +                          outterms=newterms );
24343     +                %let numsyns=0;
24344     +                proc sql;
24345     +                   select count(*) into: numsyns
24346     +                   from _myOutsyns;
24347     +                quit;
24348     +                %if &numsyns >0 %then %do;
24349     +                   %Let synnum=_myOutsyns;
24350     +                   %let terms=newterms;
24351     +                %end;
24352     +    %end;
24353     +    /* get the out and key in the proper format*/
24354     +    proc tmutil data=_keepdata key= &terms doc=&keepdocs
24355     +        %if &targetvar ne %then target=&targetvar;
24356     +        ;
24357     +        control init memloc="&memloc";
24358     +            %if &synnum ne %then syn syndata=&synnum force;
24359     +         ;
24360     +    run;
24361     +    %if &syscc >4 %then %goto end_tm_apply_tmutil;
24362     +    %if &reduceF>1 %then %do;
24363     +           proc tmutil;
24364     +           control memloc="&memloc";
24365     +               select reduceF=&reduceF;
24366     +        run;
24367     +   %end;
24368     +    %if &syscc >4 %then %goto end_tm_apply_tmutil;
24370     +     proc tmutil;
24371     +        control memloc="&memloc" release;
24372     +        weight termwgt=&termweight cellwgt=&cellweight;
24373     +            output key=_termstmutil  keyformat=default
24374     +               %if &keeponly eq Y %then keeponly;
24375     +               %if &applyweight  eq 0 %then unweighted ;
24376     +               out=&outdata;
24377     +    run;
24378     +    %if &syscc >4 %then %goto end_tm_apply_tmutil;
24380     +    proc sql noprint;
24381     +           create table _distinctterms as
24382     +           select distinct key,term, role, attribute
24383     +           from &terms;
24385     +       create table &outterms as
24386     +       select  b.term, b.role,b.attribute ,a.*
24387     +       from _termstmutil a left join  _distinctterms b
24388     +       on a.key=b.key;
24389     +       ;
24390     +       %if &outweights ne %then %do;
24391     +          create table &outweights as
24392     +          select distinct a.key as index, a.weight as gwgt
24393     +          from &outterms(where=(_ispar in('+',' '))) a inner join
24394     +                         _distinctterms b
24395     +          on a.key =b.key;
24396     +       %end;
24398     +     quit;
24399     +     %if &offsets ne and &outoffsets ne %then %do;
24401     +        %let paraExist=0; %let sentExist=0;
24402     +        data _null_;
24403     +          dsid=open("&offsets");
24404     +          para=varnum(dsid,'_paragraph_');
24405     +          sent=varnum(dsid,'_sentence_');
24406     +          if para ge 1 then call symput('paraExist',1);
24407     +          if sent ge 1 then call symput('sentExist',1);
24408     +          run;
24411     +        proc sql noprint;
24412     +        create table &outoffsets as
24413     +           select  a._document_,
24414     +              %if &paraExist=1 %then a._paragraph_, ;
24415     +              %if &sentExist=1 %then a._sentence_,;
24416     +              a._offset_, a._length_, b.parent_id as _termnum_
24417     +                 from &offsets a, _termstmutil (where=(_ispar ne "+" and keep="Y")) b
24418     +                 where a._termnum_ = b.key;
24419     +              quit;
24420     +       %end;
24424     +     %end_tm_apply_tmutil:
24426     +     %if ^%symexist(tm_debug) %then %let tm_debug=0;
24427     +       %if &tm_debug =0  %then %do;
24428     +          proc sql noprint;
24429     +            drop table _termstmutil;
24430     +            drop table _distinctterms;
24431     +            drop view _keepdata;
24432     +            %if &synchar ne and &synnum ne  %then drop table &synnum; ;
24433     +         quit;
24434     +     %end;
24435     +     %if &syscc >4 and &systmutil > 4 %then %do;
24436     +           %let EMEXCEPTIONSTRING = EMTOOL.TMUTIL,&systmutil;
24437     +           %put emexceptionstring= "&EMEXCEPTIONSTRING";
24438     +           %let syscc=0;
24439     +     %end;
24441     +%mend;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emtxtext.tm_svd_do_samp.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_SVD_DO_SAMP.SOURCE입니다.
24443     +   /* ****************************************************************
24444     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
24445     + *
24446     + * Name:             tm_svd_do_samp.sas
24447     + * Product:
24448     + * Language:         Sas
24449     + * Script:
24450     + *
24451     + * Usage:
24452     + *
24453     + * data=out dataset containing only repreentative terms
24454     + * maxK= max number of dimensions to use to computer svd
24455     + * res=<high, med, low> guidenceon what number of dims to choose
24456     + * cellwgt= <none, log, binary>
24457     + * in_global= dataset with index, weight variables
24458     + * rowVar= name of the variable representing row(term)
24459     + * colVar= name of the variable representing col
24460     + * entryVar=count for row,col
24461     + * u= name of output u matrix
24462     + * v= name of output v matrix
24463     + * s= name of output s matrix
24464     + * colpro=dataset to hold projections for terms
24465     + * rowpro= datset to hold projections for docs
24466     + * normcol=<normcol> extra option to add to normalize docs
24467     + * normrow=<normrow> extra option to add to normalize terms
24468     + * docs =<document data set of ids that are being analyzed.
24469     +*      docs needs to be input explicit since some docs may have not terms
24470     + *
24471     + * Purpose: macro to run svd and compute projections, first without mpling
24472     + * and then with sampling onon.
24473     + *
24474     + * History:
24475     + *
24476     + * Notes:
24477     + *
24478     + * Last Modified By:
24479     + * Last Modified On: Thu Jan 08 17:22:43 2009
24480     + *
24481     + * End
24482     + * ************************************************************** */
24483     +%macro tm_svd_do_samp(data=,docs=,maxK=,res=,cellwgt=,in_global=,
24484     +                     rowVar=,colVar=,entryVar=,u=,v=,s=,
24485     +                     colpro=,rowpro=,normcol=, normrow=,prefix=SVD);
24487     +   %local svdkeep;
24488     +   %let syscc=0;
24489     +   proc sort data=&data; by _termnum_; run;
24491     +   proc spsvd data=&data max_k = &maxK res = &res
24492     +       local = &cellWgt global =none in_global = &in_global;
24493     +       row _termnum_;
24494     +       col _document_;
24495     +       entry _count_;
24496     +       output  u = &U v = &V s = &s;
24497     +   run;
24499     +   /*try sampling if out of memory occurred*/
24500     +   %if(&syscc eq 1111) %then %do;
24501     +      %let syscc=0; /*reset syscc*/
24502     +      proc spsvd data = &data max_k = &maxK res = &res
24503     +          local = &cellWgt global = none in_global = &in_global ;
24504     +          row &rowVar;
24505     +          col &colVar;
24506     +          entry &entryVar;
24507     +          output u = &U v = &V s = &s;
24508     +          sample allow;
24509     +      run;
24510     +   %end;
24511     +    %if &syscc > 4 %then %do;
24512     +       %let EMEXCEPTIONSTRING = EMTOOL.SPSVDERROR;
24513     +       %goto end_svd_do_samp;
24514     +    %end;
24517     +   /* if resolution is used, the matrix U/V must be truncated to the set number of dim.*/
24518     +   proc sql noprint;
24519     +       select count(*) into: svdkeep
24520     +       from &s
24521     +       where keep=1;
24522     +    quit;
24524     +    %let svdkeep=%left(&svdkeep);
24525     +    data &U;
24526     +    set &U(keep= index col1-col&svdkeep);
24527     +    run;
24529     +    data &V;
24530     +    set &V(keep= index col1-col&svdkeep);
24531     +    run;
24532     +    %if &colpro ne %then %do;
24533     +       /* when sampling weights may have wrong dimensions*/
24534     +       proc sql noprint;
24535     +          create table new_global as
24536     +             select a.*
24537     +             from &in_global a, &U b
24538     +             where a.index = b.index;
24539     +       quit;
24542     +        proc sort data=&data; by &colVar; run;
24543     +        proc spsvd data=&data IN_U=&U
24544     +            local = &cellWgt global = none in_global = new_global ;
24545     +            row &rowVar;
24546     +            col &colVar;
24547     +            entry &entryVar;
24548     +            output colpro=&colpro bigpro normcol prefix="&prefix._SVD";
24549     +        run;
24551     +        proc sort data=&docs(keep=_document_)  out=_docids;
24552     +        by _document_;
24553     +        run;
24555     +        data &colpro;
24556     +           merge &colpro _docids(rename=(_document_=index));
24557     +        by index;
24558     +        run;
24561     +        data &colpro;
24562     +          set  &colpro;
24563     +          array svd_array &prefix._SVD1 - &prefix._SVD&SVDKEEP;
24564     +          do i = 1 to dim(svd_array);
24565     +             if svd_array(i)=. then svd_array(i)=0;
24566     +          end;
24567     +          drop i;
24568     +        run;
24569     +    %end;
24571     +    %if &syscc > 4 %then %do;
24572     +       %let EMEXCEPTIONSTRING = EMTOOL.SPSVDERROR;
24573     +       %goto end_svd_do_samp;
24574     +    %end;
24576     +    %if &rowpro ne %then %do;
24577     +        proc sort data=&data; by &rowVar; run;
24578     +        /* when sampling weights may have wrong dimensions*/
24579     +       proc sql;
24580     +          create table new_global as
24581     +             select a.*
24582     +             from &in_global a, &U b
24583     +             where a.index = b.index;
24584     +       quit;
24586     +        proc spsvd data=&data IN_V=&V
24587     +            local = &cellWgt global = none in_global = new_global ;
24588     +            row &rowVar; col &colVar; entry &entryVar;
24589     +            output wordPro = &rowpro bigpro normrow prefix="&prefix._SVD";
24590     +        run;
24591     +    %end;
24593     +    %if &syscc > 4 %then %do;
24594     +       %let EMEXCEPTIONSTRING = EMTOOL.SPSVDERROR;
24595     +       %goto end_svd_do_samp;
24596     +    %end;
24598     +   %end_svd_do_samp:
24600     +%mend;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TRAIN):   filename temp;
NOTE: Fileref TEMP을(를) 삭제했습니다.
MPRINT(TM_GET_LAST_FILTER):   * find last filter or text parse node if no filter node. ;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select data into :last_parse_node from EMWS5.TextFilter5_EMINFO where key="LastTextParsing";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_filter_node from EMWS5.TextFilter5_EMINFO where key="LastTextFilter";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_prescore_node from EMWS5.TextFilter5_EMINFO where kupcase(key)="PRESCORECODE";
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GET_LAST_FILTER):   * Check to make sure parse variable is present and still exists;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select parsevar into :parsevar from EMWS5.TextFilter5_tmconfig;
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GET_LAST_FILTER):   *check for dropped parsevar on input dataset;
MPRINT(TM_GET_LAST_FILTER):   data _null_;
MPRINT(TM_GET_LAST_FILTER):   set EMWS5.TextCluster5_VariableSet(where=(kupcase(NAME)="REVIEW" and USE in('Y' 'D')));
MPRINT(TM_GET_LAST_FILTER):   if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
MPRINT(TM_GET_LAST_FILTER):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_VARIABLESET.에서 읽었습니다.
      WHERE (KUPCASE(NAME)='REVIEW') and USE in ('D', 'Y');
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data EMWS5.TextCluster5_last_tm_nodes;
MPRINT(TRAIN):   set EMWS5.TextFilter5_EMINFO;
MPRINT(TRAIN):   run;
 
NOTE: 6개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_EMINFO.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_LAST_TM_NODES은(는) 6개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   set EMWS5.TextCluster5_VariableSet(where=(ROLE='TARGET' and USE in('Y' 'D') and LEVEL ne 'INTERVAL'));
MPRINT(TRAIN):   if _N_=1 then call symput('targetvar', strip(NAME));
MPRINT(TRAIN):   run;
 
NOTE: 0개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_VARIABLESET.에서 읽었습니다.
      WHERE (ROLE='TARGET') and USE in ('D', 'Y') and (LEVEL not = 'INTERVAL');
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   create table EMWS5.TextCluster5_tmconfig as select * from EMWS5.TextFilter5_tmconfig;
NOTE: Table EMWS5.TEXTCLUSTER5_TMCONFIG created, with 1 rows and 30 columns.
 
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select cellwgt into: _cellweight from EMWS5.TextCluster5_tmconfig;
MPRINT(TRAIN):   select termwgt into: _termwgt from EMWS5.TextCluster5_tmconfig;
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):   data _keepdocs (keep=_DOCUMENT_ );
MPRINT(TRAIN):   set EMWS5.TextFilter5_TRAIN;
MPRINT(TRAIN):   run;
 
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTPARSING5_TRAIN.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_DOC_IDS.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 WORK._KEEPDOCS은(는) 496개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.09 초
 
 
MPRINT(TM_APPLY_TMUTIL):   proc sql noprint;
MPRINT(TM_APPLY_TMUTIL):   create view _keepdata as select * from EMWS5.TextFilter5_tmout where _DOCUMENT_ in (select _DOCUMENT_ from _keepdocs);
NOTE: SQL view WORK._KEEPDATA has been defined.
MPRINT(TM_APPLY_TMUTIL):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_APPLY_TMUTIL):   proc tmutil data=_keepdata key= EMWS5.TextFilter5_terms doc=_keepdocs ;
MPRINT(TM_APPLY_TMUTIL):   control init memloc="_tmmem";
MPRINT(TM_APPLY_TMUTIL):   ;
MPRINT(TM_APPLY_TMUTIL):   run;
 
NOTE: 4155개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TMOUT.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._KEEPDOCS.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._KEEPDATA.에서 읽었습니다.
NOTE: 1376개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TERMS_DATA.에서 읽었습니다.
      WHERE KEEP='Y';
NOTE: 1377개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TERM_STRINGS.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._KEEPDOCS.에서 읽었습니다.
NOTE: 프로시저 TMUTIL 실행(총 프로세스 시간):
      실행 시간           0.21 초
      cpu 시간            0.20 초
 
 
MPRINT(TM_APPLY_TMUTIL):   proc tmutil;
MPRINT(TM_APPLY_TMUTIL):   control memloc="_tmmem";
MPRINT(TM_APPLY_TMUTIL):   select reduceF=2;
MPRINT(TM_APPLY_TMUTIL):   run;
 
NOTE: 프로시저 TMUTIL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_APPLY_TMUTIL):   proc tmutil;
MPRINT(TM_APPLY_TMUTIL):   control memloc="_tmmem" release;
MPRINT(TM_APPLY_TMUTIL):   weight termwgt=ENTROPY cellwgt=LOG;
MPRINT(TM_APPLY_TMUTIL):   output key=_termstmutil keyformat=default keeponly unweighted out=_outtmutil_;
MPRINT(TM_APPLY_TMUTIL):   run;
 
NOTE: 데이터셋 WORK._TERMSTMUTIL은(는) 560개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: 데이터셋 WORK._OUTTMUTIL_은(는) 3339개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 TMUTIL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_APPLY_TMUTIL):   proc sql noprint;
MPRINT(TM_APPLY_TMUTIL):   create table _distinctterms as select distinct key,term, role, attribute from EMWS5.TextFilter5_terms;
NOTE: Table WORK._DISTINCTTERMS created, with 1376 rows and 4 columns.
 
MPRINT(TM_APPLY_TMUTIL):   create table _newkey as select b.term, b.role,b.attribute ,a.* from _termstmutil a left join _distinctterms b on a.key=b.key;
NOTE: Table WORK._NEWKEY created, with 560 rows and 11 columns.
 
MPRINT(TM_APPLY_TMUTIL):   ;
MPRINT(TM_APPLY_TMUTIL):   create table _weights as select distinct a.key as index, a.weight as gwgt from _newkey(where=(_ispar in('+',' '))) a inner join _distinctterms b on a.key =b.key;
NOTE: Table WORK._WEIGHTS created, with 560 rows and 2 columns.
 
MPRINT(TM_APPLY_TMUTIL):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.11 초
 
 
MPRINT(TRAIN):  ;
MPRINT(TM_SVD_DO_SAMP):   proc sort data=_outtmutil_;
MPRINT(TM_SVD_DO_SAMP):   by _termnum_;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 3339개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 데이터셋 WORK._OUTTMUTIL_은(는) 3339개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc spsvd data=_outtmutil_ max_k = 100 res = LOW local = LOG global =none in_global = _weights;
MPRINT(TM_SVD_DO_SAMP):   row _termnum_;
MPRINT(TM_SVD_DO_SAMP):   col _document_;
MPRINT(TM_SVD_DO_SAMP):   entry _count_;
MPRINT(TM_SVD_DO_SAMP):   output u = EMWS5.TextCluster5_svd_u v = _svdv s = EMWS5.TextCluster5_svd_s;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: P has been set to 25.
NOTE: Restart 1, Converged 37
NOTE: Restart 2, Converged 49
NOTE: Restart 3, Converged 66
NOTE: Restart 4, Converged 81
NOTE: Restart 5, Converged 92
NOTE: Restart 6, Converged 99
NOTE: Restart 7, Converged 99
NOTE: Singular values have converged.  Creating data sets.
NOTE: Restarted 7 times.
NOTE: Using value of 45 for K.
NOTE: 3339개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 560개의 관측값을 데이터셋 WORK._WEIGHTS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_SVD_U은(는) 560개의 관측값과 101개의 변수를 가지고 있습니다.
NOTE: 데이터셋 WORK._SVDV은(는) 442개의 관측값과 101개의 변수를 가지고 있습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_SVD_S은(는) 100개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SPSVD 실행(총 프로세스 시간):
      실행 시간           0.46 초
      cpu 시간            0.46 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sql noprint;
MPRINT(TM_SVD_DO_SAMP):   select count(*) into: svdkeep from EMWS5.TextCluster5_svd_s where keep=1;
MPRINT(TM_SVD_DO_SAMP):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_SVD_DO_SAMP):   data EMWS5.TextCluster5_svd_u;
MPRINT(TM_SVD_DO_SAMP):   set EMWS5.TextCluster5_svd_u(keep= index col1-col45);
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 560개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_SVD_U.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_SVD_U은(는) 560개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_SVD_DO_SAMP):   data _svdv;
MPRINT(TM_SVD_DO_SAMP):   set _svdv(keep= index col1-col45);
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 442개의 관측값을 데이터셋 WORK._SVDV.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDV은(는) 442개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sql noprint;
MPRINT(TM_SVD_DO_SAMP):   create table new_global as select a.* from _weights a, EMWS5.TextCluster5_svd_u b where a.index = b.index;
NOTE: Table WORK.NEW_GLOBAL created, with 560 rows and 2 columns.
 
MPRINT(TM_SVD_DO_SAMP):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sort data=_outtmutil_;
MPRINT(TM_SVD_DO_SAMP):   by _document_;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 3339개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 데이터셋 WORK._OUTTMUTIL_은(는) 3339개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc spsvd data=_outtmutil_ IN_U=EMWS5.TextCluster5_svd_u local = LOG global = none in_global = new_global ;
MPRINT(TM_SVD_DO_SAMP):   row _termnum_;
MPRINT(TM_SVD_DO_SAMP):   col _document_;
MPRINT(TM_SVD_DO_SAMP):   entry _count_;
MPRINT(TM_SVD_DO_SAMP):   output colpro=_svdcolpro bigpro normcol prefix="TextCluster5_SVD";
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 3339개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 560개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_SVD_U.에서 읽었습니다.
NOTE: 560개의 관측값을 데이터셋 WORK.NEW_GLOBAL.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDCOLPRO은(는) 442개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: 프로시저 SPSVD 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sort data=_keepdocs(keep=_document_) out=_docids;
MPRINT(TM_SVD_DO_SAMP):   by _document_;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._KEEPDOCS.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCIDS은(는) 496개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   data _svdcolpro;
MPRINT(TM_SVD_DO_SAMP):   merge _svdcolpro _docids(rename=(_document_=index));
MPRINT(TM_SVD_DO_SAMP):   by index;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 442개의 관측값을 데이터셋 WORK._SVDCOLPRO.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCIDS.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDCOLPRO은(는) 496개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   data _svdcolpro;
MPRINT(TM_SVD_DO_SAMP):   set _svdcolpro;
MPRINT(TM_SVD_DO_SAMP):   array svd_array TextCluster5_SVD1 - TextCluster5_SVD45;
MPRINT(TM_SVD_DO_SAMP):   do i = 1 to dim(svd_array);
MPRINT(TM_SVD_DO_SAMP):   if svd_array(i)=. then svd_array(i)=0;
MPRINT(TM_SVD_DO_SAMP):   end;
MPRINT(TM_SVD_DO_SAMP):   drop i;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._SVDCOLPRO.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDCOLPRO은(는) 496개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sort data=_outtmutil_;
MPRINT(TM_SVD_DO_SAMP):   by _termnum_;
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 3339개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 데이터셋 WORK._OUTTMUTIL_은(는) 3339개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc sql;
MPRINT(TM_SVD_DO_SAMP):   create table new_global as select a.* from _weights a, EMWS5.TextCluster5_svd_u b where a.index = b.index;
NOTE: Table WORK.NEW_GLOBAL created, with 560 rows and 2 columns.
 
MPRINT(TM_SVD_DO_SAMP):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_SVD_DO_SAMP):   proc spsvd data=_outtmutil_ IN_V=_svdv local = LOG global = none in_global = new_global ;
MPRINT(TM_SVD_DO_SAMP):   row _termnum_;
MPRINT(TM_SVD_DO_SAMP):   col _document_;
MPRINT(TM_SVD_DO_SAMP):   entry _count_;
MPRINT(TM_SVD_DO_SAMP):   output wordPro = _svdrowpro bigpro normrow prefix="TextCluster5_SVD";
MPRINT(TM_SVD_DO_SAMP):   run;
 
NOTE: 3339개의 관측값을 데이터셋 WORK._OUTTMUTIL_.에서 읽었습니다.
NOTE: 442개의 관측값을 데이터셋 WORK._SVDV.에서 읽었습니다.
NOTE: 560개의 관측값을 데이터셋 WORK.NEW_GLOBAL.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDROWPRO은(는) 560개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: 프로시저 SPSVD 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.04 초
 
 
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   create table EMWS5.TextCluster5_terms(drop=index) as select a.*,b.* from EMWS5.TextFilter5_terms a left join _svdrowpro b on a.key = b.index;
NOTE: Table EMWS5.TEXTCLUSTER5_TERMS created, with 1376 rows and 58 columns.
 
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmgetncl.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMGETNCL.SOURCE입니다.
24603     +
24604     + /*
24605     +  Macro:   tmgetncl.sas
24606     +  Purpose: To obtain a default number of clusters
24607     +  Syntax:  %tmgetncl(data=, maxclusters=, vars=);
24608     +
24609     +  Required Parameters:  data=      The input data set.
24610     +
24611     +  Optional Parameters:  vars=      Variables to be used
24612     +
24613     +  History:
24614     +  2001/01/23 - Bill Wheeler - Initial Coding.
24615     +
24616     +*/
24617     + %MACRO tmgetncl(data=, maxclusters=, vars=, tempDS=,
24618     +                 clusDS=, threads=THREADS);
24619     +
24620     +  %if &maxclusters= %then %let maxclusters = 40;
24621     +
24622     +  %if &vars ^= %then %let var = var &vars;
24623     +  %else %let var = ;
24624     +
24625     +  /* run PROC FASTCLUS with maxClusters clusters */
24626     +  proc fastclus data = &data noprint
24627     +    maxclusters = &maxclusters
24628     +    mean = &tempDS;
24629     +    &var
24630     +    ;
24631     +    run;
24632     +
24633     +  /* use PROC CLUSTER with the MEAN data set from FASTCLUS */
24634     +  proc cluster data = &tempDS
24635     +    method = WARD
24636     +    pseudo
24637     +    noprint
24638     +    outtree = &tempDS;
24639     +    &var;
24640     +  run;
24641     +
24642     +  %if (&SYSERR > 4) %then %do;
24643     +    data &clusDS; nclus = 0; run;
24644     +    %goto exit;
24645     +  %end;
24646     +
24647     +  /* sort and get rid of missing values in the outtree data set */
24648     +  %tmsort(data=&tempDS(where=(_ccc_ > -99999.0) keep = _ncl_ _ccc_),
24649     +        out=&tempDS, by=_ncl_, options=, threads=&threads);
24650     +
24651     +  data &clusDS; set &tempDS;
24652     +    keep nclus;
24653     +    retain loclclus -1 loclccc 0 maxccc 0 maxclus 0
24654     +   jclus -1 maxjump -1 nclus 0 jccc 0 prevjump 0 jump 0 occc 0 oncl 0;
24655     +
24656     +   if _N_ = 1 then do;
24657     +     maxccc = _ccc_;
24658     +     maxclus = _ncl_;
24659     +     nclus = _ncl_;
24660     +     occc = _ccc_;
24661     +     oncl = _ncl_;
24662     +   end;
24663     +   else if (_N_ = 2) then do;
24664     +     jump = _ccc_ - occc;
24665     +     if (jump > 0) then do;
24666     +       maxjump = jump;
24667     +       jclus = _ncl_;
24668     +     end;
24669     +     if (_ccc_ > maxccc) then do;
24670     +       maxccc = _ccc_;
24671     +       maxclus = _ncl_;
24672     +     end;
24673     +     occc = _ccc_;
24674     +     oncl = _ncl_;
24675     +   end;
24676     +
24677     +   else if (_N_ > 2) then do;
24678     +     prevjump = jump;
24679     +     jump = _ccc_ - occc;
24680     +
24681     +     if ((prevjump > 0) & (jump < 0) & (loclclus < 0)) then do;
24682     +        loclclus = oncl;
24683     +        loclccc = occc;
24684     +     end;
24685     +     if (_ccc_ > maxccc) then do;
24686     +       maxccc = _ccc_;
24687     +       maxclus = _ncl_;
24688     +     end;
24689     +     if ((jump > 0) & (jump > maxjump)) then do;
24690     +       jclus = _ncl_;
24691     +       maxjump = jump;
24692     +       jccc = _ccc_;
24693     +     end;
24694     +
24695     +     occc = _ccc_;
24696     +     oncl = _ncl_;
24697     +
24698     +     if ((loclclus > 0) & (jclus > 0)) then nclus = MIN(loclclus, jclus);
24699     +     else if (loclclus > 0) then nclus = loclclus;
24700     +     else if (jclus > 0) then nclus = jclus;
24701     +     else nclus = maxclus;
24702     +   end;
24703     +  run;
24704     +
24705     +  %exit: ;
24706     +
24707     +%MEND tmgetncl;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmfast.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMFAST.SOURCE입니다.
24708     + /*
24709     +
24710     +  Macro:   tmfast.sas
24711     +  Purpose: Call proc fastclus with given defaults and parameters.
24712     +  Syntax:  %tmfast(data=, clusters=, outstat=, vars=);
24713     +
24714     +  Required Parameters:  data=      The input data set.
24715     +                        clusters=  The maximum number of clusters
24716     +
24717     +  Optional Parameters:  vars=      Variables to be used
24718     +                        outstat=   The name of the OUTSTAT data set
24719     +                        outseed=   The name of the OUTSEED data set
24720     +
24721     +  Either outstat or outseed mut be given, but not both.
24722     +  History:
24723     +  2001/01/16 - Bill Wheeler - Initial Coding.
24724     +
24725     +*/
24726     +%MACRO tmfast(data=, clusters=, outstat=, outseed=,
24727     +                 id=, out=, vars=);
24728     + /* defaults */
24729     + %if (&id ne ) %then %let id = id &id;
24730     + %if (&out ne ) %then %let out = out = &out;
24731     + %if (&vars ne ) %then %let var = var &vars;
24732     + %else %let var = ;
24733     +
24734     + %if &outseed= %then
24735     + %do;
24736     +   proc fastclus data = &data
24737     +   maxclusters = &clusters noprint
24738     +   outstat = &outstat &out;
24739     +   &var;
24740     +   &id;
24741     + %end;
24742     + %else
24743     + %do;
24744     +   proc fastclus data = &data
24745     +   maxclusters = &clusters noprint
24746     +   outseed = &outseed &out;
24747     +   &var;
24748     +   &id;
24749     + %end;
24750     +%MEND tmfast;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmemclus.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMEMCLUS.SOURCE입니다.
24751     +
24752     + /*
24753     +
24754     +  Macro:   tmemclus.sas
24755     +  Purpose: Call proc emclus with given defaults and parameters.
24756     +  Syntax:  %tmemclus(data=, role=, clusters=, seed=,
24757     +                   outstat=, out=, vars=, cov=, iter=, secclus=,
24758     +                   seciter=, min=, method=, eps=, init=, print=,
24759     +                   p=, outliers=, decvar=, initstd=, dist=,
24760     +                   secstd=, nobs=, threads=);
24761     +  Required Parameters:  data=      The input data set.
24762     +                        role=      Train or score
24763     +                        clusters=  The number of primary clusters
24764     +
24765     +  Optional Parameters:  vars=      Variables to be used
24766     +                   cov=       Type of covariance matrix
24767     +                   iter=      Number of EM iterations
24768     +                   secclus    Number of secondary clusters
24769     +                   seciter    Number of k-means iterations
24770     +                   min=       Minimum number of obs in a cluster
24771     +                   method=    Standard or scaled
24772     +                   eps=       Stopping tolerance
24773     +                   init=      Random, Fastclus, or Emclus
24774     +                   print=     All, last, or none
24775     +                   p=
24776     +                   outliers=  Keep, cluster, or ignore
24777     +                   outstat=   Name of OUTSTAT data set
24778     +                   out=       Name of OUT data set
24779     +                   seed=      Name of SEED data set
24780     +                   decvar=    Proportion to decrease variances
24781     +                   initstd=   Initial standard deviation
24782     +                   dist=      Minimum distance between clusters
24783     +                   secstd=    Secondary cluster max std dev.
24784     +                   nobs=      Number of obs read in each iteration
24785     +  History:
24786     +  2001/01/16 - Bill Wheeler - Initial Coding.
24787     +  2001/11/29 - Bill Wheeler - Updated for version 8 or 9
24788     +*/
24789     +%MACRO tmemclus(data=, role=, clusters=, seed=,
24790     + outstat=, out=, vars=, cov=, iter=, secclus=,
24791     + seciter=, min=, method=, eps=, init=, print=,
24792     + p=, outliers=, decvar=, initstd=, dist=, secstd=, nobs=, threads=);
24793     +
24794     + %local saveout saveseed op1 op2 op3 op4;
24795     +
24796     + %LET saveout = &out;
24797     + %LET saveseed = &outstat;
24798     +
24799     + /* defaults */
24800     + %if &role= %then %let role = TRAIN;
24801     + %if &seed ne %then %let seed = seed=&seed;
24802     + %if &vars= %then %let var = ;
24803     + %else %let var = var &vars;
24804     + %if &cov ne %then %let cov = cov = &cov;
24805     + %if &iter ne %then %let iter = iter = &iter;
24806     + %if &init ne %then %let init = init = &init;
24807     + %if &eps ne  %then %let eps = eps = &eps;
24808     + %if &min ne %then %let min = min = &min;
24809     + %if &seciter ne %then %let seciter = seciter = &seciter;
24810     + %if &print ne %then %let print = print = &print;
24811     + %if &p ne %then %let p = p = &p;
24812     + %if &outliers ne %then %let outliers = outliers = &outliers;
24813     + %if &method ne %then %let method = method = &method;
24814     + %if &decvar ne %then %let decvar = decvar = &decvar;
24815     + %if &outstat ne %then %let outstat = outstat = &outstat;
24816     + %if &out ne %then %let out = out = &out;
24817     + %if (&threads >= 0)  %then %let threads = threads = &threads;
24818     + %else %let threads = ;
24819     +
24820     + %LET op1 = ;
24821     + %LET op2 = ;
24822     + %LET op3 = ;
24823     + %LET op4 = ;
24824     + %if ^(&initstd=) %then %let op1 = %str(initstd = &initstd);
24825     + %if ^(&dist=) %then %let op2 = %str(dist = &dist);
24826     + %if ^(&secstd=) %then %let op3 = %str(secstd = &secstd);
24827     + %if ^(&nobs=) %then %let op4 = %str(nobs = &nobs);
24828     +
24829     +
24830     + %IF &SYSVER < 9 %THEN %DO;
24831     +    %LET cov = ;
24832     +    %LET decvar = ;
24833     +    %LET outliers = ;
24834     +    %LET out = ;
24835     + %END;
24836     +
24837     +
24838     + %if %upcase(&role) = TRAIN %then
24839     + %do;
24840     +   proc emclus data = &data
24841     +   clusters = &clusters
24842     +   &seed
24843     +   &outstat
24844     +   &out
24845     +   &init
24846     +   &eps
24847     +   &method
24848     +   &secclus
24849     +   &min
24850     +   &print
24851     +   &outliers
24852     +   &iter
24853     +   &op1 &op2
24854     +   &op3 &op4
24855     +   &decvar
24856     +   &cov
24857     +   &threads
24858     +   ;
24859     +   &var;
24860     + %end;
24861     + %else
24862     +  %do;
24863     +    proc emclus data = &data
24864     +    role = score
24865     +    clusters = &clusters
24866     +    &seed
24867     +    &out
24868     +    &cov
24869     +    ;
24870     +    &var;
24871     +  %end;
24872     +
24873     + %IF &SYSVER < 9 and &saveout ^= %THEN %DO;
24874     +   proc emclus data = &data
24875     +   role = score
24876     +   clusters = &clusters
24877     +   seed = &saveseed
24878     +   &saveout
24879     +   ;
24880     +   &var;
24881     + %END;
24882     +
24883     +
24884     +%MEND tmemclus;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmpred.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMPRED.SOURCE입니다.
24885     +
24886     +/*
24887     +  Macro: tmpred(inds,outds,clusters,type=,ignore=,freqDS=)
24888     +
24889     +  Description: This macro will take output from
24890     +     emclus and generate predicted
24891     +      predicted clusters.
24892     +
24893     +  Parms: inds - input data set, produced by emclus.
24894     +   outds - data set with clusters created by this macro.
24895     +   clusters - number of clusters that should be on this data set
24896     +   type - valid values: 'max' or 'prob'.  Max will just take the
24897     +      cluster with the highest probability as the predicted cluster.
24898     +      In the case of a tie the first cluster with that value will
24899     +       selected.
24900     +      Prob will attempt to select multiple clusters based on
24901     +      how many clusters were requested.  That is if 3 clusters
24902     +      were requested, any cluster with prob>1/3 will be selected
24903     +      as the predicted cluster. THIS OPTION IS UNTESTED.
24904     +*/
24905     +
24906     +%macro tmpred(inds,outds,clusters,type=, ignore=0, freqDS=, compress=1);
24907     +
24908     +  %local _str newfreqDS _flag;
24909     +
24910     +  * set the optional arguments;
24911     +  %if &type= %then %let type=max;
24912     +  %if &ignore = 1 %then %let
24913     +    _str = if _CLUSTER_ = &clusters then _CLUSTER_ = .;
24914     +  %else %let _str = ;
24915     +  %if %str(&freqDS) ^= %str() %then %do;
24916     +   %let newfreqDS = &freqDS(keep=_c1-_c&clusters);
24917     +   %let _flag = 1;
24918     +  %end;
24919     +  %else %let _flag = 0;
24920     +
24921     +  %if &compress = 1 %then %let compress = compress=Y;
24922     +  %else %let compress = ;
24923     +
24924     +  data &outds(&compress drop=_c1-_c&clusters)
24925     +    %if &_flag = 1 %then %do;
24926     +    &newfreqDS
24927     +    %end;
24928     +    ;
24929     +    set &inds end=eof;
24930     +   * array for holding all probabilities;
24931     +    array _p prob1--prob&clusters;
24932     +    array _c(&clusters);
24933     +    retain _c 0;
24934     +   * get rid of working columns;
24935     +    drop _max_ _i /*prob1--prob&clusters*/ _WARN_;
24936     +    /* keep the largest probability and the cluster */
24937     +    _max_ = 0;
24938     +    do _i = 1 to &clusters;
24939     +      if _p(_i) > _max_ then do;
24940     +        _max_ = _p(_i);
24941     +        _CLUSTER_ = _i;
24942     +      end;
24943     +    end;
24944     +    if (_CLUSTER_ >= 1) and (_CLUSTER_ <= &clusters) then
24945     +      _c(_CLUSTER_) = _c(_CLUSTER_) + 1;
24946     +    else _CLUSTER_ = .;
24947     +    &_str;
24948     +    %if &_flag = 1 %then %do;
24949     +      if eof then do;
24950     +        output &freqDS;
24951     +                output &outDS;
24952     +          end;
24953     +          else output &outDS;
24954     +        %end;
24955     +
24956     +    run;
24957     +%mend tmpred;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmsort.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMSORT.SOURCE입니다.
24958     + /*
24959     +PROC SORT macro
24960     +
24961     +%tmsort(data=, out=, by=);
24962     +
24963     +data=      - name of input data set (outtree data set from PROC CLUSTER)
24964     +out=       - name of the output data set
24965     +by=        - by statement
24966     +options=   - proc options
24967     +*/
24968     +
24969     +%macro tmsort(data=, out=, by=, options=, threads=THREADS);
24970     +  %if %BQUOTE(&out) ^= %then %let out = out =  &out;
24971     +  %if &SYSVER < 9 %then %let threads = ;
24972     +
24973     +  proc sort data = %STR(&data) &threads &options
24974     +    &out;
24975     +    by &by;
24976     +  run;
24977     +
24978     +%mend tmsort;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select count(*) into: numTerms from EMWS5.TextFilter5_terms a where a.numdocs>=2 and _ispar in('+',' ') ;
MPRINT(TM_CLUSTER):   select count (*) into: numdocs from EMWS5.TextFilter5_TRAIN a;
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMGETNCL):   proc fastclus data = _svdcolpro noprint maxclusters = 40 mean = _clusTemp1;
MPRINT(TMGETNCL):   var TextCluster5_SVD1 - TextCluster5_SVD45 ;
MPRINT(TMGETNCL):   run;
 
NOTE: 데이터셋 WORK._CLUSTEMP1은(는) 40개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: 프로시저 FASTCLUS 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETNCL):   proc cluster data = _clusTemp1 method = WARD pseudo noprint outtree = _clusTemp1;
MPRINT(TMGETNCL):   var TextCluster5_SVD1 - TextCluster5_SVD45;
MPRINT(TMGETNCL):   run;
 
NOTE: 데이터셋 WORK._CLUSTEMP1은(는) 79개의 관측값과 61개의 변수를 가지고 있습니다.
NOTE: 프로시저 CLUSTER 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _clusTemp1(where=(_ccc_ > -99999.0) keep = _ncl_ _ccc_) out = _clusTemp1;
MPRINT(TMSORT):   by _ncl_;
MPRINT(TMSORT):   run;
 
NOTE: 39개의 관측값을 데이터셋 WORK._CLUSTEMP1.에서 읽었습니다.
      WHERE _ccc_>-99999;
NOTE: 데이터셋 WORK._CLUSTEMP1은(는) 39개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMGETNCL):  ;
MPRINT(TMGETNCL):   data _clusTemp;
MPRINT(TMGETNCL):   set _clusTemp1;
MPRINT(TMGETNCL):   keep nclus;
MPRINT(TMGETNCL):   retain loclclus -1 loclccc 0 maxccc 0 maxclus 0 jclus -1 maxjump -1 nclus 0 jccc 0 prevjump 0 jump 0 occc 0 oncl 0;
MPRINT(TMGETNCL):   if _N_ = 1 then do;
MPRINT(TMGETNCL):   maxccc = _ccc_;
MPRINT(TMGETNCL):   maxclus = _ncl_;
MPRINT(TMGETNCL):   nclus = _ncl_;
MPRINT(TMGETNCL):   occc = _ccc_;
MPRINT(TMGETNCL):   oncl = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   else if (_N_ = 2) then do;
MPRINT(TMGETNCL):   jump = _ccc_ - occc;
MPRINT(TMGETNCL):   if (jump > 0) then do;
MPRINT(TMGETNCL):   maxjump = jump;
MPRINT(TMGETNCL):   jclus = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   if (_ccc_ > maxccc) then do;
MPRINT(TMGETNCL):   maxccc = _ccc_;
MPRINT(TMGETNCL):   maxclus = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   occc = _ccc_;
MPRINT(TMGETNCL):   oncl = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   else if (_N_ > 2) then do;
MPRINT(TMGETNCL):   prevjump = jump;
MPRINT(TMGETNCL):   jump = _ccc_ - occc;
MPRINT(TMGETNCL):   if ((prevjump > 0) & (jump < 0) & (loclclus < 0)) then do;
MPRINT(TMGETNCL):   loclclus = oncl;
MPRINT(TMGETNCL):   loclccc = occc;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   if (_ccc_ > maxccc) then do;
MPRINT(TMGETNCL):   maxccc = _ccc_;
MPRINT(TMGETNCL):   maxclus = _ncl_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   if ((jump > 0) & (jump > maxjump)) then do;
MPRINT(TMGETNCL):   jclus = _ncl_;
MPRINT(TMGETNCL):   maxjump = jump;
MPRINT(TMGETNCL):   jccc = _ccc_;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   occc = _ccc_;
MPRINT(TMGETNCL):   oncl = _ncl_;
MPRINT(TMGETNCL):   if ((loclclus > 0) & (jclus > 0)) then nclus = MIN(loclclus, jclus);
MPRINT(TMGETNCL):   else if (loclclus > 0) then nclus = loclclus;
MPRINT(TMGETNCL):   else if (jclus > 0) then nclus = jclus;
MPRINT(TMGETNCL):   else nclus = maxclus;
MPRINT(TMGETNCL):   end;
MPRINT(TMGETNCL):   run;
 
NOTE: 39개의 관측값을 데이터셋 WORK._CLUSTEMP1.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSTEMP은(는) 39개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETNCL):   ;
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select max(nclus) into: numClus from _clusTemp ;
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select count(*) into: nobs from _svdcolpro;
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtxtext.tmgethclus.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TMGETHCLUS.SOURCE입니다.
24979     +
24980     + /* ****************************************************************
24981     + * Copyright (C) 2010 by SAS Institute Inc., Cary, NC 27513
24982     + *
24983     + * Name:             tmgethclus.sas
24984     + * Product:
24985     + * Language:         Sas
24986     + * Script:
24987     + *
24988     + * Usage:
24989     +
24990     + !Inputs into %tmgethclus
24991     + * idVar = name of document index variable
24992     + * inDS = input data set containing svd dim
24993     + * vars = variables to copy to outtree
24994     + * nobs = number of observations in inDS
24995     + * nclus = number of clusters
24996     +
24997     +
24998     + !Outputs from %tmgethclus
24999     + * outtree = temp dataset to hold outtree
25000     + * outDS = output docs data set
25001     + * fastOut = temp data set for large data
25002     + * textclusDS = output clusters data set
25003     + *
25004     + * Example call
25005     + *
25006     + *%tmgethclus(outtree=_outtree,
25007     + *                   idvar=index,
25008     + *                   inDS=_docs,
25009     + *                   outDS=&outdocs,
25010     + *                   fastOut=_fastclusstat,
25011     + *                   textClusDS=&clusters,
25012     + *                   vars=%str(col1-col&svdkeep),
25013     + *                   nobs=400,
25014     + *                   nclus=10);
25015     + *
25016     + *
25017     + * Purpose: Perform the hierarchical clustering on out, term, doc from parse or filter node
25018     + *
25019     + * History:
25020     + *
25021     + *
25022     + * Notes:
25023     + *
25024     + * Last Modified By:
25025     + * Last Modified On: Tue Jul 27 10:38:10 2010
25026     + *
25027     + * End
25028     + * ************************************************************** */
25029     +
25030     +%macro tmGetHClus(outtree=,idVar=,inDS=,outDS=,fastOut=,textclusDS=,vars=,nobs=,
25031     +                nclus=,hierds=,svdkeep=,prefix=);
25032     +    %let syscc=0;
25033     +    %let emexceptionstring=;
25034     +    %let varString=&vars;
25035     +    %let id=&idvar;
25036     +    %let nLargeClusters=200;
25037     +    %if (&nClus > &nLargeClusters) %then
25038     +        %let nLargeClusters = %eval(&nClus + 1);
25039     +    %if ^%symexist(tm_debug) %then %let tm_debug=0;
25040     +    %let temp1 =&inDS;
25041     +
25042     +    proc fastclus data = &temp1 noprint
25043     +       maxclusters = &nLargeClusters
25044     +       out = &fastOut
25045     +       mean = _outseeds ;
25046     +       id &id;
25047     +       var &varString;
25048     +    run;
25049     +
25050     +    data _outseeds;
25051     +        set _outseeds;
25052     +        rename CLUSTER=_SUBCLUSTER_;
25053     +        drop _CRIT_ _FREQ_ _RMSSTD_ _RADIUS_ _NEAR_ _GAP_;
25054     +    run;
25055     +
25056     +    /* run PROC CLUSTER */
25057     +
25058     +    proc cluster data=_outseeds out=&outtree method=WARD noprint;
25059     +        copy _SUBCLUSTER_;
25060     +        var %STR(&varString);
25061     +    run;
25062     +
25063     +    %tmsort(data=&outtree, out=, by=descending _height_, options=, threads=);
25064     +    %let keepobs=%eval(2*&nclus-1);
25065     +    %let leaves=0;
25066     +
25067     +    proc sql noprint;
25068     +      create table _subtree2 as select * from &outtree where _name_ like 'CL%';
25069     +      select count(*) into :rowcnt from &outtree;
25070     +    quit;
25071     +    data _subtree; set _subtree2 (obs=&keepobs); run;
25072     +
25073     +    %do %while (&leaves<&nclus and &keepobs < &rowcnt);
25074     +        proc sql noprint;
25075     +            select count(*) into :leaves from _subtree
25076     +            where _NAME_ not in (select _PARENT_ from _subtree);
25077     +            select count(*) into :rowcnt from &outtree;
25078     +        quit;
25079     +        %if &leaves<&nclus %then %do;
25080     +            %let keepobs=%eval(&keepobs + 1);
25081     +            data _subtree; set _subtree2 (obs=&keepobs); run;
25082     +        %end;
25083     +    %end;
25084     +    %if &nclus > 1 %then %do;
25085     +
25086     +        filename temp catalog 'sashelp.emtxtext.tmhiertree.source';
25087     +        %include temp;
25088     +        %tmhiertree(_subtree, &outtree, &fastout, &hierds, &svdkeep, &prefix);
25089     +
25090     +         %if &syscc>4 or &emexceptionstring ne %then %goto end_macro;
25091     +
25092     +    %end;
25093     +    %else %do;
25094     +        %let clusnum=;
25095     +        proc sql noprint;
25096     +            select input(substr(_name_,3),8.) into :clusnum from _subtree;
25097     +        quit;
25098     +        %let clusnum=%left(&clusnum);
25099     +        data &fastout;
25100     +            set &fastout;
25101     +            _CLUSTER_=&clusnum;
25102     +            _FINALCLUSTER_=&clusnum;
25103     +            _SUBCLUSTER_=&clusnum;
25104     +        run;
25105     +        data &hierds;
25106     +            set _subtree;
25107     +        run;
25108     +    %end;
25109     +
25110     +    data &outDS;
25111     +        set &fastOut;
25112     +    run;
25113     +
25114     +      /* get data set clause */
25115     +    %let textString =(keep=_CLUSTER_ _SUBCLUSTER_ _FINALCLUSTER_ &vars);
25116     +    %let empty=1;
25117     +    %let currentpars=1;
25118     +    %let newpars=;
25119     +    %let level=2;
25120     +    data &hierds;
25121     +        set &hierds;
25122     +        _cluster_=input(substr(_name_,3),8.);
25123     +        parent=input(substr(_parent_,3),8.);
25124     +        if _cluster_=1 then level=1;
25125     +        else level=.;
25126     +        drop _name_ _parent_;
25127     +    run;
25128     +    /* add tree levels to hierds */
25129     +    %do %while (&empty > 0);
25130     +        data &hierds (drop=newparstr cnt i);
25131     +            array newpars(%eval(2*&nclus)) $ _TEMPORARY_;
25132     +            set &hierds end=lastrow;
25133     +            retain cnt;
25134     +            if _n_=1 then cnt=1;
25135     +            if parent in (&currentpars) then do;
25136     +                newpars(cnt)=put(left(_cluster_),8.);
25137     +                cnt = cnt + 1;
25138     +                level=&level;
25139     +            end;
25140     +            if lastrow then do;
25141     +                i=2;
25142     +                newparstr=put(newpars(1),$%eval(&nclus*10).);
25143     +                do while (i < cnt);
25144     +                    newparstr=CATX(', ', newparstr, newpars(i));
25145     +                    i = i + 1;
25146     +                end;
25147     +                call symput('newpars',newparstr);
25148     +            end;
25149     +        run;
25150     +        %let level=%eval(&level + 1);
25151     +        %let currentpars=&newpars;
25152     +        %let newpars=;
25153     +        proc sql noprint;
25154     +            select count(*) into :empty from &hierds where level=.;
25155     +        quit;
25156     +    %end;
25157     +
25158     +      /* get outstat data set */
25159     +    proc summary
25160     +        data = &outds &textString
25161     +        noprint;
25162     +        var &vars;
25163     +        class _CLUSTER_;
25164     +        output out = &textclusds;
25165     +    run;
25166     +
25167     +    data _NULL_;
25168     +        set &textclusds(where=(_CLUSTER_ = . and _STAT_ = 'N'));
25169     +        call symput('_TOT_', _FREQ_);
25170     +    run;
25171     +
25172     +    data &textclusds;
25173     +        set &textclusds(where=(_STAT_='MEAN'));
25174     + /*       _WEIGHT_ = _FREQ_/(&_TOT_);*/
25175     +        if _CLUSTER_ = . then delete;
25176     +        drop _TYPE_ _STAT_;
25177     +    run;
25178     +
25179     +    proc sql noprint;
25180     +        select sum(_FREQ_) into :totNumDocs
25181     +        from &textclusds;
25182     +    quit;
25183     +
25184     +    data &textclusds (rename=(_FREQ_=Freq));
25185     +        set &textclusds;
25186     +        Percent=_FREQ_/&totNumDocs;
25187     +    run;
25188     +
25189     +    proc sort data=&textclusds; by _cluster_; run;
25190     +
25191     +%end_macro:
25192     +    %if &tm_debug =0  %then %do;
25193     +    proc sql noprint;
25194     +        drop table _outseeds;
25195     +        drop table _subtree;
25196     +        drop table _subtree2;
25197     +    quit;
25198     +    %end;
25199     +%mend;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmhclus.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMHCLUS.SOURCE입니다.
25200     +
25201     + /* macro to run PROC CLUSTER
25202     +
25203     +%tmhclus(data=, outtree=, method=, copy=, outliers=, vars=);
25204     +
25205     + data=     -  input data set
25206     + outtree=  -  output data set to be input into PROC TREE
25207     + method=   -  which method to use, defaults to WARD
25208     + copy=     -  varibles to copy to outtree data set,
25209     +              id variable is needed
25210     + outliers= -  YES or NO (allow outliers ?)
25211     +*/
25212     +%macro tmhclus(data=, outtree=, method=, copy=, trim=, k=, vars=);
25213     +   %if (&trim ne .) %then %let trim = trim = &trim;
25214     +   %else %let trim = ;
25215     +   %if (&k ne .) %then %let k = k = &k;
25216     +   %else %let k = ;
25217     +
25218     +   %if &method= %then %let method = WARD;
25219     +   %if &copy ^= %then %let copy = copy &copy;
25220     +   %if &vars ne %then %let var = var &vars;
25221     +   %else %let var = ;
25222     +
25223     +   proc cluster data = &data
25224     +      outtree =   &outtree
25225     +      method = &method
25226     +      &trim &k noprint;
25227     +        &copy;
25228     +      &var;
25229     +   run;
25230     +%mend tmhclus;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmtree.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMTREE.SOURCE입니다.
25231     +
25232     + /*
25233     +PROC TREE macro
25234     +
25235     +%tmtree(data=, out=, nclusters=, id=);
25236     +
25237     +data=      - name of input data set (outtree data set from PROC CLUSTER)
25238     +out=       - name of the output data set
25239     +nclusters= - number of clusters
25240     +id=        - id variable (eg _document_)
25241     +
25242     +*/
25243     +
25244     +%macro tmtree(data=, out=, nclusters=, id=, copy=);
25245     +  %if &copy ^= %then %let copy = copy &copy;
25246     +  %if %str(&id) ^= %str() %then
25247     +    %let id = id &id;
25248     +  proc tree data = &data noprint
25249     +    out = &out
25250     +        nclusters = &nclusters;
25251     +   &id;
25252     +   &copy;
25253     +
25254     +%mend tmtree;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TMGETHCLUS):   proc fastclus data = _svdcolpro noprint maxclusters = 200 out = _fastclusstat mean = _outseeds ;
MPRINT(TMGETHCLUS):   id index;
MPRINT(TMGETHCLUS):   var TextCluster5_SVD1 - TextCluster5_SVD45;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 데이터셋 WORK._FASTCLUSSTAT은(는) 496개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: 데이터셋 WORK._OUTSEEDS은(는) 200개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: 프로시저 FASTCLUS 실행(총 프로세스 시간):
      실행 시간           0.14 초
      cpu 시간            0.15 초
 
 
MPRINT(TMGETHCLUS):   data _outseeds;
MPRINT(TMGETHCLUS):   set _outseeds;
MPRINT(TMGETHCLUS):   rename CLUSTER=_SUBCLUSTER_;
MPRINT(TMGETHCLUS):   drop _CRIT_ _FREQ_ _RMSSTD_ _RADIUS_ _NEAR_ _GAP_;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 200개의 관측값을 데이터셋 WORK._OUTSEEDS.에서 읽었습니다.
NOTE: 데이터셋 WORK._OUTSEEDS은(는) 200개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   proc cluster data=_outseeds out=_outtree method=WARD noprint;
MPRINT(TMGETHCLUS):   copy _SUBCLUSTER_;
MPRINT(TMGETHCLUS):   var TextCluster5_SVD1 - TextCluster5_SVD45;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 데이터셋 WORK._OUTTREE은(는) 399개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: 프로시저 CLUSTER 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMSORT):   proc sort data = _outtree ;
MPRINT(TMSORT):   by descending _height_;
MPRINT(TMSORT):   run;
 
NOTE: 399개의 관측값을 데이터셋 WORK._OUTTREE.에서 읽었습니다.
NOTE: 데이터셋 WORK._OUTTREE은(는) 399개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):  ;
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   create table _subtree2 as select * from _outtree where _name_ like 'CL%';
NOTE: Table WORK._SUBTREE2 created, with 199 rows and 62 columns.
 
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=31);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 31개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 31개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=32);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 32개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 32개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=33);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 33개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 33개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=34);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 34개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 34개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=35);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 35개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 35개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=36);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 36개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 36개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=37);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 37개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 37개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=38);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 38개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 38개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=39);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 39개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 39개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=40);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 40개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 40개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=41);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 41개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 41개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=42);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 42개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 42개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=43);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 43개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 43개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data _subtree;
MPRINT(TMGETHCLUS):   set _subtree2 (obs=44);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 44개의 관측값을 데이터셋 WORK._SUBTREE2.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUBTREE은(는) 44개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :leaves from _subtree where _NAME_ not in (select _PARENT_ from _subtree);
MPRINT(TMGETHCLUS):   select count(*) into :rowcnt from _outtree;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   filename temp catalog 'sashelp.emtxtext.tmhiertree.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TMHIERTREE.SOURCE입니다.
25255     +
25256     +%macro tmHierTree(subtree, outtree, fastout, leavesds, svdkeep, prefix);
25257     +%let cnt=1;
25258     +%let round=1;
25259     +
25260     +proc sql noprint;
25261     +    create table &subtree as select * from &subtree where _name_ like 'CL%';
25262     +quit;
25263     +
25264     +
25265     +%do %while (&cnt > 0);
25266     +    proc sql noprint;
25267     +
25268     +        create table leaves as select _name_
25269     +            from %if &round=1 %then &subtree; %else nosingle;
25270     +            where _name_ not in (select _parent_
25271     +                from %if &round=1 %then &subtree; %else nosingle;);
25272     +        create table singlepar as select _name_ as n
25273     +            from %if &round=1 %then &subtree; %else nosingle;
25274     +            where _parent_ not in (select _parent_
25275     +            from %if &round=1 %then &subtree; %else nosingle;
25276     +            where _name_ not eq n) and _parent_ ne '';
25277     +        /* find the leaves with a parent of only one child */
25278     +        create table leaves2 as select * from singlepar where n in (select _name_ from leaves);
25279     +        select count(*) into :cnt from leaves2;
25280     +        /* remove these leaves, we'll use their parent */
25281     +        %if &round=1 %then %do;
25282     +            create table nosingle as select * from &subtree where _name_ not in
25283     +                (select n from leaves2);
25284     +            %let round=2;
25285     +        %end;
25286     +        %else %do;
25287     +            delete from nosingle where _name_ in (select n from leaves2);
25288     +        %end;
25289     +    quit;
25290     +
25291     +%end;
25292     +
25293     +data &fastout;
25294     +    set &fastout;
25295     +    format _name_ $ 5.;
25296     +    _name_='CL'||left(cluster);
25297     +run;
25298     +%let nosingle=nosingle;
25299     +proc sort data=&fastout; by _name_; run;
25300     +proc sort data=&nosingle; by _name_; run;
25301     +proc sort data=&outtree; by _name_; run;
25302     +
25303     +%let clusts=;
25304     +proc sql noprint;
25305     +    create table newpars(
25306     +            _name_ char(8),
25307     +            parent char(8));
25308     +    insert into newpars values('CL1','CL1');
25309     +    select count(*) into :clusts from &outtree where _name_ like 'CL%';
25310     +quit;
25311     +%global parent;
25312     +%do i=2 %to &clusts;
25313     +    %tracePar(&outtree, &nosingle, CL&i);
25314     +%end;
25315     +
25316     +proc sort data=newpars; by _name_; run;
25317     +data &fastout;
25318     +    merge &fastout(rename=(cluster=_SUBCLUSTER_)) newpars;
25319     +    by _name_;
25320     +    _CLUSTER_=input(substr(parent,3.),8.);
25321     +    cluster=parent;
25322     +    drop parent _name_;
25323     +run;
25324     +
25325     +/* Find closest leaf cluster to those belonging to a parent cluster */
25326     +proc sql noprint;
25327     +    create table _calctree as select * from &outtree where _name_ like 'CL%';
25328     +quit;
25329     +proc distance data=_calctree out=_calctree method=EUCLID nostd;
25330     +    var RATIO (&prefix._SVD1-&prefix._SVD&svdkeep);
25331     +    id _name_;
25332     +run;
25333     +proc mds data=_calctree out=_calctree level=ratio dimension=2 noprint; run;
25334     +
25335     +%let cnt=0;
25336     +proc sql noprint;
25337     +    create table _parclustree as select distinct *, count(*) into :cnt
25338     +        from &fastout where cluster not in
25339     +        (select _name_ from leaves);
25340     +    create table _leafdims as select _name_ as leafname, dim1 as leafdim1, dim2 as leafdim2
25341     +        from _calctree
25342     +        where _name_ in (select _name_ from leaves);
25343     +    create table _nonleafdims as select _name_, dim1, dim2 from _calctree
25344     +        where _name_ in (select cluster from _parclustree);
25345     +    create table _parclustree as select a.*, b.* from _leafdims a, _nonleafdims b;
25346     +
25347     +quit;
25348     +data _parclustree;
25349     +    set _parclustree;
25350     +    distance=sqrt((dim1-leafdim1)**2+(dim2-leafdim2)**2);
25351     +run;
25352     +
25353     +proc sql noprint;
25354     +    create table _reroute as select _name_, min(distance) as distance
25355     +        from _parclustree group by _name_;
25356     +    create table _rerouteclus as select a._name_, a.distance, leafname
25357     +        from _reroute a, _parclustree b where a._name_ ne '' and
25358     +        a._name_=b._name_ and a.distance=b.distance;
25359     +    update &fastout set cluster=(select leafname from _rerouteclus
25360     +        where _name_=cluster) where cluster in (select _name_ from _rerouteclus);
25361     +quit;
25362     +
25363     +data &fastout;
25364     +    set &fastout;
25365     +    _FINALCLUSTER_=_CLUSTER_;
25366     +    _CLUSTER_=input(substr(cluster,3.),8.);
25367     +    drop cluster;
25368     +run;
25369     +data &leavesds;
25370     +    set nosingle;
25371     +run;
25372     +proc sql noprint;
25373     +    drop table leaves;
25374     +    drop table singlepar;
25375     +    drop table leaves2;
25376     +    drop table _calctree;
25377     +    drop table _leafdims;
25378     +    drop table _nonleafdims;
25379     +    drop table _parclustree;
25380     +    drop table _reroute;
25381     +    drop table _rerouteclus;
25382     +    drop table newpars;
25383     +    drop table nosingle;
25384     +quit;
25385     +
25386     +%mend;
25387     +%macro tracePar(outtree, clusds, obsrv);
25388     +
25389     +    %let parent=;
25390     +    /* check if _name_ is already in clusds */
25391     +    proc sql noprint;
25392     +        select _parent_ into :parent from &clusds where _name_="&obsrv";
25393     +    quit;
25394     +    %if %ktrim(&parent) eq and %ktrim(&obsrv) ne 'CL1' %then %do;
25395     +        /* check if _parent_ of _name_ is already in clusds --remove? */
25396     +        proc sql noprint;
25397     +            select _parent_ into :parent from &outtree where _name_="&obsrv";
25398     +        quit;
25399     +        %let parent=&parent;
25400     +        proc sql noprint;
25401     +            select count(*) into :exists from &clusds where _name_="&parent";
25402     +        quit;
25403     +        %if &exists < 1 %then %do;
25404     +            proc sql noprint;
25405     +                select parent into :parent from newpars where _name_="&parent";
25406     +                insert into newpars values("&obsrv","&parent");
25407     +            quit;
25408     +        %end;
25409     +        %else %do;
25410     +            proc sql noprint;
25411     +                insert into newpars values("&obsrv", "&parent");
25412     +            quit;
25413     +        %end;
25414     +    %end;
25415     +    %else %do;
25416     +        proc sql noprint;
25417     +            insert into newpars values("&obsrv", "&obsrv");
25418     +        quit;
25419     +    %end;
25420     +%mend;
25421     +
25422     +
25423     +
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TMHIERTREE):   proc sql noprint;
MPRINT(TMHIERTREE):   create table _subtree as select * from _subtree where _name_ like 'CL%';
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._SUBTREE created, with 44 rows and 62 columns.
 
MPRINT(TMHIERTREE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):   proc sql noprint;
MPRINT(TMHIERTREE):   create table leaves as select _name_ from _subtree where _name_ not in (select _parent_ from _subtree);
NOTE: Table WORK.LEAVES created, with 16 rows and 1 columns.
 
MPRINT(TMHIERTREE):   create table singlepar as select _name_ as n from _subtree where _parent_ not in (select _parent_ from _subtree where _name_ not eq n) and _parent_ ne '';
NOTE: Table WORK.SINGLEPAR created, with 13 rows and 1 columns.
 
MPRINT(TMHIERTREE):   create table leaves2 as select * from singlepar where n in (select _name_ from leaves);
NOTE: Table WORK.LEAVES2 created, with 9 rows and 1 columns.
 
MPRINT(TMHIERTREE):   select count(*) into :cnt from leaves2;
MPRINT(TMHIERTREE):   create table nosingle as select * from _subtree where _name_ not in (select n from leaves2);
NOTE: Table WORK.NOSINGLE created, with 35 rows and 62 columns.
 
MPRINT(TMHIERTREE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.15 초
      cpu 시간            0.14 초
 
 
MPRINT(TMHIERTREE):   proc sql noprint;
MPRINT(TMHIERTREE):   create table leaves as select _name_ from nosingle where _name_ not in (select _parent_ from nosingle);
NOTE: Table WORK.LEAVES created, with 16 rows and 1 columns.
 
MPRINT(TMHIERTREE):   create table singlepar as select _name_ as n from nosingle where _parent_ not in (select _parent_ from nosingle where _name_ not eq n) and _parent_ ne '';
NOTE: Table WORK.SINGLEPAR created, with 4 rows and 1 columns.
 
MPRINT(TMHIERTREE):   create table leaves2 as select * from singlepar where n in (select _name_ from leaves);
NOTE: Table WORK.LEAVES2 created, with 2 rows and 1 columns.
 
MPRINT(TMHIERTREE):   select count(*) into :cnt from leaves2;
MPRINT(TMHIERTREE):   delete from nosingle where _name_ in (select n from leaves2);
NOTE: 2 rows were deleted from WORK.NOSINGLE.
 
MPRINT(TMHIERTREE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.15 초
      cpu 시간            0.15 초
 
 
MPRINT(TMHIERTREE):   proc sql noprint;
MPRINT(TMHIERTREE):   create table leaves as select _name_ from nosingle where _name_ not in (select _parent_ from nosingle);
NOTE: Table WORK.LEAVES created, with 16 rows and 1 columns.
 
MPRINT(TMHIERTREE):   create table singlepar as select _name_ as n from nosingle where _parent_ not in (select _parent_ from nosingle where _name_ not eq n) and _parent_ ne '';
NOTE: Table WORK.SINGLEPAR created, with 2 rows and 1 columns.
 
MPRINT(TMHIERTREE):   create table leaves2 as select * from singlepar where n in (select _name_ from leaves);
NOTE: Table WORK.LEAVES2 created, with 1 rows and 1 columns.
 
MPRINT(TMHIERTREE):   select count(*) into :cnt from leaves2;
MPRINT(TMHIERTREE):   delete from nosingle where _name_ in (select n from leaves2);
NOTE: 1 row was deleted from WORK.NOSINGLE.
 
MPRINT(TMHIERTREE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.13 초
      cpu 시간            0.14 초
 
 
MPRINT(TMHIERTREE):   proc sql noprint;
MPRINT(TMHIERTREE):   create table leaves as select _name_ from nosingle where _name_ not in (select _parent_ from nosingle);
NOTE: Table WORK.LEAVES created, with 16 rows and 1 columns.
 
MPRINT(TMHIERTREE):   create table singlepar as select _name_ as n from nosingle where _parent_ not in (select _parent_ from nosingle where _name_ not eq n) and _parent_ ne '';
NOTE: Table WORK.SINGLEPAR created, with 1 rows and 1 columns.
 
MPRINT(TMHIERTREE):   create table leaves2 as select * from singlepar where n in (select _name_ from leaves);
NOTE: Table WORK.LEAVES2 created, with 0 rows and 1 columns.
 
MPRINT(TMHIERTREE):   select count(*) into :cnt from leaves2;
MPRINT(TMHIERTREE):   delete from nosingle where _name_ in (select n from leaves2);
NOTE: No rows were deleted from WORK.NOSINGLE.
 
MPRINT(TMHIERTREE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.14 초
      cpu 시간            0.14 초
 
 
MPRINT(TMHIERTREE):   data _fastclusstat;
MPRINT(TMHIERTREE):   set _fastclusstat;
MPRINT(TMHIERTREE):   format _name_ $ 5.;
MPRINT(TMHIERTREE):   _name_='CL'||left(cluster);
MPRINT(TMHIERTREE):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      80:83
NOTE: 496개의 관측값을 데이터셋 WORK._FASTCLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._FASTCLUSSTAT은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):   proc sort data=_fastclusstat;
MPRINT(TMHIERTREE):   by _name_;
MPRINT(TMHIERTREE):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._FASTCLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._FASTCLUSSTAT은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):   proc sort data=nosingle;
MPRINT(TMHIERTREE):   by _name_;
MPRINT(TMHIERTREE):   run;
 
NOTE: 32개의 관측값을 데이터셋 WORK.NOSINGLE.에서 읽었습니다.
NOTE: 데이터셋 WORK.NOSINGLE은(는) 32개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):   proc sort data=_outtree;
MPRINT(TMHIERTREE):   by _name_;
MPRINT(TMHIERTREE):   run;
 
NOTE: 399개의 관측값을 데이터셋 WORK._OUTTREE.에서 읽었습니다.
NOTE: 데이터셋 WORK._OUTTREE은(는) 399개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):   proc sql noprint;
MPRINT(TMHIERTREE):   create table newpars( _name_ char(8), parent char(8));
NOTE: Table WORK.NEWPARS created, with 0 rows and 2 columns.
MPRINT(TMHIERTREE):   insert into newpars values('CL1','CL1');
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TMHIERTREE):   select count(*) into :clusts from _outtree where _name_ like 'CL%';
MPRINT(TMHIERTREE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL2";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL2", "CL2");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL3";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL3", "CL3");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL4";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL4", "CL4");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL5";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL5", "CL5");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL6";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL6", "CL6");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL7";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL7", "CL7");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL8";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL8", "CL8");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL9";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL9", "CL9");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL10";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL10", "CL10");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL11";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL11", "CL11");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL12";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL12", "CL12");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL13";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL13", "CL13");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL14";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL14", "CL14");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL15";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL15", "CL15");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL16";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL16", "CL16");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL17";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL17", "CL17");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL18";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL18", "CL18");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL19";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL19", "CL19");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL20";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL20";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL17";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL20", "CL17");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL21";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL21", "CL21");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL22";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL22", "CL22");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL23";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL23", "CL23");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL24";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL24";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL14";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL24", "CL14");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL25";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL25";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL20";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL20";
MPRINT(TRACEPAR):   insert into newpars values("CL25","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL26";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL26";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL21";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL26", "CL21");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL27";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL27";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL22";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL27", "CL22");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL28";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL28", "CL28");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL29";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL29", "CL29");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL30";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL30";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL13";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL30", "CL13");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL31";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL31", "CL31");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL32";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL32";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL27";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL27";
MPRINT(TRACEPAR):   insert into newpars values("CL32","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL33";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL33";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL28";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL33", "CL28");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL34";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL34", "CL34");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL35";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL35", "CL35");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL36";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL36", "CL36");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL37";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL37";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL11";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL37", "CL11");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL38";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL38";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL29";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL38", "CL29");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL39";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL39", "CL39");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL40";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL40";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL31";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL40", "CL31");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL41";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL41", "CL41");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL42";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL42";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL25";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL25";
MPRINT(TRACEPAR):   insert into newpars values("CL42","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL43";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL43", "CL43");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL44";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL44", "CL44");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL45";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL45";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL25";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL25";
MPRINT(TRACEPAR):   insert into newpars values("CL45","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL46";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL46";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL22";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL46", "CL22");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL47";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL47";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL13";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL47", "CL13");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL48";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL48";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL34";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL48", "CL34");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL49";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL49";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL14";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL49", "CL14");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL50";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL50";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL31";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL50", "CL31");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL51";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL51";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL42";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL42";
MPRINT(TRACEPAR):   insert into newpars values("CL51","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL52";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL52";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL11";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL52", "CL11");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL53";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL53";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL7";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL53", "CL7");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL54";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL54";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL38";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL38";
MPRINT(TRACEPAR):   insert into newpars values("CL54","CL29    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL55";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL55";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL32";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL32";
MPRINT(TRACEPAR):   insert into newpars values("CL55","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL56";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL56";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL30";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL30";
MPRINT(TRACEPAR):   insert into newpars values("CL56","CL13    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL57";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL57";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL24";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL24";
MPRINT(TRACEPAR):   insert into newpars values("CL57","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL58";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL58";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL53";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL53";
MPRINT(TRACEPAR):   insert into newpars values("CL58","CL7     ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL59";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL59";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL39";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL59", "CL39");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL60";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL60";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL41";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL60", "CL41");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL61";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL61";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL35";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL61", "CL35");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL62";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL62";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL27";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL27";
MPRINT(TRACEPAR):   insert into newpars values("CL62","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL63";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL63";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL36";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL63", "CL36");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL64";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL64";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL37";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL37";
MPRINT(TRACEPAR):   insert into newpars values("CL64","CL11    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL65";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL65";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL40";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL40";
MPRINT(TRACEPAR):   insert into newpars values("CL65","CL31    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL66";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL66";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL49";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL49";
MPRINT(TRACEPAR):   insert into newpars values("CL66","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL67";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL67";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL59";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL59";
MPRINT(TRACEPAR):   insert into newpars values("CL67","CL39    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL68";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL68";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL21";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL68", "CL21");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL69";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL69";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL32";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL32";
MPRINT(TRACEPAR):   insert into newpars values("CL69","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL70";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL70";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL38";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL38";
MPRINT(TRACEPAR):   insert into newpars values("CL70","CL29    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL71";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL71";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL33";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL33";
MPRINT(TRACEPAR):   insert into newpars values("CL71","CL28    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL72";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL72";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL36";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL72", "CL36");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL73";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL73";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL40";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL40";
MPRINT(TRACEPAR):   insert into newpars values("CL73","CL31    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL74";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL74";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL44";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL74", "CL44");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL75";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL75";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL17";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL75", "CL17");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL76";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL76";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL26";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL26";
MPRINT(TRACEPAR):   insert into newpars values("CL76","CL21    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL77";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL77";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL47";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL47";
MPRINT(TRACEPAR):   insert into newpars values("CL77","CL13    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL78";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL78";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL57";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL57";
MPRINT(TRACEPAR):   insert into newpars values("CL78","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL79";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL79";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL56";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL56";
MPRINT(TRACEPAR):   insert into newpars values("CL79","CL13    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL80";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL80";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL44";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL80", "CL44");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL81";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL81";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL30";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL30";
MPRINT(TRACEPAR):   insert into newpars values("CL81","CL13    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL82";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL82";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL53";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL53";
MPRINT(TRACEPAR):   insert into newpars values("CL82","CL7     ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL83";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL83";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL72";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL72";
MPRINT(TRACEPAR):   insert into newpars values("CL83","CL36    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL84";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL84";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL52";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL52";
MPRINT(TRACEPAR):   insert into newpars values("CL84","CL11    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL85";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL85";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL47";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL47";
MPRINT(TRACEPAR):   insert into newpars values("CL85","CL13    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL86";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL86";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL34";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL86", "CL34");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL87";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL87";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL58";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL58";
MPRINT(TRACEPAR):   insert into newpars values("CL87","CL7     ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL88";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL88";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL60";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL60";
MPRINT(TRACEPAR):   insert into newpars values("CL88","CL41    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL89";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL89";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL45";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL45";
MPRINT(TRACEPAR):   insert into newpars values("CL89","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL90";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL90";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL54";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL54";
MPRINT(TRACEPAR):   insert into newpars values("CL90","CL29    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL91";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL91";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL24";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL24";
MPRINT(TRACEPAR):   insert into newpars values("CL91","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL92";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL92";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL43";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL92", "CL43");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL93";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL93";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL70";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL70";
MPRINT(TRACEPAR):   insert into newpars values("CL93","CL29    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL94";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL94";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL69";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL69";
MPRINT(TRACEPAR):   insert into newpars values("CL94","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL95";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL95";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL55";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL55";
MPRINT(TRACEPAR):   insert into newpars values("CL95","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL96";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL96";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL46";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL46";
MPRINT(TRACEPAR):   insert into newpars values("CL96","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL97";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL97";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL50";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL50";
MPRINT(TRACEPAR):   insert into newpars values("CL97","CL31    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL98";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL98";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL67";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL67";
MPRINT(TRACEPAR):   insert into newpars values("CL98","CL39    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL99";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL99";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL52";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL52";
MPRINT(TRACEPAR):   insert into newpars values("CL99","CL11    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL100";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL100";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL29";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL100", "CL29");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL101";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL101";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL28";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL101", "CL28");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL102";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL102";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL61";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL61";
MPRINT(TRACEPAR):   insert into newpars values("CL102","CL35    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL103";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL103";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL58";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL58";
MPRINT(TRACEPAR):   insert into newpars values("CL103","CL7     ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL104";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL104";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL51";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL51";
MPRINT(TRACEPAR):   insert into newpars values("CL104","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL105";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL105";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL48";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL48";
MPRINT(TRACEPAR):   insert into newpars values("CL105","CL34    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL106";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL106";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL71";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL71";
MPRINT(TRACEPAR):   insert into newpars values("CL106","CL28    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL107";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL107";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL75";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL75";
MPRINT(TRACEPAR):   insert into newpars values("CL107","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL108";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL108";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL37";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL37";
MPRINT(TRACEPAR):   insert into newpars values("CL108","CL11    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL109";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL109";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL67";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL67";
MPRINT(TRACEPAR):   insert into newpars values("CL109","CL39    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL110";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL110";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL90";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL90";
MPRINT(TRACEPAR):   insert into newpars values("CL110","CL29    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL111";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL111";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL46";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL46";
MPRINT(TRACEPAR):   insert into newpars values("CL111","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL112";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL112";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL26";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL26";
MPRINT(TRACEPAR):   insert into newpars values("CL112","CL21    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL113";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL113";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL59";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL59";
MPRINT(TRACEPAR):   insert into newpars values("CL113","CL39    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL114";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL114";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL66";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL66";
MPRINT(TRACEPAR):   insert into newpars values("CL114","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL115";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL115";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL35";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL115", "CL35");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL116";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL116";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL84";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL84";
MPRINT(TRACEPAR):   insert into newpars values("CL116","CL11    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL117";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL117";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL73";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL73";
MPRINT(TRACEPAR):   insert into newpars values("CL117","CL31    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL118";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL118";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL86";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL86";
MPRINT(TRACEPAR):   insert into newpars values("CL118","CL34    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL119";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL119";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL62";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL62";
MPRINT(TRACEPAR):   insert into newpars values("CL119","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL120";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL120";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL60";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL60";
MPRINT(TRACEPAR):   insert into newpars values("CL120","CL41    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL121";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL121";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL42";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL42";
MPRINT(TRACEPAR):   insert into newpars values("CL121","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL122";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL122";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL78";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL78";
MPRINT(TRACEPAR):   insert into newpars values("CL122","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL123";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL123";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL66";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL66";
MPRINT(TRACEPAR):   insert into newpars values("CL123","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL124";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL124";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL45";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL45";
MPRINT(TRACEPAR):   insert into newpars values("CL124","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL125";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL125";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL99";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL99";
MPRINT(TRACEPAR):   insert into newpars values("CL125","CL11    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL126";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL126";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL63";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL63";
MPRINT(TRACEPAR):   insert into newpars values("CL126","CL36    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL127";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL127";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL68";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL68";
MPRINT(TRACEPAR):   insert into newpars values("CL127","CL21    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL128";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL128";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL69";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL69";
MPRINT(TRACEPAR):   insert into newpars values("CL128","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL129";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL129";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL70";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL70";
MPRINT(TRACEPAR):   insert into newpars values("CL129","CL29    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL130";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL130";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL85";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL85";
MPRINT(TRACEPAR):   insert into newpars values("CL130","CL13    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL131";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL131";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL33";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL33";
MPRINT(TRACEPAR):   insert into newpars values("CL131","CL28    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL132";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL132";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL43";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL132", "CL43");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL133";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL133";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL57";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL57";
MPRINT(TRACEPAR):   insert into newpars values("CL133","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL134";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL134";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL76";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL76";
MPRINT(TRACEPAR):   insert into newpars values("CL134","CL21    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL135";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL135";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL71";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL71";
MPRINT(TRACEPAR):   insert into newpars values("CL135","CL28    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL136";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL136";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL104";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL104";
MPRINT(TRACEPAR):   insert into newpars values("CL136","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL137";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL137";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL90";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL90";
MPRINT(TRACEPAR):   insert into newpars values("CL137","CL29    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL138";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL138";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL107";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL107";
MPRINT(TRACEPAR):   insert into newpars values("CL138","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL139";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL139";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL127";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL127";
MPRINT(TRACEPAR):   insert into newpars values("CL139","CL21    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL140";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL140";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL88";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL88";
MPRINT(TRACEPAR):   insert into newpars values("CL140","CL41    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL141";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL141";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL101";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL101";
MPRINT(TRACEPAR):   insert into newpars values("CL141","CL28    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL142";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL142";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL64";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL64";
MPRINT(TRACEPAR):   insert into newpars values("CL142","CL11    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL143";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL143";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL79";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL79";
MPRINT(TRACEPAR):   insert into newpars values("CL143","CL13    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL144";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL144";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL61";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL61";
MPRINT(TRACEPAR):   insert into newpars values("CL144","CL35    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL145";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL145";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL103";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL103";
MPRINT(TRACEPAR):   insert into newpars values("CL145","CL7     ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL146";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL146";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL48";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL48";
MPRINT(TRACEPAR):   insert into newpars values("CL146","CL34    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL147";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL147";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL50";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL50";
MPRINT(TRACEPAR):   insert into newpars values("CL147","CL31    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL148";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL148";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL80";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL80";
MPRINT(TRACEPAR):   insert into newpars values("CL148","CL44    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL149";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL149";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL91";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL91";
MPRINT(TRACEPAR):   insert into newpars values("CL149","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL150";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL150";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL49";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL49";
MPRINT(TRACEPAR):   insert into newpars values("CL150","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL151";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL151";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL136";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL136";
MPRINT(TRACEPAR):   insert into newpars values("CL151","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL152";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL152";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL92";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL92";
MPRINT(TRACEPAR):   insert into newpars values("CL152","CL43    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL153";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL153";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL68";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL68";
MPRINT(TRACEPAR):   insert into newpars values("CL153","CL21    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL154";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL154";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL55";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL55";
MPRINT(TRACEPAR):   insert into newpars values("CL154","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL155";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL155";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL41";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL155", "CL41");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL156";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL156";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL133";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL133";
MPRINT(TRACEPAR):   insert into newpars values("CL156","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL157";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL157";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL114";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL114";
MPRINT(TRACEPAR):   insert into newpars values("CL157","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL158";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL158";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL64";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL64";
MPRINT(TRACEPAR):   insert into newpars values("CL158","CL11    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL159";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL159";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL39";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   insert into newpars values("CL159", "CL39");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL160";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL160";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL89";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL89";
MPRINT(TRACEPAR):   insert into newpars values("CL160","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL161";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL161";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL159";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL159";
MPRINT(TRACEPAR):   insert into newpars values("CL161","CL39    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL162";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL162";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL65";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL65";
MPRINT(TRACEPAR):   insert into newpars values("CL162","CL31    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL163";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL163";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL63";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL63";
MPRINT(TRACEPAR):   insert into newpars values("CL163","CL36    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL164";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL164";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL74";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL74";
MPRINT(TRACEPAR):   insert into newpars values("CL164","CL44    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL165";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL165";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL81";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL81";
MPRINT(TRACEPAR):   insert into newpars values("CL165","CL13    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL166";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL166";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL98";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL98";
MPRINT(TRACEPAR):   insert into newpars values("CL166","CL39    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL167";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL167";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL137";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL137";
MPRINT(TRACEPAR):   insert into newpars values("CL167","CL29    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL168";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL168";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL73";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL73";
MPRINT(TRACEPAR):   insert into newpars values("CL168","CL31    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL169";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL169";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL105";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL105";
MPRINT(TRACEPAR):   insert into newpars values("CL169","CL34    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL170";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL170";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL51";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL51";
MPRINT(TRACEPAR):   insert into newpars values("CL170","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL171";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
SAS 시스템
 
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL171";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL113";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL113";
MPRINT(TRACEPAR):   insert into newpars values("CL171","CL39    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL172";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL172";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL96";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL96";
MPRINT(TRACEPAR):   insert into newpars values("CL172","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL173";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL173";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL56";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL56";
MPRINT(TRACEPAR):   insert into newpars values("CL173","CL13    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL174";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL174";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL105";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL105";
MPRINT(TRACEPAR):   insert into newpars values("CL174","CL34    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL175";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL175";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL140";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL140";
MPRINT(TRACEPAR):   insert into newpars values("CL175","CL41    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL176";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL176";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL152";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL152";
MPRINT(TRACEPAR):   insert into newpars values("CL176","CL43    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL177";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL177";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL20";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL20";
MPRINT(TRACEPAR):   insert into newpars values("CL177","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL178";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL178";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL112";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL112";
MPRINT(TRACEPAR):   insert into newpars values("CL178","CL21    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL179";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL179";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL77";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL77";
MPRINT(TRACEPAR):   insert into newpars values("CL179","CL13    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL180";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL180";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL82";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL82";
MPRINT(TRACEPAR):   insert into newpars values("CL180","CL7     ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL181";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL181";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL98";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL98";
MPRINT(TRACEPAR):   insert into newpars values("CL181","CL39    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL182";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL182";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL146";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL146";
MPRINT(TRACEPAR):   insert into newpars values("CL182","CL34    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL183";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL183";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL91";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL91";
MPRINT(TRACEPAR):   insert into newpars values("CL183","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL184";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL184";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL109";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL109";
MPRINT(TRACEPAR):   insert into newpars values("CL184","CL39    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL185";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL185";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL108";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL108";
MPRINT(TRACEPAR):   insert into newpars values("CL185","CL11    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL186";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL186";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL172";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL172";
MPRINT(TRACEPAR):   insert into newpars values("CL186","CL22    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL187";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL187";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL114";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL114";
MPRINT(TRACEPAR):   insert into newpars values("CL187","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL188";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL188";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL130";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL130";
MPRINT(TRACEPAR):   insert into newpars values("CL188","CL13    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL189";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL189";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL84";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL84";
MPRINT(TRACEPAR):   insert into newpars values("CL189","CL11    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL190";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL190";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL76";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL76";
MPRINT(TRACEPAR):   insert into newpars values("CL190","CL21    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL191";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL191";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL93";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL93";
MPRINT(TRACEPAR):   insert into newpars values("CL191","CL29    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL192";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL192";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL142";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL142";
MPRINT(TRACEPAR):   insert into newpars values("CL192","CL11    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL193";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL193";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL129";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL129";
MPRINT(TRACEPAR):   insert into newpars values("CL193","CL29    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL194";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL194";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL183";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL183";
MPRINT(TRACEPAR):   insert into newpars values("CL194","CL14    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL195";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL195";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL180";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL180";
MPRINT(TRACEPAR):   insert into newpars values("CL195","CL7     ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL196";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL196";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL176";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL176";
MPRINT(TRACEPAR):   insert into newpars values("CL196","CL43    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL197";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL197";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL191";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL191";
MPRINT(TRACEPAR):   insert into newpars values("CL197","CL29    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL198";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL198";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL182";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL182";
MPRINT(TRACEPAR):   insert into newpars values("CL198","CL34    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from nosingle where _name_="CL199";
NOTE: No rows were selected.
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select _parent_ into :parent from _outtree where _name_="CL199";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select count(*) into :exists from nosingle where _name_="CL177";
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TRACEPAR):   proc sql noprint;
MPRINT(TRACEPAR):   select parent into :parent from newpars where _name_="CL177";
MPRINT(TRACEPAR):   insert into newpars values("CL199","CL17    ");
NOTE: 1 row was inserted into WORK.NEWPARS.
 
MPRINT(TRACEPAR):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMHIERTREE):  ;
MPRINT(TMHIERTREE):   proc sort data=newpars;
MPRINT(TMHIERTREE):   by _name_;
MPRINT(TMHIERTREE):   run;
 
NOTE: 199개의 관측값을 데이터셋 WORK.NEWPARS.에서 읽었습니다.
NOTE: 데이터셋 WORK.NEWPARS은(는) 199개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMHIERTREE):   data _fastclusstat;
MPRINT(TMHIERTREE):   merge _fastclusstat(rename=(cluster=_SUBCLUSTER_)) newpars;
MPRINT(TMHIERTREE):   by _name_;
MPRINT(TMHIERTREE):   _CLUSTER_=input(substr(parent,3.),8.);
MPRINT(TMHIERTREE):   cluster=parent;
MPRINT(TMHIERTREE):   drop parent _name_;
MPRINT(TMHIERTREE):   run;
 
WARNING: 입력 데이터셋으로 BY 변수 _name_에 대해 여러 길이가 지정되었습니다. 예상하지 못한 결과를 발생시킬 수 있습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._FASTCLUSSTAT.에서 읽었습니다.
NOTE: 199개의 관측값을 데이터셋 WORK.NEWPARS.에서 읽었습니다.
NOTE: 데이터셋 WORK._FASTCLUSSTAT은(는) 496개의 관측값과 50개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):   proc sql noprint;
MPRINT(TMHIERTREE):   create table _calctree as select * from _outtree where _name_ like 'CL%';
NOTE: Table WORK._CALCTREE created, with 199 rows and 62 columns.
 
MPRINT(TMHIERTREE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):   proc distance data=_calctree out=_calctree method=EUCLID nostd;
MPRINT(TMHIERTREE):   var RATIO (TextCluster5_SVD1-TextCluster5_SVD45);
MPRINT(TMHIERTREE):   id _name_;
MPRINT(TMHIERTREE):   run;
 
WARNING: Found negative value(s) in the ratio variable(s). The distance matrix may be meaningless.
NOTE: 데이터셋 WORK._CALCTREE은(는) 199개의 관측값과 200개의 변수를 가지고 있습니다.
NOTE: 프로시저 DISTANCE 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
 
MPRINT(TMHIERTREE):   proc mds data=_calctree out=_calctree level=ratio dimension=2 noprint;
MPRINT(TMHIERTREE):   run;
 
NOTE: Convergence reached in 12 iterations.
NOTE: 데이터셋 WORK._CALCTREE은(는) 201개의 관측값과 7개의 변수를 가지고 있습니다.
NOTE: 프로시저 MDS 실행(총 프로세스 시간):
      실행 시간           2.11 초
      cpu 시간            2.07 초
 
 
MPRINT(TMHIERTREE):   proc sql noprint;
MPRINT(TMHIERTREE):   create table _parclustree as select distinct *, count(*) into :cnt from _fastclusstat where cluster not in (select _name_ from leaves);
WARNING: INTO clause is ignored in the CREATE TABLE statement.
WARNING: INTO clause specifies fewer host variables than columns listed in the SELECT clause.
NOTE: The query requires remerging summary statistics back with the original data.
NOTE: Table WORK._PARCLUSTREE created, with 108 rows and 51 columns.
 
MPRINT(TMHIERTREE):   create table _leafdims as select _name_ as leafname, dim1 as leafdim1, dim2 as leafdim2 from _calctree where _name_ in (select _name_ from leaves);
NOTE: Table WORK._LEAFDIMS created, with 16 rows and 3 columns.
 
MPRINT(TMHIERTREE):   create table _nonleafdims as select _name_, dim1, dim2 from _calctree where _name_ in (select cluster from _parclustree);
NOTE: Table WORK._NONLEAFDIMS created, with 18 rows and 3 columns.
 
MPRINT(TMHIERTREE):   create table _parclustree as select a.*, b.* from _leafdims a, _nonleafdims b;
NOTE: The execution of this query involves performing one or more Cartesian product joins that can not be optimized.
NOTE: Table WORK._PARCLUSTREE created, with 288 rows and 6 columns.
 
MPRINT(TMHIERTREE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.16 초
      cpu 시간            0.17 초
 
 
MPRINT(TMHIERTREE):   data _parclustree;
MPRINT(TMHIERTREE):   set _parclustree;
MPRINT(TMHIERTREE):   distance=sqrt((dim1-leafdim1)**2+(dim2-leafdim2)**2);
MPRINT(TMHIERTREE):   run;
 
NOTE: 결측값을 사용한 연산의 결과로 결측값을 생성했습니다.
      생성 정보: (발생횟수) || (행):(칼럼).
      32 || 490:114   32 || 490:137   32 || 490:143   32 || 490:153
NOTE: 288개의 관측값을 데이터셋 WORK._PARCLUSTREE.에서 읽었습니다.
NOTE: 데이터셋 WORK._PARCLUSTREE은(는) 288개의 관측값과 7개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):   proc sql noprint;
MPRINT(TMHIERTREE):   create table _reroute as select _name_, min(distance) as distance from _parclustree group by _name_;
NOTE: Table WORK._REROUTE created, with 17 rows and 2 columns.
 
MPRINT(TMHIERTREE):   create table _rerouteclus as select a._name_, a.distance, leafname from _reroute a, _parclustree b where a._name_ ne '' and a._name_=b._name_ and a.distance=b.distance;
NOTE: Table WORK._REROUTECLUS created, with 16 rows and 3 columns.
 
MPRINT(TMHIERTREE):   update _fastclusstat set cluster=(select leafname from _rerouteclus where _name_=cluster) where cluster in (select _name_ from _rerouteclus);
WARNING: Character expression will be truncated when assigned to character column cluster.
NOTE: 107 rows were updated in WORK._FASTCLUSSTAT.
 
MPRINT(TMHIERTREE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.13 초
      cpu 시간            0.12 초
 
 
MPRINT(TMHIERTREE):   data _fastclusstat;
MPRINT(TMHIERTREE):   set _fastclusstat;
MPRINT(TMHIERTREE):   _FINALCLUSTER_=_CLUSTER_;
MPRINT(TMHIERTREE):   _CLUSTER_=input(substr(cluster,3.),8.);
MPRINT(TMHIERTREE):   drop cluster;
MPRINT(TMHIERTREE):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._FASTCLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._FASTCLUSSTAT은(는) 496개의 관측값과 50개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):   data EMWS5.TextCluster5_hierds;
MPRINT(TMHIERTREE):   set nosingle;
MPRINT(TMHIERTREE):   run;
 
NOTE: 32개의 관측값을 데이터셋 WORK.NOSINGLE.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 62개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMHIERTREE):   proc sql noprint;
MPRINT(TMHIERTREE):   drop table leaves;
NOTE: 테이블 WORK.LEAVES 을(를) 삭제했습니다.
MPRINT(TMHIERTREE):   drop table singlepar;
NOTE: 테이블 WORK.SINGLEPAR 을(를) 삭제했습니다.
MPRINT(TMHIERTREE):   drop table leaves2;
NOTE: 테이블 WORK.LEAVES2 을(를) 삭제했습니다.
MPRINT(TMHIERTREE):   drop table _calctree;
NOTE: 테이블 WORK._CALCTREE 을(를) 삭제했습니다.
MPRINT(TMHIERTREE):   drop table _leafdims;
NOTE: 테이블 WORK._LEAFDIMS 을(를) 삭제했습니다.
MPRINT(TMHIERTREE):   drop table _nonleafdims;
NOTE: 테이블 WORK._NONLEAFDIMS 을(를) 삭제했습니다.
MPRINT(TMHIERTREE):   drop table _parclustree;
NOTE: 테이블 WORK._PARCLUSTREE 을(를) 삭제했습니다.
MPRINT(TMHIERTREE):   drop table _reroute;
NOTE: 테이블 WORK._REROUTE 을(를) 삭제했습니다.
MPRINT(TMHIERTREE):   drop table _rerouteclus;
NOTE: 테이블 WORK._REROUTECLUS 을(를) 삭제했습니다.
MPRINT(TMHIERTREE):   drop table newpars;
NOTE: 테이블 WORK.NEWPARS 을(를) 삭제했습니다.
MPRINT(TMHIERTREE):   drop table nosingle;
NOTE: 테이블 WORK.NOSINGLE 을(를) 삭제했습니다.
MPRINT(TMHIERTREE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
 
 
MPRINT(TMGETHCLUS):  ;
MPRINT(TMGETHCLUS):   data EMWS5.TextCluster5_docs;
MPRINT(TMGETHCLUS):   set _fastclusstat;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._FASTCLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_DOCS은(는) 496개의 관측값과 50개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   data EMWS5.TextCluster5_hierds;
MPRINT(TMGETHCLUS):   set EMWS5.TextCluster5_hierds;
MPRINT(TMGETHCLUS):   _cluster_=input(substr(_name_,3),8.);
MPRINT(TMGETHCLUS):   parent=input(substr(_parent_,3),8.);
MPRINT(TMGETHCLUS):   if _cluster_=1 then level=1;
MPRINT(TMGETHCLUS):   else level=.;
MPRINT(TMGETHCLUS):   drop _name_ _parent_;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 63개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMGETHCLUS):   data EMWS5.TextCluster5_hierds (drop=newparstr cnt i);
MPRINT(TMGETHCLUS):   array newpars(32) $ _TEMPORARY_;
MPRINT(TMGETHCLUS):   set EMWS5.TextCluster5_hierds end=lastrow;
MPRINT(TMGETHCLUS):   retain cnt;
MPRINT(TMGETHCLUS):   if _n_=1 then cnt=1;
MPRINT(TMGETHCLUS):   if parent in (1) then do;
MPRINT(TMGETHCLUS):   newpars(cnt)=put(left(_cluster_),8.);
MPRINT(TMGETHCLUS):   cnt = cnt + 1;
MPRINT(TMGETHCLUS):   level=2;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   if lastrow then do;
MPRINT(TMGETHCLUS):   i=2;
MPRINT(TMGETHCLUS):   newparstr=put(newpars(1),$160.);
MPRINT(TMGETHCLUS):   do while (i < cnt);
MPRINT(TMGETHCLUS):   newparstr=CATX(', ', newparstr, newpars(i));
MPRINT(TMGETHCLUS):   i = i + 1;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   call symput('newpars',newparstr);
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      75:40
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 63개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.06 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :empty from EMWS5.TextCluster5_hierds where level=.;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data EMWS5.TextCluster5_hierds (drop=newparstr cnt i);
MPRINT(TMGETHCLUS):   array newpars(32) $ _TEMPORARY_;
MPRINT(TMGETHCLUS):   set EMWS5.TextCluster5_hierds end=lastrow;
MPRINT(TMGETHCLUS):   retain cnt;
MPRINT(TMGETHCLUS):   if _n_=1 then cnt=1;
MPRINT(TMGETHCLUS):   if parent in (2, 7) then do;
MPRINT(TMGETHCLUS):   newpars(cnt)=put(left(_cluster_),8.);
MPRINT(TMGETHCLUS):   cnt = cnt + 1;
MPRINT(TMGETHCLUS):   level=3;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   if lastrow then do;
MPRINT(TMGETHCLUS):   i=2;
MPRINT(TMGETHCLUS):   newparstr=put(newpars(1),$160.);
MPRINT(TMGETHCLUS):   do while (i < cnt);
MPRINT(TMGETHCLUS):   newparstr=CATX(', ', newparstr, newpars(i));
MPRINT(TMGETHCLUS):   i = i + 1;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   call symput('newpars',newparstr);
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      83:40
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 63개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :empty from EMWS5.TextCluster5_hierds where level=.;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMGETHCLUS):   data EMWS5.TextCluster5_hierds (drop=newparstr cnt i);
MPRINT(TMGETHCLUS):   array newpars(32) $ _TEMPORARY_;
MPRINT(TMGETHCLUS):   set EMWS5.TextCluster5_hierds end=lastrow;
MPRINT(TMGETHCLUS):   retain cnt;
MPRINT(TMGETHCLUS):   if _n_=1 then cnt=1;
MPRINT(TMGETHCLUS):   if parent in (19, 29, 3) then do;
MPRINT(TMGETHCLUS):   newpars(cnt)=put(left(_cluster_),8.);
MPRINT(TMGETHCLUS):   cnt = cnt + 1;
MPRINT(TMGETHCLUS):   level=4;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   if lastrow then do;
MPRINT(TMGETHCLUS):   i=2;
MPRINT(TMGETHCLUS):   newparstr=put(newpars(1),$160.);
MPRINT(TMGETHCLUS):   do while (i < cnt);
MPRINT(TMGETHCLUS):   newparstr=CATX(', ', newparstr, newpars(i));
MPRINT(TMGETHCLUS):   i = i + 1;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   call symput('newpars',newparstr);
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      91:40
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 63개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.04 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :empty from EMWS5.TextCluster5_hierds where level=.;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMGETHCLUS):   data EMWS5.TextCluster5_hierds (drop=newparstr cnt i);
MPRINT(TMGETHCLUS):   array newpars(32) $ _TEMPORARY_;
MPRINT(TMGETHCLUS):   set EMWS5.TextCluster5_hierds end=lastrow;
MPRINT(TMGETHCLUS):   retain cnt;
MPRINT(TMGETHCLUS):   if _n_=1 then cnt=1;
MPRINT(TMGETHCLUS):   if parent in (34, 39, 4, 5) then do;
MPRINT(TMGETHCLUS):   newpars(cnt)=put(left(_cluster_),8.);
MPRINT(TMGETHCLUS):   cnt = cnt + 1;
MPRINT(TMGETHCLUS):   level=5;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   if lastrow then do;
MPRINT(TMGETHCLUS):   i=2;
MPRINT(TMGETHCLUS):   newparstr=put(newpars(1),$160.);
MPRINT(TMGETHCLUS):   do while (i < cnt);
MPRINT(TMGETHCLUS):   newparstr=CATX(', ', newparstr, newpars(i));
MPRINT(TMGETHCLUS):   i = i + 1;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   call symput('newpars',newparstr);
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      99:40
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 63개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :empty from EMWS5.TextCluster5_hierds where level=.;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data EMWS5.TextCluster5_hierds (drop=newparstr cnt i);
MPRINT(TMGETHCLUS):   array newpars(32) $ _TEMPORARY_;
MPRINT(TMGETHCLUS):   set EMWS5.TextCluster5_hierds end=lastrow;
MPRINT(TMGETHCLUS):   retain cnt;
MPRINT(TMGETHCLUS):   if _n_=1 then cnt=1;
MPRINT(TMGETHCLUS):   if parent in (10, 14, 6, 9) then do;
MPRINT(TMGETHCLUS):   newpars(cnt)=put(left(_cluster_),8.);
MPRINT(TMGETHCLUS):   cnt = cnt + 1;
MPRINT(TMGETHCLUS):   level=6;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   if lastrow then do;
MPRINT(TMGETHCLUS):   i=2;
MPRINT(TMGETHCLUS):   newparstr=put(newpars(1),$160.);
MPRINT(TMGETHCLUS):   do while (i < cnt);
MPRINT(TMGETHCLUS):   newparstr=CATX(', ', newparstr, newpars(i));
MPRINT(TMGETHCLUS):   i = i + 1;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   call symput('newpars',newparstr);
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      107:40
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 63개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :empty from EMWS5.TextCluster5_hierds where level=.;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data EMWS5.TextCluster5_hierds (drop=newparstr cnt i);
MPRINT(TMGETHCLUS):   array newpars(32) $ _TEMPORARY_;
MPRINT(TMGETHCLUS):   set EMWS5.TextCluster5_hierds end=lastrow;
MPRINT(TMGETHCLUS):   retain cnt;
MPRINT(TMGETHCLUS):   if _n_=1 then cnt=1;
MPRINT(TMGETHCLUS):   if parent in (11, 12, 18, 21, 41, 8) then do;
MPRINT(TMGETHCLUS):   newpars(cnt)=put(left(_cluster_),8.);
MPRINT(TMGETHCLUS):   cnt = cnt + 1;
MPRINT(TMGETHCLUS):   level=7;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   if lastrow then do;
MPRINT(TMGETHCLUS):   i=2;
MPRINT(TMGETHCLUS):   newparstr=put(newpars(1),$160.);
MPRINT(TMGETHCLUS):   do while (i < cnt);
MPRINT(TMGETHCLUS):   newparstr=CATX(', ', newparstr, newpars(i));
MPRINT(TMGETHCLUS):   i = i + 1;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   call symput('newpars',newparstr);
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      115:40
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 63개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :empty from EMWS5.TextCluster5_hierds where level=.;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data EMWS5.TextCluster5_hierds (drop=newparstr cnt i);
MPRINT(TMGETHCLUS):   array newpars(32) $ _TEMPORARY_;
MPRINT(TMGETHCLUS):   set EMWS5.TextCluster5_hierds end=lastrow;
MPRINT(TMGETHCLUS):   retain cnt;
MPRINT(TMGETHCLUS):   if _n_=1 then cnt=1;
MPRINT(TMGETHCLUS):   if parent in (13, 15, 16, 28, 31, 43) then do;
MPRINT(TMGETHCLUS):   newpars(cnt)=put(left(_cluster_),8.);
MPRINT(TMGETHCLUS):   cnt = cnt + 1;
MPRINT(TMGETHCLUS):   level=8;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   if lastrow then do;
MPRINT(TMGETHCLUS):   i=2;
MPRINT(TMGETHCLUS):   newparstr=put(newpars(1),$160.);
MPRINT(TMGETHCLUS):   do while (i < cnt);
MPRINT(TMGETHCLUS):   newparstr=CATX(', ', newparstr, newpars(i));
MPRINT(TMGETHCLUS):   i = i + 1;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   call symput('newpars',newparstr);
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      123:40
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 63개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :empty from EMWS5.TextCluster5_hierds where level=.;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMGETHCLUS):   data EMWS5.TextCluster5_hierds (drop=newparstr cnt i);
MPRINT(TMGETHCLUS):   array newpars(32) $ _TEMPORARY_;
MPRINT(TMGETHCLUS):   set EMWS5.TextCluster5_hierds end=lastrow;
MPRINT(TMGETHCLUS):   retain cnt;
MPRINT(TMGETHCLUS):   if _n_=1 then cnt=1;
MPRINT(TMGETHCLUS):   if parent in (17, 22, 23, 35) then do;
MPRINT(TMGETHCLUS):   newpars(cnt)=put(left(_cluster_),8.);
MPRINT(TMGETHCLUS):   cnt = cnt + 1;
MPRINT(TMGETHCLUS):   level=9;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   if lastrow then do;
MPRINT(TMGETHCLUS):   i=2;
MPRINT(TMGETHCLUS):   newparstr=put(newpars(1),$160.);
MPRINT(TMGETHCLUS):   do while (i < cnt);
MPRINT(TMGETHCLUS):   newparstr=CATX(', ', newparstr, newpars(i));
MPRINT(TMGETHCLUS):   i = i + 1;
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   call symput('newpars',newparstr);
MPRINT(TMGETHCLUS):   end;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      131:40
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 63개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.04 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select count(*) into :empty from EMWS5.TextCluster5_hierds where level=.;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   proc summary data = EMWS5.TextCluster5_docs (keep=_CLUSTER_ _SUBCLUSTER_ _FINALCLUSTER_ TextCluster5_SVD1 - TextCluster5_SVD45) noprint;
MPRINT(TMGETHCLUS):   var TextCluster5_SVD1 - TextCluster5_SVD45;
MPRINT(TMGETHCLUS):   class _CLUSTER_;
MPRINT(TMGETHCLUS):   output out = _clusstat;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_DOCS.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSSTAT은(는) 85개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.09 초
 
 
MPRINT(TMGETHCLUS):   data _NULL_;
MPRINT(TMGETHCLUS):   set _clusstat(where=(_CLUSTER_ = . and _STAT_ = 'N'));
MPRINT(TMGETHCLUS):   call symput('_TOT_', _FREQ_);
MPRINT(TMGETHCLUS):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      139:31
NOTE: 1개의 관측값을 데이터셋 WORK._CLUSSTAT.에서 읽었습니다.
      WHERE (_CLUSTER_=.) and (_STAT_='N');
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMGETHCLUS):   data _clusstat;
MPRINT(TMGETHCLUS):   set _clusstat(where=(_STAT_='MEAN'));
MPRINT(TMGETHCLUS):   if _CLUSTER_ = . then delete;
MPRINT(TMGETHCLUS):   drop _TYPE_ _STAT_;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 17개의 관측값을 데이터셋 WORK._CLUSSTAT.에서 읽었습니다.
      WHERE _STAT_='MEAN';
NOTE: 데이터셋 WORK._CLUSSTAT은(는) 16개의 관측값과 47개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   proc sql noprint;
MPRINT(TMGETHCLUS):   select sum(_FREQ_) into :totNumDocs from _clusstat;
MPRINT(TMGETHCLUS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMGETHCLUS):   data _clusstat (rename=(_FREQ_=Freq));
MPRINT(TMGETHCLUS):   set _clusstat;
MPRINT(TMGETHCLUS):   Percent=_FREQ_/ 495;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 16개의 관측값을 데이터셋 WORK._CLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSSTAT은(는) 16개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMGETHCLUS):   proc sort data=_clusstat;
MPRINT(TMGETHCLUS):   by _cluster_;
MPRINT(TMGETHCLUS):   run;
 
NOTE: 16개의 관측값을 데이터셋 WORK._CLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSSTAT은(는) 16개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   data _clusstat;
MPRINT(TM_CLUSTER):   set _clusstat(rename=(TextCluster5_SVD1 - TextCluster5_SVD45=_mean1-_mean45));
MPRINT(TM_CLUSTER):   run;
 
NOTE: 16개의 관측값을 데이터셋 WORK._CLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSSTAT은(는) 16개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_CLUSTER):   data _clustermean;
MPRINT(TM_CLUSTER):   set _clusstat(keep=_cluster_ _mean1-_mean45 rename=(_cluster_=cluster));
MPRINT(TM_CLUSTER):   run;
 
NOTE: 16개의 관측값을 데이터셋 WORK._CLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSTERMEAN은(는) 16개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   drop table _outtree;
NOTE: 테이블 WORK._OUTTREE 을(를) 삭제했습니다.
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   proc sql;
MPRINT(TM_CLUSTER):   create table _meandocs(drop=cluster) as select a.*, b.* from EMWS5.TextCluster5_docs a left join _clustermean b on a._cluster_=b.cluster ;
NOTE: Table WORK._MEANDOCS created, with 496 rows and 95 columns.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
 
 
MPRINT(TM_CLUSTER):   data _rmscalc;
MPRINT(TM_CLUSTER):   merge _meandocs(in=inhere) _clusstat;
MPRINT(TM_CLUSTER):   array _means(45) _mean1-_mean45;
MPRINT(TM_CLUSTER):   array _svds(45) TextCluster5_SVD1 - TextCluster5_SVD45;
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   error=0;
MPRINT(TM_CLUSTER):   do i = 1 to 45;
MPRINT(TM_CLUSTER):   error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
MPRINT(TM_CLUSTER):   end;
MPRINT(TM_CLUSTER):   drop i;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 결측값을 사용한 연산의 결과로 결측값을 생성했습니다.
      생성 정보: (발생횟수) || (행):(칼럼).
      45 || 303:131
NOTE: 496개의 관측값을 데이터셋 WORK._MEANDOCS.에서 읽었습니다.
NOTE: 16개의 관측값을 데이터셋 WORK._CLUSSTAT.에서 읽었습니다.
NOTE: 데이터셋 WORK._RMSCALC은(는) 496개의 관측값과 98개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_CLUSTER):   proc summary data=_rmscalc nway;
MPRINT(TM_CLUSTER):   class _cluster_;
MPRINT(TM_CLUSTER):   var error;
MPRINT(TM_CLUSTER):   output out=_meanerr mean=meane sum=sume;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._RMSCALC.에서 읽었습니다.
NOTE: 데이터셋 WORK._MEANERR은(는) 16개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   data _rmsse;
MPRINT(TM_CLUSTER):   set _meanerr;
MPRINT(TM_CLUSTER):   if _freq_ gt 1 then do;
MPRINT(TM_CLUSTER):   _rmsstd_=sqrt(sume/((_freq_-1)*(45)));
MPRINT(TM_CLUSTER):   end;
MPRINT(TM_CLUSTER):   else do;
MPRINT(TM_CLUSTER):   _rmsstd_=0;
MPRINT(TM_CLUSTER):   end;
MPRINT(TM_CLUSTER):   keep _cluster_ _rmsstd_;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 16개의 관측값을 데이터셋 WORK._MEANERR.에서 읽었습니다.
NOTE: 데이터셋 WORK._RMSSE은(는) 16개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   proc sql;
MPRINT(TM_CLUSTER):   create table _clusstat2(drop=cluster) as select a.*,b.* from _clustermean a left join _rmsse b on a.cluster=b._cluster_;
NOTE: Table WORK._CLUSSTAT2 created, with 16 rows and 47 columns.
 
MPRINT(TM_CLUSTER):   create table EMWS5.TextCluster5_clusters as select a.*, b.freq, b.percent from _clusstat2(keep=_cluster_ _mean1-_mean45 _rmsstd_) a right join _clusstat b on a._cluster_=b._cluster_ where b.freq>0 ;
NOTE: Table EMWS5.TEXTCLUSTER5_CLUSTERS created, with 16 rows and 49 columns.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.09 초
 
 
MPRINT(TM_CLUSTER):   filename temp catalog 'sashelp.emtext.tmterm1.source';
MPRINT(TM_CLUSTER):   proc sort data=EMWS5.TextFilter5_terms out=_terms_;
MPRINT(TM_CLUSTER):   by key _ispar;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 입력 데이터셋이 이미 정렬되어 있습니다; 출력 데이터셋에 복사되었습니다.
NOTE: 1376개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TERMS_DATA.에서 읽었습니다.
      WHERE KEEP='Y';
NOTE: 1377개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TERM_STRINGS.에서 읽었습니다.
NOTE: 1376개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TERMS.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 1376개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.24 초
      cpu 시간            0.14 초
 
 
MPRINT(TM_CLUSTER):   data _terms_;
MPRINT(TM_CLUSTER):   set _terms_;
MPRINT(TM_CLUSTER):   by key _ispar;
MPRINT(TM_CLUSTER):   if first.key then output;
MPRINT(TM_CLUSTER):   else;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 1376개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 1376개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   data _terms_;
MPRINT(TM_CLUSTER):   set _terms_;
MPRINT(TM_CLUSTER):   if _ispar='+' then Term=_ispar || ' ' || term;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 1376개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 1376개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMSORT):   proc sort data = EMWS5.TextFilter5_tmout threads out = _tmout_;
MPRINT(TMSORT):   by _termnum_;
MPRINT(TMSORT):   run;
 
NOTE: 4155개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._TMOUT_은(는) 4155개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   data _tmout_;
MPRINT(TM_CLUSTER):   merge _tmout_ (in=_A_) _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
MPRINT(TM_CLUSTER):   by _termnum_;
MPRINT(TM_CLUSTER):   if _A_;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 1376개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TMOUT_은(는) 4155개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   data _docs_;
MPRINT(TM_CLUSTER):   set EMWS5.TextCluster5_docs (rename=(index=_document_) keep=index _cluster_ _finalcluster_);
MPRINT(TM_CLUSTER):   _SEGMNT_=_finalcluster_;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_DOCS.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   select max(_cluster_) into :numclus from EMWS5.TextCluster5_clusters;
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 2892개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.07 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 33개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
 
MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;
 
NOTE: 33개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;
 
NOTE: 2892개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 2892개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;
 
NOTE: 2892개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 747개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;
 
NOTE: 747개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 391개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 356개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 1460 rows and 3 columns.
 
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;
 
NOTE: 1460개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 356개의 관측값과 34개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 44 ) 4 clus1 - clus44 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 44 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus44 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 4144 - 19;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 19 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 4144 - 5;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 5 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 4144 - 18;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 18 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 4144 - 32;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 32 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus5 = 0) or (clus5 < 0) then cdf5 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus5 ;
MPRINT(TMTERM1):   div = 4144 - 11;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf5 = CDF( 'binomial', clus5 , propor , 11 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf5 = 1;
MPRINT(TMTERM1):   else cdf5 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus6 = 0) or (clus6 < 0) then cdf6 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus6 ;
MPRINT(TMTERM1):   div = 4144 - 12;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf6 = CDF( 'binomial', clus6 , propor , 12 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf6 = 1;
MPRINT(TMTERM1):   else cdf6 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus7 = 0) or (clus7 < 0) then cdf7 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus7 ;
MPRINT(TMTERM1):   div = 4144 - 216;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf7 = CDF( 'binomial', clus7 , propor , 216 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf7 = 1;
MPRINT(TMTERM1):   else cdf7 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus8 = 0) or (clus8 < 0) then cdf8 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus8 ;
MPRINT(TMTERM1):   div = 4144 - 50;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf8 = CDF( 'binomial', clus8 , propor , 50 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf8 = 1;
MPRINT(TMTERM1):   else cdf8 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus9 = 0) or (clus9 < 0) then cdf9 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus9 ;
MPRINT(TMTERM1):   div = 4144 - 18;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf9 = CDF( 'binomial', clus9 , propor , 18 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf9 = 1;
MPRINT(TMTERM1):   else cdf9 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus10 = 0) or (clus10 < 0) then cdf10 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus10 ;
MPRINT(TMTERM1):   div = 4144 - 10;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf10 = CDF( 'binomial', clus10 , propor , 10 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf10 = 1;
MPRINT(TMTERM1):   else cdf10 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus11 = 0) or (clus11 < 0) then cdf11 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus11 ;
MPRINT(TMTERM1):   div = 4144 - 243;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf11 = CDF( 'binomial', clus11 , propor , 243 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf11 = 1;
MPRINT(TMTERM1):   else cdf11 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus12 = 0) or (clus12 < 0) then cdf12 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus12 ;
MPRINT(TMTERM1):   div = 4144 - 40;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf12 = CDF( 'binomial', clus12 , propor , 40 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf12 = 1;
MPRINT(TMTERM1):   else cdf12 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus13 = 0) or (clus13 < 0) then cdf13 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus13 ;
MPRINT(TMTERM1):   div = 4144 - 361;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf13 = CDF( 'binomial', clus13 , propor , 361 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf13 = 1;
MPRINT(TMTERM1):   else cdf13 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus14 = 0) or (clus14 < 0) then cdf14 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus14 ;
MPRINT(TMTERM1):   div = 4144 - 365;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf14 = CDF( 'binomial', clus14 , propor , 365 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf14 = 1;
MPRINT(TMTERM1):   else cdf14 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus15 = 0) or (clus15 < 0) then cdf15 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus15 ;
MPRINT(TMTERM1):   div = 4144 - 18;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf15 = CDF( 'binomial', clus15 , propor , 18 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf15 = 1;
MPRINT(TMTERM1):   else cdf15 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus16 = 0) or (clus16 < 0) then cdf16 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus16 ;
MPRINT(TMTERM1):   div = 4144 - 28;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf16 = CDF( 'binomial', clus16 , propor , 28 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf16 = 1;
MPRINT(TMTERM1):   else cdf16 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus17 = 0) or (clus17 < 0) then cdf17 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus17 ;
MPRINT(TMTERM1):   div = 4144 - 283;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf17 = CDF( 'binomial', clus17 , propor , 283 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf17 = 1;
MPRINT(TMTERM1):   else cdf17 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus18 = 0) or (clus18 < 0) then cdf18 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus18 ;
MPRINT(TMTERM1):   div = 4144 - 7;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf18 = CDF( 'binomial', clus18 , propor , 7 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf18 = 1;
MPRINT(TMTERM1):   else cdf18 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus19 = 0) or (clus19 < 0) then cdf19 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus19 ;
MPRINT(TMTERM1):   div = 4144 - 24;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf19 = CDF( 'binomial', clus19 , propor , 24 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf19 = 1;
MPRINT(TMTERM1):   else cdf19 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus20 = 0) or (clus20 < 0) then cdf20 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus20 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf20 = CDF( 'binomial', clus20 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf20 = 1;
MPRINT(TMTERM1):   else cdf20 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus21 = 0) or (clus21 < 0) then cdf21 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus21 ;
MPRINT(TMTERM1):   div = 4144 - 216;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf21 = CDF( 'binomial', clus21 , propor , 216 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf21 = 1;
MPRINT(TMTERM1):   else cdf21 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus22 = 0) or (clus22 < 0) then cdf22 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus22 ;
MPRINT(TMTERM1):   div = 4144 - 380;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf22 = CDF( 'binomial', clus22 , propor , 380 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf22 = 1;
MPRINT(TMTERM1):   else cdf22 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus23 = 0) or (clus23 < 0) then cdf23 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus23 ;
MPRINT(TMTERM1):   div = 4144 - 19;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf23 = CDF( 'binomial', clus23 , propor , 19 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf23 = 1;
MPRINT(TMTERM1):   else cdf23 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus24 = 0) or (clus24 < 0) then cdf24 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus24 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf24 = CDF( 'binomial', clus24 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf24 = 1;
MPRINT(TMTERM1):   else cdf24 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus25 = 0) or (clus25 < 0) then cdf25 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus25 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf25 = CDF( 'binomial', clus25 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf25 = 1;
MPRINT(TMTERM1):   else cdf25 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus26 = 0) or (clus26 < 0) then cdf26 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus26 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf26 = CDF( 'binomial', clus26 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf26 = 1;
MPRINT(TMTERM1):   else cdf26 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus27 = 0) or (clus27 < 0) then cdf27 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus27 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf27 = CDF( 'binomial', clus27 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf27 = 1;
MPRINT(TMTERM1):   else cdf27 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus28 = 0) or (clus28 < 0) then cdf28 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus28 ;
MPRINT(TMTERM1):   div = 4144 - 139;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf28 = CDF( 'binomial', clus28 , propor , 139 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf28 = 1;
MPRINT(TMTERM1):   else cdf28 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus29 = 0) or (clus29 < 0) then cdf29 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus29 ;
MPRINT(TMTERM1):   div = 4144 - 291;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf29 = CDF( 'binomial', clus29 , propor , 291 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf29 = 1;
MPRINT(TMTERM1):   else cdf29 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus30 = 0) or (clus30 < 0) then cdf30 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus30 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf30 = CDF( 'binomial', clus30 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf30 = 1;
MPRINT(TMTERM1):   else cdf30 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus31 = 0) or (clus31 < 0) then cdf31 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus31 ;
MPRINT(TMTERM1):   div = 4144 - 192;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf31 = CDF( 'binomial', clus31 , propor , 192 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf31 = 1;
MPRINT(TMTERM1):   else cdf31 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus32 = 0) or (clus32 < 0) then cdf32 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus32 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf32 = CDF( 'binomial', clus32 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf32 = 1;
MPRINT(TMTERM1):   else cdf32 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus33 = 0) or (clus33 < 0) then cdf33 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus33 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf33 = CDF( 'binomial', clus33 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf33 = 1;
MPRINT(TMTERM1):   else cdf33 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus34 = 0) or (clus34 < 0) then cdf34 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus34 ;
MPRINT(TMTERM1):   div = 4144 - 214;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf34 = CDF( 'binomial', clus34 , propor , 214 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf34 = 1;
MPRINT(TMTERM1):   else cdf34 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus35 = 0) or (clus35 < 0) then cdf35 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus35 ;
MPRINT(TMTERM1):   div = 4144 - 147;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf35 = CDF( 'binomial', clus35 , propor , 147 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf35 = 1;
MPRINT(TMTERM1):   else cdf35 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus36 = 0) or (clus36 < 0) then cdf36 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus36 ;
MPRINT(TMTERM1):   div = 4144 - 91;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf36 = CDF( 'binomial', clus36 , propor , 91 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf36 = 1;
MPRINT(TMTERM1):   else cdf36 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus37 = 0) or (clus37 < 0) then cdf37 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus37 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf37 = CDF( 'binomial', clus37 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf37 = 1;
MPRINT(TMTERM1):   else cdf37 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus38 = 0) or (clus38 < 0) then cdf38 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus38 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf38 = CDF( 'binomial', clus38 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf38 = 1;
MPRINT(TMTERM1):   else cdf38 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus39 = 0) or (clus39 < 0) then cdf39 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus39 ;
MPRINT(TMTERM1):   div = 4144 - 301;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf39 = CDF( 'binomial', clus39 , propor , 301 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf39 = 1;
MPRINT(TMTERM1):   else cdf39 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus40 = 0) or (clus40 < 0) then cdf40 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus40 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf40 = CDF( 'binomial', clus40 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf40 = 1;
MPRINT(TMTERM1):   else cdf40 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus41 = 0) or (clus41 < 0) then cdf41 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus41 ;
MPRINT(TMTERM1):   div = 4144 - 143;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf41 = CDF( 'binomial', clus41 , propor , 143 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf41 = 1;
MPRINT(TMTERM1):   else cdf41 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus42 = 0) or (clus42 < 0) then cdf42 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus42 ;
MPRINT(TMTERM1):   div = 4144 - 0;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf42 = CDF( 'binomial', clus42 , propor ,0 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf42 = 1;
MPRINT(TMTERM1):   else cdf42 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus43 = 0) or (clus43 < 0) then cdf43 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus43 ;
MPRINT(TMTERM1):   div = 4144 - 125;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf43 = CDF( 'binomial', clus43 , propor , 125 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf43 = 1;
MPRINT(TMTERM1):   else cdf43 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus44 = 0) or (clus44 < 0) then cdf44 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus44 ;
MPRINT(TMTERM1):   div = 4144 - 126;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf44 = CDF( 'binomial', clus44 , propor , 126 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf44 = 1;
MPRINT(TMTERM1):   else cdf44 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;
 
NOTE: 356개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 356개의 관측값과 90개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.26 초
      cpu 시간            0.17 초
 
 
MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 44 ) cdf1 - cdf44 ;
MPRINT(TMTERM1):   array a_count ( 44 ) clus1 - clus44 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 44 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;
 
NOTE: 356개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 1460개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;
 
NOTE: 1460개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 1460개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 1460) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1460) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 1460) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;
 
NOTE: 1460개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 32개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TMSORT):   proc sort data = EMWS5.TextCluster5_clusters threads out = EMWS5.TextCluster5_clusters;
MPRINT(TMSORT):   by _cluster_;
MPRINT(TMSORT):   run;
 
NOTE: 16개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS은(는) 16개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TMSORT):   proc sort data = _desc_ threads out = _desc_;
MPRINT(TMSORT):   by _cluster_;
MPRINT(TMSORT):   run;
 
NOTE: 32개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 32개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   data _desc_;
MPRINT(TM_CLUSTER):   merge EMWS5.TextCluster5_clusters _desc_;
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 16개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 32개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 32개의 관측값과 50개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMSORT):   proc sort data = _desc_ threads out = EMWS5.TextCluster5_clusters;
MPRINT(TMSORT):   by _cluster_;
MPRINT(TMSORT):   run;
 
NOTE: 32개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS은(는) 32개의 관측값과 50개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TMSORT):   proc sort data = EMWS5.TextCluster5_hierds threads out = EMWS5.TextCluster5_hierds;
MPRINT(TMSORT):   by _cluster_;
MPRINT(TMSORT):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 63개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_CLUSTER):  ;
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_hierds;
MPRINT(TM_CLUSTER):   merge EMWS5.TextCluster5_clusters EMWS5.TextCluster5_hierds (keep=_cluster_ parent level in=P);
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   clust=_cluster_;
MPRINT(TM_CLUSTER):   drop _cluster_;
MPRINT(TM_CLUSTER):   if P;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   create table EMWS5.TextCluster5_clusters as select a._cluster_, b.* from EMWS5.TextCluster5_hierds (rename=(clust=_CLUSTER_)) a left join EMWS5.TextCluster5_clusters b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 _CLUSTER_이(가) 파일 EMWS5.TEXTCLUSTER5_CLUSTERS에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER5_CLUSTERS created, with 32 rows and 50 columns.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_clusters set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=_cluster_), percent= (select sum(percent) from EMWS5.TextCluster5_hierds where parent=_cluster_) where freq=. and _cluster_
not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 5 rows were updated in EMWS5.TEXTCLUSTER5_CLUSTERS.
 
MPRINT(TM_CLUSTER):   select count(*) into :empty from EMWS5.TextCluster5_clusters where freq=.;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_hierds set freq=(select freq from EMWS5.TextCluster5_clusters where _cluster_=clust);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.10 초
 
 
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_hierds;
MPRINT(TM_CLUSTER):   merge EMWS5.TextCluster5_clusters EMWS5.TextCluster5_hierds ( rename=(clust=_cluster_) keep=clust parent level in=P);
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   clust=_cluster_;
MPRINT(TM_CLUSTER):   drop _cluster_;
MPRINT(TM_CLUSTER):   if P;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_clusters set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=_cluster_), percent= (select sum(percent) from EMWS5.TextCluster5_hierds where parent=_cluster_) where freq=. and _cluster_
not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 4 rows were updated in EMWS5.TEXTCLUSTER5_CLUSTERS.
 
MPRINT(TM_CLUSTER):   select count(*) into :empty from EMWS5.TextCluster5_clusters where freq=.;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_hierds set freq=(select freq from EMWS5.TextCluster5_clusters where _cluster_=clust);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.11 초
 
 
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_hierds;
MPRINT(TM_CLUSTER):   merge EMWS5.TextCluster5_clusters EMWS5.TextCluster5_hierds ( rename=(clust=_cluster_) keep=clust parent level in=P);
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   clust=_cluster_;
MPRINT(TM_CLUSTER):   drop _cluster_;
MPRINT(TM_CLUSTER):   if P;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_clusters set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=_cluster_), percent= (select sum(percent) from EMWS5.TextCluster5_hierds where parent=_cluster_) where freq=. and _cluster_
not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 2 rows were updated in EMWS5.TEXTCLUSTER5_CLUSTERS.
 
MPRINT(TM_CLUSTER):   select count(*) into :empty from EMWS5.TextCluster5_clusters where freq=.;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_hierds set freq=(select freq from EMWS5.TextCluster5_clusters where _cluster_=clust);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.09 초
 
 
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_hierds;
MPRINT(TM_CLUSTER):   merge EMWS5.TextCluster5_clusters EMWS5.TextCluster5_hierds ( rename=(clust=_cluster_) keep=clust parent level in=P);
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   clust=_cluster_;
MPRINT(TM_CLUSTER):   drop _cluster_;
MPRINT(TM_CLUSTER):   if P;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_clusters set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=_cluster_), percent= (select sum(percent) from EMWS5.TextCluster5_hierds where parent=_cluster_) where freq=. and _cluster_
not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 1 row was updated in EMWS5.TEXTCLUSTER5_CLUSTERS.
 
MPRINT(TM_CLUSTER):   select count(*) into :empty from EMWS5.TextCluster5_clusters where freq=.;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_hierds set freq=(select freq from EMWS5.TextCluster5_clusters where _cluster_=clust);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
 
 
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_hierds;
MPRINT(TM_CLUSTER):   merge EMWS5.TextCluster5_clusters EMWS5.TextCluster5_hierds ( rename=(clust=_cluster_) keep=clust parent level in=P);
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   clust=_cluster_;
MPRINT(TM_CLUSTER):   drop _cluster_;
MPRINT(TM_CLUSTER):   if P;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_clusters set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=_cluster_), percent= (select sum(percent) from EMWS5.TextCluster5_hierds where parent=_cluster_) where freq=. and _cluster_
not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 1 row was updated in EMWS5.TEXTCLUSTER5_CLUSTERS.
 
MPRINT(TM_CLUSTER):   select count(*) into :empty from EMWS5.TextCluster5_clusters where freq=.;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_hierds set freq=(select freq from EMWS5.TextCluster5_clusters where _cluster_=clust);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.09 초
 
 
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_hierds;
MPRINT(TM_CLUSTER):   merge EMWS5.TextCluster5_clusters EMWS5.TextCluster5_hierds ( rename=(clust=_cluster_) keep=clust parent level in=P);
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   clust=_cluster_;
MPRINT(TM_CLUSTER):   drop _cluster_;
MPRINT(TM_CLUSTER):   if P;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_clusters set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=_cluster_), percent= (select sum(percent) from EMWS5.TextCluster5_hierds where parent=_cluster_) where freq=. and _cluster_
not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 1 row was updated in EMWS5.TEXTCLUSTER5_CLUSTERS.
 
MPRINT(TM_CLUSTER):   select count(*) into :empty from EMWS5.TextCluster5_clusters where freq=.;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_hierds set freq=(select freq from EMWS5.TextCluster5_clusters where _cluster_=clust);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
 
 
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_hierds;
MPRINT(TM_CLUSTER):   merge EMWS5.TextCluster5_clusters EMWS5.TextCluster5_hierds ( rename=(clust=_cluster_) keep=clust parent level in=P);
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   clust=_cluster_;
MPRINT(TM_CLUSTER):   drop _cluster_;
MPRINT(TM_CLUSTER):   if P;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_clusters set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=_cluster_), percent= (select sum(percent) from EMWS5.TextCluster5_hierds where parent=_cluster_) where freq=. and _cluster_
not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 1 row was updated in EMWS5.TEXTCLUSTER5_CLUSTERS.
 
MPRINT(TM_CLUSTER):   select count(*) into :empty from EMWS5.TextCluster5_clusters where freq=.;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_hierds set freq=(select freq from EMWS5.TextCluster5_clusters where _cluster_=clust);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.09 초
 
 
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_hierds;
MPRINT(TM_CLUSTER):   merge EMWS5.TextCluster5_clusters EMWS5.TextCluster5_hierds ( rename=(clust=_cluster_) keep=clust parent level in=P);
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   clust=_cluster_;
MPRINT(TM_CLUSTER):   drop _cluster_;
MPRINT(TM_CLUSTER):   if P;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   proc sql noprint;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_clusters set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=_cluster_), percent= (select sum(percent) from EMWS5.TextCluster5_hierds where parent=_cluster_) where freq=. and _cluster_
not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 1 row was updated in EMWS5.TEXTCLUSTER5_CLUSTERS.
 
MPRINT(TM_CLUSTER):   select count(*) into :empty from EMWS5.TextCluster5_clusters where freq=.;
MPRINT(TM_CLUSTER):   update EMWS5.TextCluster5_hierds set freq=(select freq from EMWS5.TextCluster5_clusters where _cluster_=clust);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_CLUSTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.07 초
 
 
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_hierds;
MPRINT(TM_CLUSTER):   merge EMWS5.TextCluster5_clusters EMWS5.TextCluster5_hierds ( rename=(clust=_cluster_) keep=clust parent level in=P);
MPRINT(TM_CLUSTER):   by _cluster_;
MPRINT(TM_CLUSTER):   clust=_cluster_;
MPRINT(TM_CLUSTER):   drop _cluster_;
MPRINT(TM_CLUSTER):   if P;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 52개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_hierds;
MPRINT(TM_CLUSTER):   set EMWS5.TextCluster5_hierds(rename=(CLUST=_CLUSTER_) keep=clust FREQ CLUS_DESC PARENT level);
MPRINT(TM_CLUSTER):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_clusters;
MPRINT(TM_CLUSTER):   set EMWS5.TextCluster5_clusters;
MPRINT(TM_CLUSTER):   if _rmsstd_ ne .;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS은(는) 16개의 관측값과 50개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_CLUSTER):   data EMWS5.TextCluster5_docs;
MPRINT(TM_CLUSTER):   set EMWS5.TextCluster5_docs (drop=_FINALCLUSTER_ _SUBCLUSTER_);
MPRINT(TM_CLUSTER):   label _CLUSTER_= Cluster ID;
MPRINT(TM_CLUSTER):   run;
 
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_DOCS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_DOCS은(는) 496개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_CLUSTER):   filename temp;
NOTE: Fileref TEMP을(를) 삭제했습니다.
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data EMWS5.TextCluster5_hierds(drop=plus);
MPRINT(TRAIN):   set EMWS5.TextCluster5_hierds;
MPRINT(TRAIN):   plus='';
MPRINT(TRAIN):   if substr(CLUS_DESC, 1, 1) = "+" then plus="+ ";
MPRINT(TRAIN):   graphdesc=_CLUSTER_ || ': ' || plus || scan(CLUS_DESC, 1);
MPRINT(TRAIN):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      83681:182
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):   * add the info to EMINFO to forward on to other nodes ;
MPRINT(TRAIN):   data EMWS5.TextCluster5_EMINFO;
MPRINT(TRAIN):   length TARGET KEY $32 DATA $43;
MPRINT(TRAIN):   key="LastTMNode";
MPRINT(TRAIN):   data="TextCluster5";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTMNodeType";
MPRINT(TRAIN):   data="TextCluster";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="LastTextCluster";
MPRINT(TRAIN):   data="TextCluster5";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   key="PRESCORECODE";
MPRINT(TRAIN):   data="TextCluster5";
MPRINT(TRAIN):   output;
MPRINT(TRAIN):   run;
 
NOTE: 변수 TARGET이(가) 초기화되지 않았습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_EMINFO은(는) 4개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):   proc sql noprint;
MPRINT(TRAIN):   select count(*) into :svdkeep from EMWS5.TextCluster5_svd_s where keep=1;
MPRINT(TRAIN):   select count(*) into :cluscnt from EMWS5.TextCluster5_clusters;
MPRINT(TRAIN):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):   data EMWS5.TextCluster5_tmconfig;
MPRINT(TRAIN):   set EMWS5.TextCluster5_tmconfig;
MPRINT(TRAIN):   clus_alg = "2.0";
MPRINT(TRAIN):   maxsvd = 100;
MPRINT(TRAIN):   svdkeep= 45;
MPRINT(TRAIN):   last_prescore = "TextFilter5                                ";
MPRINT(TRAIN):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_TMCONFIG.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_TMCONFIG은(는) 1개의 관측값과 33개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   length KEY $32 DELETE $1 UNAME $32 ROLE $32 LEVEL $10 ORDER $8 COMMENT $64 LOWERLIMIT 8 UPPERLIMIT 8;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_CLUSTER_");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("SEGMENT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("NOMINAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 1개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD1");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 1개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 2개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD2");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 2개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 3개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD3");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 3개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 4개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD4");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 4개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 5개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD5");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 5개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 6개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD6");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 7개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD7");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 7개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 8개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD8");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 8개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 9개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD9");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 9개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 10개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD10");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 10개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 11개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD11");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 11개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 12개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD12");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 12개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 13개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD13");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 13개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 14개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD14");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 14개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 15개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD15");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 15개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 16개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD16");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 16개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 17개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD17");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 17개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 18개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD18");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 18개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 19개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD19");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 19개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 20개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD20");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 20개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 21개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD21");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 21개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 22개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD22");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 22개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 23개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD23");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 23개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 24개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD24");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 24개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 25개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD25");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 25개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 26개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD26");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 26개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 27개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD27");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 27개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 28개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD28");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 28개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 29개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD29");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 29개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 30개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD30");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 30개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 31개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD31");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 31개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 32개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD32");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 32개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 33개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD33");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 33개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 34개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD34");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 34개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 35개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD35");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 35개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 36개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD36");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 36개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 37개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD37");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 37개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 38개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD38");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 38개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 39개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD39");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 39개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 40개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD40");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 40개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 41개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD41");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 41개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 42개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD42");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 42개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 43개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD43");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 43개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 44개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD44");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 44개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 45개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_SVD45");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("INPUT");
MPRINT(EM_METACHANGE):   LEVEL = upcase("INTERVAL");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 45개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 46개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB1");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 46개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 47개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB2");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 47개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 48개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB3");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 48개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 49개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB4");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 49개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 50개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB5");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 50개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 51개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB6");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 51개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 52개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB7");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 52개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 53개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB8");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 53개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 54개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB9");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 54개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 55개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB10");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 55개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 56개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB11");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 56개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 57개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB12");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 57개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 58개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB13");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 58개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 59개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB14");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 59개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 60개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB15");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 60개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 61개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(EM_METACHANGE):   data WORK.EM_METACHANGE;
MPRINT(EM_METACHANGE):   set WORK.EM_METACHANGE end=eof;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   if eof then do;
MPRINT(EM_METACHANGE):   KEY = upcase("CDELTA_TRAIN");
MPRINT(EM_METACHANGE):   UNAME = upcase("TextCluster5_PROB16");
MPRINT(EM_METACHANGE):   DELETE = upcase("N");
MPRINT(EM_METACHANGE):   ROLE = upcase("REJECTED");
MPRINT(EM_METACHANGE):   LEVEL = upcase("");
MPRINT(EM_METACHANGE):   ORDER = upcase("");
MPRINT(EM_METACHANGE):   COMMENT = "";
MPRINT(EM_METACHANGE):   LOWERLIMIT = .;
MPRINT(EM_METACHANGE):   UPPERLIMIT = .;
MPRINT(EM_METACHANGE):   output;
MPRINT(EM_METACHANGE):   end;
MPRINT(EM_METACHANGE):   run;
 
NOTE: 61개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 62개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename temp;
WARNING: 파일 이름 TEMP이(가) 논리적으로 할당되지 않았습니다.
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: TextCluster5;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
25760      *------------------------------------------------------------*;
25761      * End TRAIN: TextCluster5;
25762      *------------------------------------------------------------*;
 
25763      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
25764      * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
25765      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
25766      ;
MPRINT(EM_DIAGRAM):   ;
25767      ;
MPRINT(EM_DIAGRAM):   ;
25768      ;
MPRINT(EM_DIAGRAM):   ;
25769      ;
MPRINT(EM_DIAGRAM):   ;
25770      quit;
MPRINT(EM_DIAGRAM):   quit;
25771      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
25772      * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
25773      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
25774      /*; *"; *'; */
25775      ;
MPRINT(EM_DIAGRAM):   ;
25776      run;
MPRINT(EM_DIAGRAM):   run;
25777      quit;
MPRINT(EM_DIAGRAM):   quit;
25778      /* Reset EM Options */
25779      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
25780      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
25781      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
25782      proc sort data=WORK.EM_METACHANGE;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_METACHANGE;
25783      by key uname;
MPRINT(EM_DIAGRAM):   by key uname;
25784      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 62개의 관측값을 데이터셋 WORK.EM_METACHANGE.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_METACHANGE은(는) 62개의 관측값과 9개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
25785      filename x "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\CDELTA_TRAIN.sas";
MPRINT(EM_DIAGRAM):    filename x "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\CDELTA_TRAIN.sas";
25786      data _null_;
MPRINT(EM_DIAGRAM):   data _null_;
25787      file x;
MPRINT(EM_DIAGRAM):   file x;
25788      put 'if upcase(NAME) = "TEXTCLUSTER5_CLUSTER_" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_CLUSTER_" then do;';
25789      put 'ROLE = "SEGMENT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "SEGMENT";';
25790      put 'LEVEL = "NOMINAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "NOMINAL";';
25791      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25792      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25793      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB1" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB1" then do;';
25794      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25795      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25796      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25797      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB10" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB10" then do;';
25798      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25799      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25800      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25801      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB11" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB11" then do;';
25802      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25803      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25804      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25805      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB12" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB12" then do;';
25806      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25807      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25808      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25809      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB13" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB13" then do;';
25810      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25811      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25812      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25813      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB14" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB14" then do;';
25814      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25815      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25816      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25817      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB15" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB15" then do;';
25818      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25819      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25820      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25821      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB16" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB16" then do;';
25822      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25823      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25824      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25825      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB2" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB2" then do;';
25826      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25827      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25828      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25829      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB3" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB3" then do;';
25830      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25831      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25832      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25833      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB4" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB4" then do;';
25834      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25835      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25836      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25837      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB5" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB5" then do;';
25838      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25839      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25840      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25841      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB6" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB6" then do;';
25842      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25843      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25844      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25845      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB7" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB7" then do;';
25846      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25847      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25848      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25849      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB8" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB8" then do;';
25850      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25851      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25852      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25853      put 'if upcase(NAME) = "TEXTCLUSTER5_PROB9" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_PROB9" then do;';
25854      put 'ROLE = "REJECTED";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "REJECTED";';
25855      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25856      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25857      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD1" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD1" then do;';
25858      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25859      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25860      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25861      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25862      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD10" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD10" then do;';
25863      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25864      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25865      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25866      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25867      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD11" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD11" then do;';
25868      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25869      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25870      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25871      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25872      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD12" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD12" then do;';
25873      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25874      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25875      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25876      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25877      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD13" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD13" then do;';
25878      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25879      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25880      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25881      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25882      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD14" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD14" then do;';
25883      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25884      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25885      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25886      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25887      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD15" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD15" then do;';
25888      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25889      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25890      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25891      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25892      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD16" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD16" then do;';
25893      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25894      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25895      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25896      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25897      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD17" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD17" then do;';
25898      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25899      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25900      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25901      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25902      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD18" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD18" then do;';
25903      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25904      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25905      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25906      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25907      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD19" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD19" then do;';
25908      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25909      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25910      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25911      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25912      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD2" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD2" then do;';
25913      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25914      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25915      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25916      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25917      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD20" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD20" then do;';
25918      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25919      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25920      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25921      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25922      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD21" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD21" then do;';
25923      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25924      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25925      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25926      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25927      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD22" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD22" then do;';
25928      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25929      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25930      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25931      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25932      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD23" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD23" then do;';
25933      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25934      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25935      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25936      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25937      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD24" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD24" then do;';
25938      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25939      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25940      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25941      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25942      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD25" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD25" then do;';
25943      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25944      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25945      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25946      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25947      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD26" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD26" then do;';
25948      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25949      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25950      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25951      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25952      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD27" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD27" then do;';
25953      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25954      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25955      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25956      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25957      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD28" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD28" then do;';
25958      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25959      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25960      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25961      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25962      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD29" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD29" then do;';
25963      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25964      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25965      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25966      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25967      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD3" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD3" then do;';
25968      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25969      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25970      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25971      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25972      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD30" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD30" then do;';
25973      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25974      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25975      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25976      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25977      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD31" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD31" then do;';
25978      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25979      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25980      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25981      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25982      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD32" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD32" then do;';
25983      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25984      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25985      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25986      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25987      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD33" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD33" then do;';
25988      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25989      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25990      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25991      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25992      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD34" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD34" then do;';
25993      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25994      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
25995      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
25996      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
25997      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD35" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD35" then do;';
25998      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
25999      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26000      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26001      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26002      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD36" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD36" then do;';
26003      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26004      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26005      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26006      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26007      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD37" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD37" then do;';
26008      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26009      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26010      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26011      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26012      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD38" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD38" then do;';
26013      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26014      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26015      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26016      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26017      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD39" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD39" then do;';
26018      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26019      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26020      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26021      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26022      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD4" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD4" then do;';
26023      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26024      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26025      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26026      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26027      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD40" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD40" then do;';
26028      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26029      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26030      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26031      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26032      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD41" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD41" then do;';
26033      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26034      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26035      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26036      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26037      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD42" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD42" then do;';
26038      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26039      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26040      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26041      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26042      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD43" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD43" then do;';
26043      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26044      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26045      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26046      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26047      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD44" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD44" then do;';
26048      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26049      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26050      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26051      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26052      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD45" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD45" then do;';
26053      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26054      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26055      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26056      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26057      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD5" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD5" then do;';
26058      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26059      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26060      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26061      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26062      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD6" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD6" then do;';
26063      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26064      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26065      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26066      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26067      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD7" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD7" then do;';
26068      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26069      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26070      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26071      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26072      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD8" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD8" then do;';
26073      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26074      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26075      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26076      put 'else ';
MPRINT(EM_DIAGRAM):   put 'else ';
26077      put 'if upcase(NAME) = "TEXTCLUSTER5_SVD9" then do;';
MPRINT(EM_DIAGRAM):   put 'if upcase(NAME) = "TEXTCLUSTER5_SVD9" then do;';
26078      put 'ROLE = "INPUT";';
MPRINT(EM_DIAGRAM):   put 'ROLE = "INPUT";';
26079      put 'LEVEL = "INTERVAL";';
MPRINT(EM_DIAGRAM):   put 'LEVEL = "INTERVAL";';
26080      put 'end;';
MPRINT(EM_DIAGRAM):   put 'end;';
26081      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 파일 X:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,파일 크기 (바이트)=0,
      마지막 수정일=2018년 11월 28일 18시14분56초,
      생성 시간=2018년 11월 28일 18시13분46초
 
NOTE: 293개의 레코드를 파일 X에 기록했습니다.
      최소 레코드 길이는 4입니다.
      최대 레코드 길이는 50입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
26082      filename x;
MPRINT(EM_DIAGRAM):   filename x;
NOTE: Fileref X을(를) 삭제했습니다.
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 28일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "18시14분57초" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 스코어 로그";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* 스코어 로그
날짜:                2018년 11월 28일
시간:                18시14분57초
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O0DKM80R "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O0DKM80R new;
MPRINT(EM_DIAGRAM):   run;
26184      %let EMEXCEPTIONSTRING=;
26185      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
26186      * SCORE: TextCluster5;
MPRINT(EM_DIAGRAM):   * SCORE: TextCluster5;
26187      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
26188      %let EM_ACTION = SCORE;
26189      %let syscc = 0;
26190      %macro main();
26191
26192         %if %upcase(&EM_ACTION) eq CREATE %then %do;
26193            filename temp catalog 'sashelp.emtxtext.cluster_create.source';
26194            %include temp;
26195            %create();
26196         %end;
26197         %if %upcase(&EM_ACTION) eq TRAIN %then %do;
26198            filename temp catalog 'sashelp.emtxtext.cluster_train.source';
26199            %include temp;
26200            %train();
26201         %end;
26202         %if %upcase(&EM_ACTION) eq REPORT %then %do;
26203            filename temp catalog 'sashelp.emtxtext.cluster_report.source';
26204            %include temp;
26205            %report();
26206         %end;
26207         %if %upcase(&EM_ACTION) eq SCORE %then %do;
26208            filename temp catalog 'sashelp.emtxtext.cluster_score.source';
26209            %include temp;
26210            %score();
26211         %end;
26212      %mend main;
26213
26214      %main();
MPRINT(EM_DIAGRAM):
MPRINT(MAIN):   filename temp catalog 'sashelp.emtxtext.cluster_score.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.CLUSTER_SCORE.SOURCE입니다.
26215     +%macro tmc_score(import_ds=,configdata=,export_ds=,term_ds=,export_out=,clusters_ds=,svdu=,svds=,
26216     +    import_out=,em_outstat=,prefixstring=,ocluster=,ndescterms=,ftmout=,fterms=,hier=);
26217     +  %if &import_ds ne %then %do;
26219     +    %let syscc=0;
26221     +    %tmc_doc_score(import=&import_ds,export=&export_ds,emoutstat=&em_outstat,
26222     +                termds=&term_ds,clusters=&clusters_ds,configds=&configdata,
26223     +                _scrout=&import_out, svd_u=&svdu, svd_s=&svds, prefix=&prefixstring,
26224     +                outclusters=&ocluster, descterms=&ndescterms, filterterms=&fterms,
26225     +                filtertmout=&ftmout, hierds=&hier);
26227     +  %end;
26229     +%mend tmc_score;
26230     +%macro score();
26232     +    %global last_parse_node last_filter_node last_prescore_node server_err
26233     +      parsevar EM_SASMSG ;
26234     +    %let syscc=0;
26235     +    %if ^%symexist(tm_debug) %then %let tm_debug=0;
26236     +    /*use saved version of em_info in case macro is not populated*/
26237     +    %em_getname(key=last_tm_nodes, type=data);
26239     +    filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
26240     +    %include temp;
26241     +    %tm_get_last_filter(eminfo=&em_user_last_tm_nodes,em_lib=&em_lib,
26242     +                        em_variableset=&em_data_variableset);
26243     +    %if &EMEXCEPTIONSTRING ne %then %goto end_cluster_score;
26244     +    %let lastparsenode=&last_parse_node;
26245     +    %let lastfilternode=&last_filter_node;
26246     +    %let lastprescore=&last_prescore_node;
26247     +    %let filt_node=;
26249     +   %em_getname(key=terms, type=data);
26250     +   %em_getname(key=docs, type=data);
26251     +   %em_getname(key=clusters, type=data);
26252     +   %em_getname(key=svd_u, type=data);
26253     +   %em_getname(key=svd_s, type=data);
26254     +   %em_getname(key=emoutstat, type=data);
26255     +   %em_getname(key=tmconfig, type=data);
26257     +   %em_getname(key=tmout, type=data);
26258     +   %em_getname(key=validout, type=data);
26259     +   %em_getname(key=testout, type=data);
26260     +   %em_getname(key=scoreout, type=data);
26261     +   %em_getname(key=PRESCORECODE, type=file, extension=sas);
26262     +   %let systmutil=;
26264     +    filename temp catalog 'sashelp.emtxtext.tm_data2code.source';
26265     +    %include temp;
26266     +    filename temp catalog 'sashelp.emtext.tmemclus.source';
26267     +    %include temp;
26268     +    filename temp catalog 'sashelp.emtext.tmpred.source';
26269     +    %include temp;
26270     +    filename temp catalog 'sashelp.emtext.tmsort.source';
26271     +    %include temp;
26272     +    filename temp catalog 'sashelp.emtxtext.tmc_doc_score.source';
26273     +    %include temp;
26274     +    filename temp catalog 'sashelp.emtext.tmsvd.source';
26275     +    %include temp;
26276     +    filename temp catalog 'sashelp.emtext.tmfast.source';
26277     +    %include temp;
26279     +   %let EM_PUBLISHCODE = PUBLISH;
26280     +   %let EM_SCORECODEFORMAT = DATASTEP;
26281     +   %let overwrite_pre = ;
26283     +   %let lastprescore=%trim(%left(&lastprescore));
26285     +   /* Create indexed term table for writing out score code */
26286     +   proc sql noprint;
26287     +       select count(*) into :svdkeep
26288     +       from &em_user_svd_s
26289     +       where keep=1;
26290     +   create table _clusterms as
26291     +      select key, term, role, keep, freq, numdocs, parent, _ispar, weight from &em_user_terms;
26293     +   data _filter_tmout;
26294     +      set &EM_LIB..&lastfilternode._tmout;
26295     +   run;
26297     +   %tmc_score(import_ds=&em_import_data,export_ds=&em_export_train,
26298     +              import_out=_filter_tmout,
26299     +              export_out=&EM_export_transaction,
26300     +              term_ds=_clusterms,
26301     +              clusters_ds=&em_user_clusters,
26302     +              svdu=&em_user_svd_u,
26303     +              svds=&em_user_svd_s,
26304     +              em_outstat=&em_user_emoutstat,
26305     +              configdata=&em_user_tmconfig,
26306     +              prefixstring=&EM_NODEID,
26307     +              ocluster=&em_user_clusters,
26308     +              ndescterms=&em_property_ndescterms,
26309     +              fterms=&EM_LIB..&lastfilternode._terms,
26310     +              ftmout=&EM_LIB..&lastfilternode._tmout,
26311     +              hier=&em_user_hierds);
26313     +   %tmc_score(import_ds=&em_import_validate,export_ds=&em_export_validate,
26314     +              export_out=&EM_USER_validout,
26315     +              import_out=&EM_LIB..&lastfilternode._validout,
26316     +              term_ds=_clusterms,
26317     +              clusters_ds=&em_user_clusters,
26318     +              svdu=&em_user_svd_u,
26319     +              svds=&em_user_svd_s,
26320     +              em_outstat=&em_user_emoutstat,
26321     +              configdata=&em_user_tmconfig,
26322     +              prefixstring=&EM_NODEID);
26323     +   %tmc_score(import_ds=&em_import_test,export_ds=&em_export_test,
26324     +              export_out=&EM_USER_testout,
26325     +              import_out=&EM_LIB..&lastfilternode._testout,
26326     +              term_ds=_clusterms,
26327     +              clusters_ds=&em_user_clusters,
26328     +              svdu=&em_user_svd_u,
26329     +              svds=&em_user_svd_s,
26330     +              em_outstat=&em_user_emoutstat,
26331     +              configdata=&em_user_tmconfig,
26332     +              prefixstring=&EM_NODEID);
26334     +   %if &syscc>4 %then %do;
26335     +       %let syscc=0;
26336     +       %goto end_cluster_score;
26337     +   %end;
26339     +   * path of the diagram ;
26340     +   %let emwspath = ;
26341     +   data _null_;
26342     +      call symput("emwspath", strip(pathname("&EM_LIB")));
26343     +   run;
26345     +   filename pre "&EM_USER_PRESCORECODE";
26346     +   data _null_;
26347     +       file pre;
26348     +       put 'filename temp catalog "sashelp.emtext.tmemclus.source";';
26349     +       put '%include temp;';
26350     +       put 'filename temp catalog "sashelp.emtext.tmpred.source";';
26351     +       put '%include temp;';
26352     +       put 'filename temp catalog "sashelp.emtxtext.tmc_doc_score.source";';
26353     +       put '%include temp;';
26354     +       put 'filename temp catalog "sashelp.emtext.tmsort.source";';
26355     +       put '%include temp;';
26356     +       put 'filename temp catalog "sashelp.emtext.tmsvd.source";';
26357     +       put '%include temp;';
26358     +       put 'filename temp catalog "sashelp.emtext.tmfast.source";';
26359     +       put '%include temp;';
26360     +       put 'filename temp;';
26361     +   run;
26364     +   /* We need to use last prescore */
26365     +   %if &lastprescore ne %then %do;
26366     +      %let tmprescoreFile = %bquote(&emwspath)&em_dsep&lastprescore&em_dsep.PRESCORECODE.sas;
26367     +      filename tmpre "&tmprescoreFile";
26368     +      %em_copyfile(infref=tmpre, outfref=pre, append=Y);
26369     +      filename tmpre;
26370     +   %end;
26372     +   data _codeclusters;
26373     +        set &em_user_clusters (drop=clus_desc);
26374     +   run;
26376     +     %if not %symexist(em_term_loc) %then %do;
26377     +       %let em_term_loc = %bquote(%sysfunc(pathname(&EM_LIB)));
26378     +         libname termloc "&em_term_loc";
26380     +      %let scored_terms = termloc.&lastfilternode._filtterms;
26381     +       %let scored_clust = termloc.&EM_NODEID._clusters;
26382     +       %let scored_config = termloc.&EM_NODEID._tmconfig;
26383     +       %let scored_svd_u = termloc.&EM_NODEID._svd_u;
26384     +       %let scored_svd_s= termloc.&EM_NODEID._svd_s;
26386     +       %if &em_property_algorithm=1.0 %then  %do;
26387     +          %let scored_emoutstat= termloc.&EM_NODEID._emoutstat;
26388     +       %end;
26390     +   %end;
26391     +   %else %do; /* Write out data sets to external directory */
26392     +       libname termloc "&em_term_loc";
26393     +        %if %sysfunc(libref(termloc)) ne 0 %then %do;
26394     +           %let  EMEXCEPTIONSTRING = EMTOOL.EMTERMLOC,&em_term_loc;
26395     +           %goto end_cluster_score;
26396     +       %end;
26398     +      /* copy datasets to use for prescore code*/
26399     +       data termloc.&EM_LIB._&EM_NODEID._CLUSTERS;
26400     +         set _codeclusters;
26401     +       run;
26403     +       data termloc.&EM_LIB._&EM_NODEID._svd_u;
26404     +         set &em_user_svd_u;
26405     +       run;
26407     +       data termloc.&EM_LIB._&EM_NODEID._svd_s;
26408     +         set &em_user_svd_s;
26409     +       run;
26411     +       data termloc.&EM_LIB._&EM_NODEID._tmconfig;
26412     +         set &em_user_tmconfig;
26413     +       run;
26415     +       %let scored_terms = termloc.&EM_LIB._&lastfilternode._filtterms;
26416     +       %let scored_clust = termloc.&EM_LIB._&EM_NODEID._CLUSTERS;
26417     +       %let scored_config = termloc.&EM_LIB._&EM_NODEID._tmconfig;
26418     +       %let scored_svd_u = termloc.&EM_LIB._&EM_NODEID._svd_u;
26419     +       %let scored_svd_s= termloc.&EM_LIB._&EM_NODEID._svd_s;
26421     +       %if &em_property_algorithm=1.0 %then  %do;
26422     +         data termloc.&EM_LIB._&EM_NODEID._emoutstat;
26423     +         set &em_user_emoutstat;
26424     +         run;
26425     +           %let scored_emoutstat= termloc.&EM_LIB._&EM_NODEID._emoutstat;
26426     +       %end;
26427     +   %end;
26431     +   %let _score_append=;
26433     +   * Now save code, if necessary, for search phrase;
26434     +   filename _tmscore "&EM_FILE_EMPUBLISHSCORECODE";
26435     +   %if &em_property_algorithm=1.0 %then %do;
26436     +   data _NULL_;
26437     +     file _tmscore;
26438     +     length string $200;
26439     +     string ='%tmc_doc_score(import='||'&em_score_output'||",export=work._newexport,";
26440     +     put string;
26441     +     string="      termds=&scored_terms, configds=&scored_config,";
26442     +     put string;
26443     +     string= "      clusters=&scored_clust, emoutstat=&scored_emoutstat, ";
26444     +     put string;
26445     +     string = "      _scrout=work.&lastfilternode._out, svd_u=&scored_svd_u, svd_s=&scored_svd_s, prefix=&em_nodeid);";
26446     +     put string;
26447     +     string='data &em_score_output; set work._newexport;';
26448     +     put string;
26449     +    run;
26450     +    %end;
26451     +    %else %do;
26452     +    data _NULL_;
26453     +     file _tmscore;
26454     +     string= '%'||"tmc_doc_score(import="||'&em_score_output'||",export=work._newexport,";
26455     +     put string;
26456     +     put "      termds=&scored_terms,configds=&scored_config,";
26457     +     put "      clusters=&scored_clust, ";
26458     +     put "      _scrout=work.&lastfilternode._out, svd_u=&scored_svd_u, svd_s=&scored_svd_s, prefix=&em_nodeid);";
26459     +     put 'data &em_score_output; set work._newexport;';
26460     +    run;
26461     +    %end;
26462     +   filename _tmscore;
26464     +%end_cluster_score:
26465     +    filename temp;
26466     +    %if &tm_debug =0 %then %do;
26467     +    proc sql noprint;
26468     +        drop table _clusterms;
26469     +        drop table _filter_tmout;
26470     +        drop table _codeclusters;
26471     +    quit;
26472     +    %end;
26474     +%mend score;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):  ;
MPRINT(SCORE):   filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_GET_LAST_FILTER.SOURCE입니다.
26476     +/* ****************************************************************
26477     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
26478     + *
26479     + * Name:             tm_get_last_filter.sas
26480     + * Product:          SAS Text Miner
26481     + * Language:         Sas
26482     + * Script:
26483     + *
26484     + * Usage:
26485     + *
26486     + * Purpose:  macro to get the last filter node and the last parse node in the
26487     + *   diagram that corresponds to the current parse variable.  If there is no filter
26488     + *   node, the filter node is set to the last parse node.
26489     + *
26490     + *
26491     + *
26492     + * History:
26493     + * 14Aug09 Initial Coding
26494     + *
26495     + * Notes:
26496     + *    Returns an error in the following cases:
26497     + *      1. There is no preceding parse node.
26498     + *      2. There is no parse node with the current parse variable.
26499     + *
26500     + * Last Modified By:
26501     + * Last Modified On: Wed Sep 23 15:35:04 2009
26502     + *
26503     + * End
26504     + * ************************************************************** */
26505     +%macro tm_get_last_filter(eminfo=,em_lib=, em_variableset=);
26506     +   %let last_parse_node=;
26507     +   %let last_filter_node=;
26508     +   %let last_prescore_node=;
26509     +   %let server_err=;
26510     +   %let EMEXCEPTIONSTRING=;
26511     +   %let syscc=0;
26512     +
26513     +    /* verify that setinit for SAS Text Miner is currently active */
26514     +    %if %sysfunc(sysprod(PRODNUM107)) ne 1 %then %do;
26515     +       %let EMEXCEPTIONSTRING = EMTOOL.NOTMLICENSE;
26516     +        %goto end_macro;
26517     +        %end;
26518     +
26519     +
26520     +    * find last filter or text parse node if no filter node. ;
26521     +   %if %sysfunc(exist(&eminfo)) %then %do;
26522     +      proc sql noprint;
26523     +      select data into :last_parse_node from &eminfo where key="LastTextParsing";
26524     +         select data into :last_filter_node from &eminfo where key="LastTextFilter";
26525     +         select data into :last_prescore_node from &eminfo where kupcase(key)="PRESCORECODE";
26526     +      quit;
26527     +
26528     +   %end;
26529     +
26530     +   %if &last_parse_node= %then %do;
26531     +      %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGNODE;
26532     +      %goto end_macro;
26533     +      %end;
26534     +
26535     +   %else %if &last_filter_node= %then %let last_filter_node = %ktrim(&last_parse_node);
26536     +   %else %let last_filter_node = %ktrim(&last_filter_node);
26537     +   %let last_parse_node = %ktrim(&last_parse_node);
26538     +
26539     +   * Check to make sure parse variable is present and still exists;
26540     +   %let parsevar = ;
26541     +   proc sql noprint;
26542     +    select parsevar into :parsevar
26543     +    from &em_lib..&last_filter_node._tmconfig;
26544     +    quit;
26545     +
26546     +    *check for dropped parsevar on input dataset;
26547     +       %let parsevarOK= ;
26548     +       %let parsevarN=%kupcase(%ktrim(&parsevar));
26549     +       data _null_;
26550     +         set &em_variableset(where=(kupcase(NAME)="&parsevarN" and USE in('Y' 'D')));
26551     +         if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
26552     +         run;
26553     +       %if(&parsevarOK eq ) %then %do;
26554     +          %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGVAR;
26555     +          %goto end_macro;
26556     +          %end;
26557     +%end_macro:
26558     +
26559     +%mend tm_get_last_filter;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_GET_LAST_FILTER):   * find last filter or text parse node if no filter node. ;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select data into :last_parse_node from EMWS5.TextCluster5_last_tm_nodes where key="LastTextParsing";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_filter_node from EMWS5.TextCluster5_last_tm_nodes where key="LastTextFilter";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_prescore_node from EMWS5.TextCluster5_last_tm_nodes where kupcase(key)="PRESCORECODE";
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GET_LAST_FILTER):   * Check to make sure parse variable is present and still exists;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select parsevar into :parsevar from EMWS5.TextFilter5_tmconfig;
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GET_LAST_FILTER):   *check for dropped parsevar on input dataset;
MPRINT(TM_GET_LAST_FILTER):   data _null_;
MPRINT(TM_GET_LAST_FILTER):   set EMWS5.TextCluster5_VariableSet(where=(kupcase(NAME)="REVIEW" and USE in('Y' 'D')));
MPRINT(TM_GET_LAST_FILTER):   if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
MPRINT(TM_GET_LAST_FILTER):   run;
 
NOTE: 1개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_VARIABLESET.에서 읽었습니다.
      WHERE (KUPCASE(NAME)='REVIEW') and USE in ('D', 'Y');
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):   filename temp catalog 'sashelp.emtxtext.tm_data2code.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_DATA2CODE.SOURCE입니다.
26560     +/* ****************************************************************
26561     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
26562     + *
26563     + * Name:             tm_data2code.sas
26564     + * Product:          SAS Text Miner
26565     + * Language:         Sas
26566     + * Script:
26567     + *
26568     + * Usage:  %tm_data2code(data=, outdata=WORK.DATA);
26569     + *
26570     + * Purpose:          To do a data2code (like %em_data2code()) but allow the input data
26571     + *  to be view or data.
26572     + *
26573     + *    PARAMETERS:
26574     + *        DATA        = data set
26575     + *        OUTDATA     = out data set
26576     + *        OUTFILE     = file where to saved the code
26577     + *        APPEND      = append (Y/N)
26578     + * History:
26579     + * 11Jun09 Initial Coding
26580     + *
26581     + * Notes:
26582     + *
26583     + * Last Modified By:
26584     + * Last Modified On: Thu Jul 23 11:00:06 2009
26585     + *
26586     + * End
26587     + * ************************************************************** */
26588     +%macro tm_data2code(data=, outdata=WORK.DATA, outfile=, append=N);
26589     +%if &data eq %then %do;
26590     +   %put ERROR: Data set not defined;
26591     +   %end;
26592     +%else %do;
26593     +   %if (^%sysfunc(exist(&data)) and ^%sysfunc(exist(&data, view))) %then %do;
26594     +       %put ERROR: Data set does not exist;
26595     +       %end;
26596     +   %else %do;
26597     +      %global em_data em_outdata em_codefile em_append;
26598     +      %let em_data=&data;
26599     +      %let em_outdata=&outdata;
26600     +      %let em_codefile=&outfile;
26601     +      %let em_append=&append;
26602     +      proc display c=sashelp.emutil.data2code.scl; run;
26603     +      %end;
26604     +   %end;
26605     +%mend;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmemclus.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMEMCLUS.SOURCE입니다.
26606     +
26607     + /*
26608     +
26609     +  Macro:   tmemclus.sas
26610     +  Purpose: Call proc emclus with given defaults and parameters.
26611     +  Syntax:  %tmemclus(data=, role=, clusters=, seed=,
26612     +                   outstat=, out=, vars=, cov=, iter=, secclus=,
26613     +                   seciter=, min=, method=, eps=, init=, print=,
26614     +                   p=, outliers=, decvar=, initstd=, dist=,
26615     +                   secstd=, nobs=, threads=);
26616     +  Required Parameters:  data=      The input data set.
26617     +                        role=      Train or score
26618     +                        clusters=  The number of primary clusters
26619     +
26620     +  Optional Parameters:  vars=      Variables to be used
26621     +                   cov=       Type of covariance matrix
26622     +                   iter=      Number of EM iterations
26623     +                   secclus    Number of secondary clusters
26624     +                   seciter    Number of k-means iterations
26625     +                   min=       Minimum number of obs in a cluster
26626     +                   method=    Standard or scaled
26627     +                   eps=       Stopping tolerance
26628     +                   init=      Random, Fastclus, or Emclus
26629     +                   print=     All, last, or none
26630     +                   p=
26631     +                   outliers=  Keep, cluster, or ignore
26632     +                   outstat=   Name of OUTSTAT data set
26633     +                   out=       Name of OUT data set
26634     +                   seed=      Name of SEED data set
26635     +                   decvar=    Proportion to decrease variances
26636     +                   initstd=   Initial standard deviation
26637     +                   dist=      Minimum distance between clusters
26638     +                   secstd=    Secondary cluster max std dev.
26639     +                   nobs=      Number of obs read in each iteration
26640     +  History:
26641     +  2001/01/16 - Bill Wheeler - Initial Coding.
26642     +  2001/11/29 - Bill Wheeler - Updated for version 8 or 9
26643     +*/
26644     +%MACRO tmemclus(data=, role=, clusters=, seed=,
26645     + outstat=, out=, vars=, cov=, iter=, secclus=,
26646     + seciter=, min=, method=, eps=, init=, print=,
26647     + p=, outliers=, decvar=, initstd=, dist=, secstd=, nobs=, threads=);
26648     +
26649     + %local saveout saveseed op1 op2 op3 op4;
26650     +
26651     + %LET saveout = &out;
26652     + %LET saveseed = &outstat;
26653     +
26654     + /* defaults */
26655     + %if &role= %then %let role = TRAIN;
26656     + %if &seed ne %then %let seed = seed=&seed;
26657     + %if &vars= %then %let var = ;
26658     + %else %let var = var &vars;
26659     + %if &cov ne %then %let cov = cov = &cov;
26660     + %if &iter ne %then %let iter = iter = &iter;
26661     + %if &init ne %then %let init = init = &init;
26662     + %if &eps ne  %then %let eps = eps = &eps;
26663     + %if &min ne %then %let min = min = &min;
26664     + %if &seciter ne %then %let seciter = seciter = &seciter;
26665     + %if &print ne %then %let print = print = &print;
26666     + %if &p ne %then %let p = p = &p;
26667     + %if &outliers ne %then %let outliers = outliers = &outliers;
26668     + %if &method ne %then %let method = method = &method;
26669     + %if &decvar ne %then %let decvar = decvar = &decvar;
26670     + %if &outstat ne %then %let outstat = outstat = &outstat;
26671     + %if &out ne %then %let out = out = &out;
26672     + %if (&threads >= 0)  %then %let threads = threads = &threads;
26673     + %else %let threads = ;
26674     +
26675     + %LET op1 = ;
26676     + %LET op2 = ;
26677     + %LET op3 = ;
26678     + %LET op4 = ;
26679     + %if ^(&initstd=) %then %let op1 = %str(initstd = &initstd);
26680     + %if ^(&dist=) %then %let op2 = %str(dist = &dist);
26681     + %if ^(&secstd=) %then %let op3 = %str(secstd = &secstd);
26682     + %if ^(&nobs=) %then %let op4 = %str(nobs = &nobs);
26683     +
26684     +
26685     + %IF &SYSVER < 9 %THEN %DO;
26686     +    %LET cov = ;
26687     +    %LET decvar = ;
26688     +    %LET outliers = ;
26689     +    %LET out = ;
26690     + %END;
26691     +
26692     +
26693     + %if %upcase(&role) = TRAIN %then
26694     + %do;
26695     +   proc emclus data = &data
26696     +   clusters = &clusters
26697     +   &seed
26698     +   &outstat
26699     +   &out
26700     +   &init
26701     +   &eps
26702     +   &method
26703     +   &secclus
26704     +   &min
26705     +   &print
26706     +   &outliers
26707     +   &iter
26708     +   &op1 &op2
26709     +   &op3 &op4
26710     +   &decvar
26711     +   &cov
26712     +   &threads
26713     +   ;
26714     +   &var;
26715     + %end;
26716     + %else
26717     +  %do;
26718     +    proc emclus data = &data
26719     +    role = score
26720     +    clusters = &clusters
26721     +    &seed
26722     +    &out
26723     +    &cov
26724     +    ;
26725     +    &var;
26726     +  %end;
26727     +
26728     + %IF &SYSVER < 9 and &saveout ^= %THEN %DO;
26729     +   proc emclus data = &data
26730     +   role = score
26731     +   clusters = &clusters
26732     +   seed = &saveseed
26733     +   &saveout
26734     +   ;
26735     +   &var;
26736     + %END;
26737     +
26738     +
26739     +%MEND tmemclus;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmpred.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMPRED.SOURCE입니다.
26740     +
26741     +/*
26742     +  Macro: tmpred(inds,outds,clusters,type=,ignore=,freqDS=)
26743     +
26744     +  Description: This macro will take output from
26745     +     emclus and generate predicted
26746     +      predicted clusters.
26747     +
26748     +  Parms: inds - input data set, produced by emclus.
26749     +   outds - data set with clusters created by this macro.
26750     +   clusters - number of clusters that should be on this data set
26751     +   type - valid values: 'max' or 'prob'.  Max will just take the
26752     +      cluster with the highest probability as the predicted cluster.
26753     +      In the case of a tie the first cluster with that value will
26754     +       selected.
26755     +      Prob will attempt to select multiple clusters based on
26756     +      how many clusters were requested.  That is if 3 clusters
26757     +      were requested, any cluster with prob>1/3 will be selected
26758     +      as the predicted cluster. THIS OPTION IS UNTESTED.
26759     +*/
26760     +
26761     +%macro tmpred(inds,outds,clusters,type=, ignore=0, freqDS=, compress=1);
26762     +
26763     +  %local _str newfreqDS _flag;
26764     +
26765     +  * set the optional arguments;
26766     +  %if &type= %then %let type=max;
26767     +  %if &ignore = 1 %then %let
26768     +    _str = if _CLUSTER_ = &clusters then _CLUSTER_ = .;
26769     +  %else %let _str = ;
26770     +  %if %str(&freqDS) ^= %str() %then %do;
26771     +   %let newfreqDS = &freqDS(keep=_c1-_c&clusters);
26772     +   %let _flag = 1;
26773     +  %end;
26774     +  %else %let _flag = 0;
26775     +
26776     +  %if &compress = 1 %then %let compress = compress=Y;
26777     +  %else %let compress = ;
26778     +
26779     +  data &outds(&compress drop=_c1-_c&clusters)
26780     +    %if &_flag = 1 %then %do;
26781     +    &newfreqDS
26782     +    %end;
26783     +    ;
26784     +    set &inds end=eof;
26785     +   * array for holding all probabilities;
26786     +    array _p prob1--prob&clusters;
26787     +    array _c(&clusters);
26788     +    retain _c 0;
26789     +   * get rid of working columns;
26790     +    drop _max_ _i /*prob1--prob&clusters*/ _WARN_;
26791     +    /* keep the largest probability and the cluster */
26792     +    _max_ = 0;
26793     +    do _i = 1 to &clusters;
26794     +      if _p(_i) > _max_ then do;
26795     +        _max_ = _p(_i);
26796     +        _CLUSTER_ = _i;
26797     +      end;
26798     +    end;
26799     +    if (_CLUSTER_ >= 1) and (_CLUSTER_ <= &clusters) then
26800     +      _c(_CLUSTER_) = _c(_CLUSTER_) + 1;
26801     +    else _CLUSTER_ = .;
26802     +    &_str;
26803     +    %if &_flag = 1 %then %do;
26804     +      if eof then do;
26805     +        output &freqDS;
26806     +                output &outDS;
26807     +          end;
26808     +          else output &outDS;
26809     +        %end;
26810     +
26811     +    run;
26812     +%mend tmpred;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmsort.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMSORT.SOURCE입니다.
26813     + /*
26814     +PROC SORT macro
26815     +
26816     +%tmsort(data=, out=, by=);
26817     +
26818     +data=      - name of input data set (outtree data set from PROC CLUSTER)
26819     +out=       - name of the output data set
26820     +by=        - by statement
26821     +options=   - proc options
26822     +*/
26823     +
26824     +%macro tmsort(data=, out=, by=, options=, threads=THREADS);
26825     +  %if %BQUOTE(&out) ^= %then %let out = out =  &out;
26826     +  %if &SYSVER < 9 %then %let threads = ;
26827     +
26828     +  proc sort data = %STR(&data) &threads &options
26829     +    &out;
26830     +    by &by;
26831     +  run;
26832     +
26833     +%mend tmsort;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtxtext.tmc_doc_score.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TMC_DOC_SCORE.SOURCE입니다.
26834     +/*****************************************************************************
26835     +*
26836     +* tmc_doc_score
26837     +*
26838     +*  import  =  the doc data set of _document_ ids's as input
26839     +*  export = the new doc dataset with the svd dimensions and cluster results as output
26840     +*  termds = the terms table as input
26841     +*  clusters = input dataset of clusters from train
26842     +*  emoutstat = input dataset of seeds from training
26843     +*  _scrout = input OUT data set to be scored, may be trimmed based on conent of termds
26844     +*  svd_u = input singular vectors
26845     +
26846     +
26847     +*  svd_s = input singular values
26848     +*  prefxi = variable prefix string identifier.
26849     +*
26850     +**************************************************************************************/
26851     +
26852     +%macro tmc_doc_score(import=,export=,termds=,export_out=,clusters=,emoutstat=,
26853     +                 _scrout=,svd_u=,svd_s=,configds=,prefix=, outclusters=,hierds=,
26854     +                filterterms=,filtertmout=, descterms=);
26855     +
26856     +   %if ^%symexist(tm_debug) %then %let tm_debug=0;
26857     +
26858     +    proc sql noprint;
26859     +        select cellwgt into: cellwgt
26860     +            from &configds;
26861     +        select clus_alg into: algorithm
26862     +            from &configds;
26863     +        select parseVar into :textvar
26864     +            from &configds;
26865     +        select count(*) into :nclus
26866     +            from &clusters;
26867     +        select count(*) into :svdkeep
26868     +            from &svd_s
26869     +            where keep=1;
26870     +    quit;
26871     +
26872     +    %let svdkeep=%left(&svdkeep);
26873     +    %let nclus=%left(&nclus);
26874     +    %let algorithm=%left(&algorithm);
26875     +    %Let cellwgt=%left(&cellwgt);
26876     +    data _import_ds;
26877     +        set &import;
26878     +    run;
26879     +
26880     +
26881     +    %tmsort(data=&termds(where=(keep='Y')), out=_terms(keep= KEY PARENT),
26882     +            by=KEY);
26883     +    %tmsort(data=&_scrout, out=&_scrout, by=_termnum_);
26884     +
26885     +    data _svdm1;
26886     +        merge _terms (where=(PARENT ne _termnum_) in=_b_ keep=KEY PARENT rename=(KEY=_TERMNUM_))
26887     +              &_scrout (in = _A_ rename=(_COUNT_=COUNT));
26888     +        by _termnum_;
26889     +        if _B_;
26890     +        if (_A_ and _B_ and (PARENT ne .))
26891     +          then _TERMNUM_ = PARENT;
26892     +
26893     +        keep _TERMNUM_ _DOCUMENT_ COUNT;
26894     +        if (_DOCUMENT_=.) or (COUNT=.) then delete;
26895     +    run;
26896     +
26897     +    proc sql ;
26898     +       create table _scrout as select distinct _TERMNUM_, _DOCUMENT_,
26899     +        sum(COUNT) as _COUNT_ from _svdm1
26900     +        group by _TERMNUM_, _DOCUMENT_;
26901     +
26902     +       drop table _svdm1;
26903     +       drop table _terms;
26904     +    quit;
26905     +
26906     +    %tmsort(data=&termds(where=(KEEP='Y' and PARENT=.)),
26907     +         out=_weights (rename=(KEY=INDEX WEIGHT=GWGT) keep=KEY WEIGHT),
26908     +         by=KEY, options=, threads=);
26909     +
26910     +
26911     +    %tmsort(data=_scrout, out=_scrout, by=_DOCUMENT_, options=, threads=);
26912     +      %let svdkeep=%left(&svdkeep);
26913     +      data &svd_u;
26914     +         set &svd_u(keep= index col1-col&svdkeep);
26915     +      run;
26916     +
26917     +      proc sql;
26918     +         create table  _inweights as
26919     +         select a.*
26920     +         from _weights a right join &svd_u b
26921     +         on a.index=b.index
26922     +         ;
26923     +       quit;
26924     +    %if %lowcase(&cellwgt) = bin %then %let cellwgt=BINARY;
26925     +    proc spsvd data=_scrout IN_U=&svd_u
26926     +        local = &cellwgt global = none in_global = _inweights ;
26927     +        row _TERMNUM_;
26928     +        col _DOCUMENT_;
26929     +        entry _COUNT_;
26930     +        output colpro=_COLPRO bigpro normcol prefix="&prefix._SVD";
26931     +    run;
26932     +    proc sort data=_import_ds;
26933     +    by _DOCUMENT_; run;
26934     +
26935     +    proc sort data=_colpro;
26936     +    by INDEX;
26937     +    run;
26938     +
26939     +    data &export;
26940     +        merge _import_ds (in=_C_ ) _colpro (rename=(INDEX=_DOCUMENT_));
26941     +        by _DOCUMENT_;
26942     +        if _C_;
26943     +    run;
26944     +
26945     +    data &export;
26946     +       set  &export;
26947     +       array svd_array &prefix._SVD1 - &prefix._SVD&svdkeep.;
26948     +       do i = 1 to dim(svd_array);
26949     +          if svd_array(i)=. then svd_array(i)=0;
26950     +       end;
26951     +       drop i;
26952     +    run;
26953     +
26954     +
26955     +    %tmsort(data=&export, out=, by=_document_, options=, threads=);
26956     +
26957     +    %if %left(&algorithm)=1.0 %then %do;
26958     +
26959     +        %tmemclus(data=&export,
26960     +            role=SCORE, clusters=&nclus,
26961     +            seed=&emoutstat,
26962     +            outstat=, out=&export,
26963     +            vars=%STR(&prefix._SVD1 - &prefix._SVD&SVDKEEP),
26964     +            cov=, iter=5, secclus=,
26965     +            seciter=, min=, method=, eps=.1, init=, print=,
26966     +            p=, outliers=, decvar=0,
26967     +            initstd=, dist=, secstd=, nobs=);
26968     +        run;
26969     +
26970     +        %tmpred(&export, &export, &nclus, type=, ignore=0,
26971     +                  freqDS=, compress=1);
26972     +
26973     +        data &export;
26974     +           set &export;
26975     +           rename prob1-prob&nClus = &prefix._prob1-&prefix._prob&nclus;
26976     +           rename _cluster_=&prefix._cluster_;
26977     +        run;
26978     +
26979     +        %if &outclusters ne %then %do;
26980     +              %let memloc = _tmmem;
26981     +              proc tmutil data=&_scrout key=&filterterms ;
26982     +                 control init memloc="&memloc" release;
26983     +                 output keeponly out=_outtmutil;
26984     +              run;
26985     +
26986     +              data _docdata;
26987     +                 set &export (rename=(&prefix._cluster_=cluster));
26988     +              run;
26989     +
26990     +              /* Recalculate desc terms */
26991     +              data _terms_;
26992     +               set &filterterms;
26993     +               by key _ispar;
26994     +               if first.key then
26995     +                output;
26996     +               else;
26997     +              run;
26998     +
26999     +              data _terms_;
27000     +               set _terms_;
27001     +               if _ispar='+' then
27002     +                  Term=_ispar || ' ' || term;
27003     +              run;
27004     +
27005     +             %tmsort(data=_outtmutil,
27006     +               out=_tmout_,
27007     +               by=_termnum_,
27008     +                  options=,
27009     +               threads=threads);
27010     +
27011     +
27012     +             data _tmout_;
27013     +               merge _tmout_ (in=_A_)
27014     +                  _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
27015     +               by _termnum_;
27016     +               if _A_;
27017     +             run;
27018     +
27019     +             data _docs_;
27020     +               set _docdata (rename=(cluster=_cluster_) keep=_document_ cluster);
27021     +               _SEGMNT_=_cluster_;
27022     +             run;
27023     +
27024     +             %tmterm1(DSN_TPARS=_tmout_,
27025     +              DSN_CLUS=_docs_,
27026     +              DSN_DESC=_desc_,
27027     +              N_DESC_TERMS=&descterms,
27028     +              N_CLUS=&nclus,
27029     +              top_freq=%eval(&descterms*2),
27030     +              key=);
27031     +
27032     +             %tmsort(data=_desc_,
27033     +               out=_desc_,
27034     +               by=_cluster_,
27035     +                  options=,
27036     +               threads=threads);
27037     +
27038     +             proc sql noprint;
27039     +               create table &outclusters as
27040     +                 select a.clus_desc, b.* from &outclusters b left join _desc_ a
27041     +                 on a._cluster_=b._cluster_;
27042     +             quit;
27043     +
27044     +       %end;
27045     +
27046     +    %end;
27047     +    %else %do;
27048     +
27049     +        data _clustermean;
27050     +            set &clusters(keep=_cluster_ _mean1-_mean&svdkeep. freq);
27051     +        run;
27052     +
27053     +        proc sql;
27054     +        create table _meandocs as
27055     +            select a.*, b.*
27056     +            from &export(keep=&prefix._SVD1 - &prefix._SVD&SVDKEEP _document_) a , _clustermean b;
27057     +        quit;
27058     +
27059     +
27060     +        proc sort data=_meandocs;
27061     +        by _document_;
27062     +        run;
27063     +
27064     +        %if (&syscc>4) %then %do;
27065     +            %let emexceptionstring=EMTOOL.INSUFFICIENTMEM;
27066     +            %goto end_tmc;
27067     +        %end;
27068     +
27069     +        %tmsort(data=_meandocs,out=,by=_document_);
27070     +
27071     +          data _docdata(drop=_mean1-_mean&svdkeep. j _CLUSTER_ _freq_ rename=(_cluster_=&prefix._cluster_ distance=&prefix._distance));
27072     +            set _meandocs;
27073     +            drop _minDist_ _dist_ j freq;
27074     +            label CLUSTER = 'Cluster ID';
27075     +            array _means(&svdkeep) _mean1-_mean&svdkeep.;
27076     +            array _cols(&svdkeep) &prefix._SVD1-&prefix._SVD&svdkeep.;
27077     +            by _document_;
27078     +            retain CLUSTER _mindist_;
27079     +            _dist_ = 0;
27080     +            /* innner product*/
27081     +            do j = 1 to &svdkeep;
27082     +                _dist_ = _dist_ + (_cols(j)-_means(j))*(_cols(j)-_means(j));
27083     +            end;
27084     +
27085     +            /* initialization*/
27086     +            if first._document_ then do;
27087     +                _minDist_ = _dist_;
27088     +                CLUSTER = _cluster_;
27089     +            end;
27090     +            /*optimization*/
27091     +            if (_dist_ < _minDist_) then do;
27092     +                _minDist_ = _dist_;
27093     +                CLUSTER = _cluster_;
27094     +            end;
27095     +            if last._document_ then do;
27096     +               output;
27097     +            end;
27098     +        run;
27099     +        proc sort data=_docdata;
27100     +           by _document_;
27101     +        proc sort data=&export;
27102     +           by _document_;
27103     +        run;
27104     +
27105     +        data &export;
27106     +           merge &export _docdata;
27107     +           by _document_;
27108     +           rename cluster=&prefix._cluster_;
27109     +        run;
27110     +    %end;
27111     +
27112     +    /* Reorder variables in exported data set */
27113     +    proc sql noprint;
27114     +        create table &export as
27115     +        select &textvar, &prefix._cluster_, *
27116     +        from &export;
27117     +    quit;
27118     +
27119     +
27120     +    %if &outclusters ne %then %do;
27121     +
27122     +        /* update freqencies in cluster table */
27123     +         proc freq data =_docdata ;
27124     +            tables cluster/out=_tempfreqtable;
27125     +         run;
27126     +
27127     +        proc sql noprint;
27128     +            create table &outclusters as
27129     +            select  a.*, b.count as freq, b.percent/100 as percent
27130     +            from &clusters (drop= freq percent _rmsstd_) a, _tempfreqtable b
27131     +           where a._cluster_=b.cluster;
27132     +
27133     +        quit;
27134     +
27135     +        %if %left(&algorithm)=2.0 %then %do;
27136     +
27137     +          proc sql noprint;
27138     +
27139     +             create table &hierds as select a.freq, b.*
27140     +                from &outclusters a right join &hierds b on a._cluster_=b._cluster_;
27141     +          quit;
27142     +
27143     +          /* Find descriptive terms for clusters & parents */
27144     +          filename temp catalog 'sashelp.emtxtext.tmgethierterms.source';
27145     +          %include temp;
27146     +          filename temp;
27147     +
27148     +          %tm_getHierTerms(hierds=&hierds,
27149     +                         docs=_docdata,
27150     +                         tmout=&filtertmout,
27151     +                         terms= &filterterms,
27152     +                         ndescterms=&descterms);
27153     +
27154     +          proc sql noprint;
27155     +             create table &outclusters as
27156     +                select a.clus_desc, b.* from &hierds a, &outclusters b
27157     +                where a._cluster_=b._cluster_;
27158     +
27159     +             update &hierds set freq=0 where clus_desc="" and _cluster_ ne 1;
27160     +          quit;
27161     +
27162     +          /* Add frequencies to ancestors */
27163     +          data _hd;
27164     +             set &hierds;
27165     +             cluster=_cluster_;
27166     +             drop _cluster_ parent;
27167     +          run;
27168     +
27169     +          %let empty=1;
27170     +
27171     +          %do %while (&empty);
27172     +
27173     +            proc sql noprint;
27174     +                update _hd set freq=
27175     +                    (select sum(freq) from &HIERDS
27176     +                    where parent=cluster)
27177     +                    where freq=. and cluster not in
27178     +                    (select parent from &hierds where freq=.);
27179     +                select count(*) into :empty from _hd
27180     +                    where freq=.;
27181     +                update &hierds set freq=(select freq from _hd where _cluster_=cluster);
27182     +            quit;
27183     +
27184     +          %end;
27185     +
27186     +          /* Set graphdesc variable for graph display */
27187     +          data &hierds(drop=plus pos sub);
27188     +            set &hierds;
27189     +            plus='';
27190     +            if substr(CLUS_DESC, 1, 1) = "+" then plus="+ ";
27191     +            if ktrim(clus_desc) ne "" then do;
27192     +              if(substr(CLUS_DESC, 1, 1)) = "'" then do;
27193     +                 pos = findc(CLUS_DESC, "'",2);
27194     +                 sub = substr(CLUS_DESC,1,pos);
27195     +              end;
27196     +              else sub = scan(CLUS_DESC, 1);
27197     +              graphdesc=_CLUSTER_ || ': ' || plus || sub;
27198     +            end;
27199     +            else graphdesc=_CLUSTER_;
27200     +          run;
27201     +        %end;
27202     +
27203     +         /*calculate residual for each doc */
27204     +
27205     +         proc sort data=_docdata (rename=(cluster=_cluster_));
27206     +            by _cluster_;
27207     +         run;
27208     +
27209     +         data _rmscalc;
27210     +            merge _docdata(in=inhere) &outclusters;
27211     +            array _means(&svdkeep) _mean1-_mean&svdkeep.;
27212     +            array _svds(&svdkeep) &prefixstring._SVD1 - &prefixstring._SVD&svdkeep.;
27213     +            by _cluster_;
27214     +            error=0;
27215     +            do i = 1 to &svdkeep;
27216     +               error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
27217     +            end;
27218     +
27219     +            drop i ;
27220     +         run;
27221     +
27222     +          /*calc standardized residual for clusters*/
27223     +         proc summary data=_rmscalc nway;
27224     +            class _cluster_;
27225     +            var error;
27226     +            output out=_meanerr mean=meane sum=sume;
27227     +         run;
27228     +
27229     +         data _rmsse;
27230     +            set _meanerr;
27231     +            /* original code divides by number of svd dims*/
27232     +            if _freq_ gt 1 then do;
27233     +              _rmsstd_=sqrt(sume/((_freq_-1)*(&svdkeep.)));
27234     +            end;
27235     +            else do;
27236     +              _rmsstd_=0;
27237     +            end;
27238     +            keep _cluster_  _rmsstd_;
27239     +         run;
27240     +
27241     +
27242     +         proc sql noprint;
27243     +           create table _clusstat2 as
27244     +           select a.*,b.*
27245     +           from &outclusters a left join _rmsse b
27246     +           on a._cluster_=b._cluster_;
27247     +
27248     +           create table &outclusters as
27249     +           select * from _clusstat2;
27250     +         quit;
27251     +
27252     +
27253     +    %end;
27254     +
27255     +
27256     +%end_tmc:
27257     +    %if &tm_debug =0  %then %do;
27258     +    proc sql noprint;
27259     +        drop table _weights;
27260     +        drop table _colpro;
27261     +        drop table _scrout;
27262     +        drop table _svdm1;
27263     +        drop table _inweights;
27264     +        drop table _clustermean;
27265     +        drop table _clusstat2;
27266     +        drop table _outtmutil;
27267     +        drop table _rmscalc;
27268     +        drop table _rmsse;
27269     +        drop table _meanerr;
27270     +        drop table _meandocs;
27271     +        drop table _import_ds;
27272     +        drop table _hd;
27273     +        drop table _terms_;
27274     +        drop table _docs_;
27275     +        drop table _tmout_;
27276     +        drop table _desc_;
27277     +        drop table _docdata;
27278     +    quit;
27279     +    %end;
27280     +
27281     +%mend tmc_doc_score;
27282     +
27283     +
27284     +
27285     +
27286     +
27287     +
27288     +
27289     +
27290     +
27291     +
27292     +
27293     +
27294     +
27295     +
27296     +
27297     +
27298     +
27299     +
27300     +
27301     +
27302     +
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmsvd.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMSVD.SOURCE입니다.
27304     + /*
27306     +  Macro:     tmsvd.sas
27307     +  Purpose:  Call proc spsvd with given defaults and parameters.
27308     +  Syntax:   %tmsvd(in,k=,global=,local=,row=,col=,entry=,scaleOp=,normOp=,
27309     +            in_global=,in_u=,in_s=,in_v=,u=,s=,v=,wgt=,wordPro=,
27310     +           colPro=, p=, tol=, gwgt=, mink=, maxk=, res=, remote=, compact=,bigpro=0);
27312     +  Required Parameters:  in     The data= data set.
27313     +  Optional Parameters:  k= The number of dimensions to reduce to
27314     +                   global=  The global weight to use, defaults to IDF.
27315     +                   local=  The local weight to use, defaults to BINARY.
27316     +                   row=   Column in the input data set that represents
27317     +                          the matrix row,
27318     +                       defaults to _termnum_.
27319     +            col=   Column in the input data set that represents
27320     +                          the matrix column,
27321     +                         defaults to _document_.
27322     +            entry= Column in the input data set that represents the
27323     +                          value in the
27324     +                         given row,column cell.  Defaults to _count_.
27325     +             scaleOp= Scale options: scalerow scalecol scaleall
27326     +            normOp=  Normalization options: normrow normcol normall
27327     +            in_global= The gwgt= output data set from a prior spsvd run.
27328     +                   in_u=  The u= output from a prior spsvd run.
27329     +                   in_s=  The s= output from a prior spsvd run.
27330     +                   in_v=  The v= output from a prior spsvd run.
27331     +                   u=     matrix U data set
27332     +                   s=     matrix S data set
27333     +                   v=     matrix V data set
27334     +                  wgt=   weighted input matrix data set
27335     +                  wordPro= projections of rows of A onto columns of V
27336     +                  colPro=  projection of columns of A onto columns of U
27337     +                  p=   number of iterations
27338     +                  tol= convergence tolerance
27339     +                   gwgt= global weights data set
27340     +                  mink=
27341     +                  maxk=
27342     +                  res=
27343     +                  remote= name of file
27345     +  History:
27346     +  2001/01/16 - Kevin Daly - Initial coding.
27347     +  2001/01/19 - Kevin Daly - Fixed so that when global=NONE and local=NONE,
27348     +             no gwgt data set
27349     +               is requested.  This was causing an error and the proc
27350     +              would terminate.
27351     +  2001/02/21 - Bill Wheeler - Allowd all options to be specified
27352     +  2001/05/14 - Bill Wheeler - Added version 9 options min_k, max_k, resolution
27353     +  2001/08/14 - Bill Wheeler - Added remote option
27354     +  2001/11/29 - Bill Wheeler - Updated for version 8 or 9
27355     +*/
27357     +%macro tmsvd(in,k=,global=,local=,row=,col=,entry=,scaleOp=,normOp=,
27358     +             in_global=, in_u=, in_s=, in_v=, u=, s=, v=,
27359     +             wgt=, wordPro=, colPro=, p=, tol=, gwgt=, mink=, maxk=, res=,
27360     +             remote=, compact=,bigpro= );
27362     +  %put;
27363     +  /* Defaults */
27364     +  %if &k ^= %then %let k = k = &k;
27365     +  %if &global ^= %then %let global = global = &global;
27366     +  %if %lowcase(&local) = bin %then %let local=BINARY;
27367     +  %if &local ^= %then %let local=local=&local;
27368     +  %if &row= %then %let row=_termnum_;
27369     +  %if &col= %then %let col=_document_;
27370     +  %if &entry= %then %let entry=_count_;
27371     +  %if &scaleOp ^= %then %let scaleOp = scaledoc;
27372     +  %if &normOp ^= %then %let normOp = normdoc;
27373     +  %if &compact ^= %then %let compact = compact;
27374     +  %else %let compact = ;
27376     +  %if &in_global ^= %then %let in_global = in_global=&in_global;
27377     +  %if &in_u ^= %then %let in_u = in_u=&in_u;
27378     +  %if &in_s ^= %then %let in_s = in_s=&in_s;
27379     +  %if &in_v ^= %then %let in_v = in_v=&in_v;
27380     +  %if ((&p ^= ) and (&p ^= .)) %then %let p = p=&p;
27381     +  %else %let p = ;
27382     +  %if ((&tol ^= ) and (&tol ^= .)) %then %let tol = tol=&tol;
27383     +  %else %let tol = ;
27385     +  %IF &SYSVER < 9 %THEN %DO;
27386     +    %IF &k = %THEN %DO;
27387     +      %IF &maxk ^= %THEN %LET k = k = &maxk;
27388     +      %ELSE %LET k = k = 100;
27389     +    %END;
27390     +    %LET mink = ;
27391     +    %LET maxk = ;
27392     +    %LET res = ;
27393     +    %LET remote = ;
27394     +    %LET compact = ;
27395     +  %END;
27398     +  %if &colPro ^= %then %let colPro = COLPRO=&colPro;
27399     +  %if &gwgt ^= %then %let gwgt = GWGT=&gwgt;
27400     +  %if &s ^= %then %let s = S=&s;
27401     +  %if &u ^= %then %let u = U=&u;
27402     +  %if &v ^= %then %let v = V=&v;
27403     +  %if &wordPro ^= %then %let wordPro = WORDPRO=&wordPro;
27404     +  %if &wgt ^= %then %let wgt = WGT=&wgt;
27405     +  %if (&mink ^=  ) and (&mink ^= .) %then %let mink = min_k = &mink;
27406     +  %else %let mink = ;
27407     +  %if &maxk ^= %then %let maxk = max_k = &maxk;
27408     +  %if &res ^= %then %let res = res = &res;
27409     +  proc sort data=&in; by &col;
27410     +  /* Run the proc */
27411     +  proc spsvd data=&in
27412     +      &mink
27413     +      &maxk
27414     +      &res
27415     +      &k &compact
27416     +    &local &global &in_global
27417     +    &in_u &in_s &in_v &p &tol;
27418     +    row &row; col &col; entry &entry;
27419     +      output &colPro &gwgt &normOp &scaleOp &s &u &v
27420     +           &wordPro &wgt &bigpro;
27421     +    &remote;
27422     +  run;
27424     +%mend tmsvd;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmfast.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMFAST.SOURCE입니다.
27425     + /*
27426     +
27427     +  Macro:   tmfast.sas
27428     +  Purpose: Call proc fastclus with given defaults and parameters.
27429     +  Syntax:  %tmfast(data=, clusters=, outstat=, vars=);
27430     +
27431     +  Required Parameters:  data=      The input data set.
27432     +                        clusters=  The maximum number of clusters
27433     +
27434     +  Optional Parameters:  vars=      Variables to be used
27435     +                        outstat=   The name of the OUTSTAT data set
27436     +                        outseed=   The name of the OUTSEED data set
27437     +
27438     +  Either outstat or outseed mut be given, but not both.
27439     +  History:
27440     +  2001/01/16 - Bill Wheeler - Initial Coding.
27441     +
27442     +*/
27443     +%MACRO tmfast(data=, clusters=, outstat=, outseed=,
27444     +                 id=, out=, vars=);
27445     + /* defaults */
27446     + %if (&id ne ) %then %let id = id &id;
27447     + %if (&out ne ) %then %let out = out = &out;
27448     + %if (&vars ne ) %then %let var = var &vars;
27449     + %else %let var = ;
27450     +
27451     + %if &outseed= %then
27452     + %do;
27453     +   proc fastclus data = &data
27454     +   maxclusters = &clusters noprint
27455     +   outstat = &outstat &out;
27456     +   &var;
27457     +   &id;
27458     + %end;
27459     + %else
27460     + %do;
27461     +   proc fastclus data = &data
27462     +   maxclusters = &clusters noprint
27463     +   outseed = &outseed &out;
27464     +   &var;
27465     +   &id;
27466     + %end;
27467     +%MEND tmfast;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   proc sql noprint;
MPRINT(SCORE):   select count(*) into :svdkeep from EMWS5.TextCluster5_svd_s where keep=1;
MPRINT(SCORE):   create table _clusterms as select key, term, role, keep, freq, numdocs, parent, _ispar, weight from EMWS5.TextCluster5_terms;
NOTE: Table WORK._CLUSTERMS created, with 1376 rows and 9 columns.
 
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(SCORE):   data _filter_tmout;
MPRINT(SCORE):   set EMWS5.TextFilter5_tmout;
MPRINT(SCORE):   run;
 
NOTE: 4155개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._FILTER_TMOUT은(는) 4155개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   select cellwgt into: cellwgt from EMWS5.TextCluster5_tmconfig;
MPRINT(TMC_DOC_SCORE):   select clus_alg into: algorithm from EMWS5.TextCluster5_tmconfig;
MPRINT(TMC_DOC_SCORE):   select parseVar into :textvar from EMWS5.TextCluster5_tmconfig;
MPRINT(TMC_DOC_SCORE):   select count(*) into :nclus from EMWS5.TextCluster5_clusters;
MPRINT(TMC_DOC_SCORE):   select count(*) into :svdkeep from EMWS5.TextCluster5_svd_s where keep=1;
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   data _import_ds;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextFilter5_TRAIN;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTPARSING5_TRAIN.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_DOC_IDS.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 WORK._IMPORT_DS은(는) 496개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
 
MPRINT(TMSORT):   proc sort data = _clusterms(where=(keep='Y')) THREADS out = _terms(keep= KEY PARENT);
MPRINT(TMSORT):   by KEY;
MPRINT(TMSORT):   run;
 
NOTE: 입력 데이터셋이 이미 정렬되어 있습니다; 출력 데이터셋에 복사되었습니다.
NOTE: 1376개의 관측값을 데이터셋 WORK._CLUSTERMS.에서 읽었습니다.
      WHERE keep='Y';
NOTE: 데이터셋 WORK._TERMS은(는) 1376개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMSORT):   proc sort data = _filter_tmout THREADS out = _filter_tmout;
MPRINT(TMSORT):   by _termnum_;
MPRINT(TMSORT):   run;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._FILTER_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._FILTER_TMOUT은(는) 4155개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data _svdm1;
MPRINT(TMC_DOC_SCORE):   merge _terms (where=(PARENT ne _termnum_) in=_b_ keep=KEY PARENT rename=(KEY=_TERMNUM_)) _filter_tmout (in = _A_ rename=(_COUNT_=COUNT));
MPRINT(TMC_DOC_SCORE):   by _termnum_;
MPRINT(TMC_DOC_SCORE):   if _B_;
MPRINT(TMC_DOC_SCORE):   if (_A_ and _B_ and (PARENT ne .)) then _TERMNUM_ = PARENT;
MPRINT(TMC_DOC_SCORE):   keep _TERMNUM_ _DOCUMENT_ COUNT;
MPRINT(TMC_DOC_SCORE):   if (_DOCUMENT_=.) or (COUNT=.) then delete;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 1376개의 관측값을 데이터셋 WORK._TERMS.에서 읽었습니다.
      WHERE PARENT not = _termnum_;
NOTE: 4155개의 관측값을 데이터셋 WORK._FILTER_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDM1은(는) 4155개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql ;
MPRINT(TMC_DOC_SCORE):   create table _scrout as select distinct _TERMNUM_, _DOCUMENT_, sum(COUNT) as _COUNT_ from _svdm1 group by _TERMNUM_, _DOCUMENT_;
NOTE: Table WORK._SCROUT created, with 4155 rows and 3 columns.
 
MPRINT(TMC_DOC_SCORE):   drop table _svdm1;
NOTE: 테이블 WORK._SVDM1 을(를) 삭제했습니다.
MPRINT(TMC_DOC_SCORE):   drop table _terms;
NOTE: 테이블 WORK._TERMS 을(를) 삭제했습니다.
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMSORT):   proc sort data = _clusterms(where=(KEEP='Y' and PARENT=.)) out = _weights (rename=(KEY=INDEX WEIGHT=GWGT) keep=KEY WEIGHT);
MPRINT(TMSORT):   by KEY;
MPRINT(TMSORT):   run;
 
NOTE: 입력 데이터셋이 이미 정렬되어 있습니다; 출력 데이터셋에 복사되었습니다.
NOTE: 1376개의 관측값을 데이터셋 WORK._CLUSTERMS.에서 읽었습니다.
      WHERE (KEEP='Y') and (PARENT=.);
NOTE: 데이터셋 WORK._WEIGHTS은(는) 1376개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMSORT):   proc sort data = _scrout out = _scrout;
MPRINT(TMSORT):   by _DOCUMENT_;
MPRINT(TMSORT):   run;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._SCROUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._SCROUT은(는) 4155개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster5_svd_u;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster5_svd_u(keep= index col1-col45);
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 560개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_SVD_U.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_SVD_U은(는) 560개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql;
MPRINT(TMC_DOC_SCORE):   create table _inweights as select a.* from _weights a right join EMWS5.TextCluster5_svd_u b on a.index=b.index ;
NOTE: Table WORK._INWEIGHTS created, with 560 rows and 2 columns.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc spsvd data=_scrout IN_U=EMWS5.TextCluster5_svd_u local = LOG global = none in_global = _inweights ;
MPRINT(TMC_DOC_SCORE):   row _TERMNUM_;
MPRINT(TMC_DOC_SCORE):   col _DOCUMENT_;
MPRINT(TMC_DOC_SCORE):   entry _COUNT_;
MPRINT(TMC_DOC_SCORE):   output colpro=_COLPRO bigpro normcol prefix="TextCluster5_SVD";
MPRINT(TMC_DOC_SCORE):   run;
 
WARNING: There are entries to be projected that are not on the IN_U dataset.
NOTE: 4155개의 관측값을 데이터셋 WORK._SCROUT.에서 읽었습니다.
NOTE: 560개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_SVD_U.에서 읽었습니다.
NOTE: 560개의 관측값을 데이터셋 WORK._INWEIGHTS.에서 읽었습니다.
NOTE: 데이터셋 WORK._COLPRO은(는) 445개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: 프로시저 SPSVD 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sort data=_import_ds;
MPRINT(TMC_DOC_SCORE):   by _DOCUMENT_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._IMPORT_DS.에서 읽었습니다.
NOTE: 데이터셋 WORK._IMPORT_DS은(는) 496개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sort data=_colpro;
MPRINT(TMC_DOC_SCORE):   by INDEX;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 445개의 관측값을 데이터셋 WORK._COLPRO.에서 읽었습니다.
NOTE: 데이터셋 WORK._COLPRO은(는) 445개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster5_TRAIN;
MPRINT(TMC_DOC_SCORE):   merge _import_ds (in=_C_ ) _colpro (rename=(INDEX=_DOCUMENT_));
MPRINT(TMC_DOC_SCORE):   by _DOCUMENT_;
MPRINT(TMC_DOC_SCORE):   if _C_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._IMPORT_DS.에서 읽었습니다.
NOTE: 445개의 관측값을 데이터셋 WORK._COLPRO.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_TRAIN은(는) 496개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster5_TRAIN;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster5_TRAIN;
MPRINT(TMC_DOC_SCORE):   array svd_array TextCluster5_SVD1 - TextCluster5_SVD45;
MPRINT(TMC_DOC_SCORE):   do i = 1 to dim(svd_array);
MPRINT(TMC_DOC_SCORE):   if svd_array(i)=. then svd_array(i)=0;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   drop i;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_TRAIN은(는) 496개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = EMWS5.TextCluster5_TRAIN ;
MPRINT(TMSORT):   by _document_;
MPRINT(TMSORT):   run;
 
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_TRAIN은(는) 496개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data _clustermean;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster5_clusters(keep=_cluster_ _mean1-_mean45 freq);
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 16개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSTERMEAN은(는) 16개의 관측값과 47개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql;
MPRINT(TMC_DOC_SCORE):   create table _meandocs as select a.*, b.* from EMWS5.TextCluster5_TRAIN(keep=TextCluster5_SVD1 - TextCluster5_SVD45 _document_) a , _clustermean b;
NOTE: The execution of this query involves performing one or more Cartesian product joins that can not be optimized.
NOTE: Table WORK._MEANDOCS created, with 7936 rows and 93 columns.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sort data=_meandocs;
MPRINT(TMC_DOC_SCORE):   by _document_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 7936개의 관측값을 데이터셋 WORK._MEANDOCS.에서 읽었습니다.
NOTE: 데이터셋 WORK._MEANDOCS은(는) 7936개의 관측값과 93개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.03 초
 
 
MPRINT(TMSORT):   proc sort data = _meandocs THREADS ;
MPRINT(TMSORT):   by _document_;
MPRINT(TMSORT):   run;
 
NOTE: 입력 데이터셋이 이미 정렬되어 있어서, 정렬을 실행하지 않았습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data _docdata(drop=_mean1-_mean45 j _CLUSTER_ _freq_ rename=(_cluster_=TextCluster5_cluster_ distance=TextCluster5_distance));
MPRINT(TMC_DOC_SCORE):   set _meandocs;
MPRINT(TMC_DOC_SCORE):   drop _minDist_ _dist_ j freq;
MPRINT(TMC_DOC_SCORE):   label CLUSTER = 'Cluster ID';
MPRINT(TMC_DOC_SCORE):   array _means(45) _mean1-_mean45;
MPRINT(TMC_DOC_SCORE):   array _cols(45) TextCluster5_SVD1-TextCluster5_SVD45;
MPRINT(TMC_DOC_SCORE):   by _document_;
MPRINT(TMC_DOC_SCORE):   retain CLUSTER _mindist_;
MPRINT(TMC_DOC_SCORE):   _dist_ = 0;
MPRINT(TMC_DOC_SCORE):   do j = 1 to 45;
MPRINT(TMC_DOC_SCORE):   _dist_ = _dist_ + (_cols(j)-_means(j))*(_cols(j)-_means(j));
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   if first._document_ then do;
MPRINT(TMC_DOC_SCORE):   _minDist_ = _dist_;
MPRINT(TMC_DOC_SCORE):   CLUSTER = _cluster_;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   if (_dist_ < _minDist_) then do;
MPRINT(TMC_DOC_SCORE):   _minDist_ = _dist_;
MPRINT(TMC_DOC_SCORE):   CLUSTER = _cluster_;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   if last._document_ then do;
MPRINT(TMC_DOC_SCORE):   output;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   run;
 
WARNING: DROP, KEEP 또는 RENAME의 변수 j은(는) 참조되지 않습니다.
WARNING: DROP, KEEP 또는 RENAME의 변수 _freq_은(는) 참조되지 않습니다.
WARNING: DROP, KEEP 또는 RENAME의 변수 _cluster_은(는) 참조되지 않습니다.
WARNING: DROP, KEEP 또는 RENAME의 변수 distance은(는) 참조되지 않습니다.
NOTE: 7936개의 관측값을 데이터셋 WORK._MEANDOCS.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCDATA은(는) 496개의 관측값과 47개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sort data=_docdata;
MPRINT(TMC_DOC_SCORE):   by _document_;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCDATA은(는) 496개의 관측값과 47개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sort data=EMWS5.TextCluster5_TRAIN;
MPRINT(TMC_DOC_SCORE):   by _document_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 입력 데이터셋이 이미 정렬되어 있어서, 정렬을 실행하지 않았습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster5_TRAIN;
MPRINT(TMC_DOC_SCORE):   merge EMWS5.TextCluster5_TRAIN _docdata;
MPRINT(TMC_DOC_SCORE):   by _document_;
MPRINT(TMC_DOC_SCORE):   rename cluster=TextCluster5_cluster_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 496개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_TRAIN.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_TRAIN은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster5_TRAIN as select review , TextCluster5_cluster_, * from EMWS5.TextCluster5_TRAIN;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 Review이(가) 파일 EMWS5.TEXTCLUSTER5_TRAIN에 이미 존재합니다.
WARNING: 변수 TextCluster5_cluster_이(가) 파일 EMWS5.TEXTCLUSTER5_TRAIN에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER5_TRAIN created, with 496 rows and 49 columns.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc freq data =_docdata ;
MPRINT(TMC_DOC_SCORE):   tables cluster/out=_tempfreqtable;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._TEMPFREQTABLE은(는) 16개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 출력 결과 (프로시저: FREQ, 페이지: 2)
NOTE: 프로시저 FREQ 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster5_clusters as select a.*, b.count as freq, b.percent/100 as percent from EMWS5.TextCluster5_clusters (drop= freq percent _rmsstd_) a, _tempfreqtable b where a._cluster_=b.cluster;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS5.TEXTCLUSTER5_CLUSTERS created, with 16 rows and 49 columns.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster5_hierds as select a.freq, b.* from EMWS5.TextCluster5_clusters a right join EMWS5.TextCluster5_hierds b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 Freq이(가) 파일 EMWS5.TEXTCLUSTER5_HIERDS에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER5_HIERDS created, with 32 rows and 6 columns.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   filename temp catalog 'sashelp.emtxtext.tmgethierterms.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TMGETHIERTERMS.SOURCE입니다.
27468     +%macro tm_getHierTerms(hierds=,docs=,tmout=,terms=,ndescterms=);
27469     +
27470     +      filename temp catalog 'sashelp.emtext.tmterm1.source';
27471     +      %include temp;
27472     +      filename temp catalog 'sashelp.emtext.tmsort.source';
27473     +      %include temp;
27474     +      filename temp;
27475     +
27476     +      data _terms_;
27477     +       set &terms;
27478     +       by key _ispar;
27479     +       if first.key then
27480     +          output;
27481     +       else;
27482     +    run;
27483     +
27484     +    /* Concatenate + to terms */
27485     +    data _terms_;
27486     +        set _terms_;
27487     +        if _ispar='+' then
27488     +            Term=_ispar || ' ' || term;
27489     +    run;
27490     +
27491     +    %tmsort(data=&tmout,
27492     +         out=_tmout_,
27493     +         by=_termnum_,
27494     +            options=,
27495     +         threads=threads);
27496     +
27497     +
27498     +    data _tmout_;
27499     +      merge _tmout_ (in=_A_)
27500     +            _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
27501     +      by _termnum_;
27502     +      if _A_;
27503     +    run;
27504     +
27505     +
27506     +      data &hierds;
27507     +            set &hierds (drop=clus_desc);
27508     +            length clus_desc $2000;
27509     +            clus_desc="";
27510     +      run;
27511     +
27512     +      data _hierds; set &hierds; run;
27513     +
27514     +      /* initialize tables to create table of ancestors */
27515     +      proc sql noprint;
27516     +            select max(level) into :level from _hierds;
27517     +            create table _ancestors as select _cluster_, parent, parent as ancestor,
27518     +                  parent as newclus from _hierds;
27519     +            create table _hierds as select a.*, newclus from _hierds a, _ancestors b
27520     +                  where a._cluster_=b._cluster_;
27521     +
27522     +            alter table _ancestors add tlevel int;
27523     +            update _ancestors set tlevel=(select level from &hierds a where
27524     +                a._cluster_=ancestor);
27525     +      quit;
27526     +
27527     +      %let nottop=1;
27528     +
27529     +      /* create ancestors table, one record for each ancestor of a cluster */
27530     +      %do %while (&nottop);
27531     +            proc sql noprint;
27532     +                  create table _ancestors2 as select a._cluster_, a.parent,
27533     +                  b.parent as ancestor, b.parent as newcluster,
27534     +                  (select level from &hierds c where c._cluster_=b.parent) as tlevel
27535     +                  from _hierds a, _hierds b where a.newclus=b._cluster_;
27536     +
27537     +                  select count(*) into :nottop from _ancestors2;
27538     +
27539     +                  create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level
27540     +                  from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
27541     +            quit;
27542     +
27543     +            data _ancestors (drop=newclus newcluster parent);
27544     +                  set _ancestors _ancestors2;
27545     +                  if ancestor ne .;
27546     +            run;
27547     +      %end;
27548     +
27549     +
27550     +      proc sql noprint;
27551     +           insert into _ancestors(_cluster_, ancestor, tlevel)
27552     +                select _cluster_, _cluster_, level
27553     +                from &hierds
27554     +                where freq ne .;
27555     +      quit;
27556     +
27557     +      proc sort data=_ancestors; by ancestor; run;
27558     +
27559     +      /* Find desc terms for each cluster */
27560     +      %do %while(&level ne 1);
27561     +
27562     +            data _docs_ ;
27563     +                  set &docs;
27564     +                  _SEGMNT_=.;
27565     +                  ancestor=.;
27566     +            run;
27567     +
27568     +            proc sql noprint;
27569     +                  create table _level as select _cluster_ as clust
27570     +                        from &hierds where level=&level;
27571     +
27572     +                  select count(*) into :nclus from _level;
27573     +
27574     +                  update _docs_ set ancestor=(select ancestor from _ancestors
27575     +                         where _cluster_=cluster and tlevel=&level);
27576     +
27577     +            quit;
27578     +
27579     +            data _level;
27580     +                  set _level;
27581     +                  segmnt=_n_;
27582     +            run;
27583     +
27584     +            proc sql noprint;
27585     +                  update _docs_ set _SEGMNT_=(select segmnt from _level where
27586     +                        clust=ancestor) where ancestor in (select clust from _level);
27587     +            quit;
27588     +
27589     +            data _docs_;
27590     +                set _docs_(rename=(cluster=_CLUSTER_));
27591     +            run;
27592     +
27593     +            %tmterm1(DSN_TPARS=_tmout_,
27594     +              DSN_CLUS=_docs_,
27595     +              DSN_DESC=_desc_,
27596     +              N_DESC_TERMS=&ndescterms,
27597     +              N_CLUS=&nclus,
27598     +              top_freq=%eval(&ndescterms*2),
27599     +              key=);
27600     +
27601     +            data _desc_(rename=(_CLUSTER_=clus));
27602     +                 set _desc_;
27603     +            run;
27604     +
27605     +            proc sql noprint;
27606     +                  update &hierds set clus_desc=(select clus_desc
27607     +                        from _desc_ where clus=(select segmnt
27608     +                        from _level where clust=_cluster_)) where _cluster_ in
27609     +                        (select clust from _level);
27610     +            quit;
27611     +
27612     +            %let level=%eval(&level-1);
27613     +      %end;
27614     +
27615     +%end_getdesc:
27616     +   %if &tm_debug =0 %then %do;
27617     +        proc sql noprint;
27618     +            drop table _ancestors;
27619     +            drop table _ancestors2;
27620     +            drop table _terms_;
27621     +            drop table _docs_;
27622     +            drop table _tmout_;
27623     +            drop table _desc_;
27624     +            drop table _hierds;
27625     +            drop table _level;
27626     +        quit;
27627     +    %end;
27628     +
27629     +%mend;
27630     +
27631     +
27632     +
27633     +
27634     +
27635     +
27636     +
27637     +
27638     +
27639     +
27640     +
27641     +
27642     +
27643     +
27644     +
27645     +
27646     +
27647     +
27648     +
27649     +
27650     +
27651     +
27652     +
27653     +
27654     +
27655     +
27656     +
27657     +
27658     +
27659     +
27660     +
27661     +
27662     +
27663     +
27664     +
27665     +
27666     +
27667     +
27668     +
27669     +
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TMC_DOC_SCORE):   filename temp;
NOTE: Fileref TEMP을(를) 삭제했습니다.
MPRINT(TM_GETHIERTERMS):   filename temp catalog 'sashelp.emtext.tmterm1.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMTERM1.SOURCE입니다.
27671     + %macro tmterm1( DSN_TPARS=
27672     +                        , DSN_CLUS=
27673     +                        , DSN_DESC=
27674     +                        , DSN_OUT=
27675     +                        , MIN_PROB=.5
27676     +                        , TOP_FREQ=20
27677     +                        , N_DESC_TERMS=5
27678     +                        , key=
27679     +                        , threads=THREADS
27680     +                        , N_CLUS=
27681     +                        , MIN_NUM=0
27682     +                        ) ;
27684     +   /* PURPOSE: compute &TOP_FREQ terms which represent
27685     +      descriptive drivers of particular cluster
27686     +    *
27687     +    * NOTE:    &MIN_PROB represents minimum CDF probability at which
27688     +         term is included in cluster
27689     +    *          terms failing this criterion will be set to blank to
27690     +         indicate missingness
27691     +    *
27692     +    *          test is made after all terms have been ranked and sorted by
27693     +           descending CDF value
27694     +    *
27695     +    * NOTE:    &TOP_FREQ terms, ranked by frequency,
27696     +       will be selected from each cluster
27697     +    *
27698     +    * EXAMPLE OF USE:
27699     +    *    libname DATALIB '.' ;
27700     +    *
27701     +    *    *** use PROC TPARS   to create dataset DATALIB.TPARS_OUT ***
27702     +    *    *** use PROC CLUSTER to create dataset DATALIB.CLUS_OUT  ***
27703     +    *
27704     +    *    %CLUSTERTERMDRIVER( DSN_TPARS=DATALIB.TPARS_OUT
27705     +    *                      , DSN_CLUS=DATALIB.CLUS_OUT
27706     +    *                      , DSN_DESC=DATALIB.CLUS_DESC
27707     +    *                      , DSN_OUT=DATALIB.TOP_FREQ_OUT
27708     +    *                      , MIN_PROB=.75
27709     +    *                      , TOP_FREQ=10
27710     +    *                      )
27711     +    */
27713     +   /*#################################################################*/
27714     +   /* begin executable statements
27715     +   /*##################################################################*/
27717     +   %local combined termfreq summary uniqterm clus_cdf clus_cdf_transp;
27718     +   %local format dsid nobs rc CLUSALL;
27721     +   %if &SYSVER < 9 %then %let threads = ;
27723     +   %LET combined = _CMB&key;
27724     +   %LET termfreq = _TFREQ&key;
27725     +   %LET summary = _SUM&key;
27726     +   %LET uniqterm = _UNQT&key;
27727     +   %LET clus_cdf = _CLCDF&key;
27728     +   %LET clus_cdf_transp = _CLCDFTR&key;
27730     +   /*====================================================================*/
27731     +   /* create view which joins cluster # to document # so each term has
27732     +      a cluster # and a document #
27733     +      rename '_segmnt_' to 'cluster'  */
27734     +   /*=====================================================================*/
27736     +   proc sql &threads;
27737     +      create view &combined as
27738     +      select t1.*, t2._segmnt_ as cluster
27739     +      from &DSN_TPARS t1, &DSN_CLUS t2
27740     +      where t1._document_ = t2._document_ ;
27741     +   quit ;
27744     +   /*=====================================================================*/
27745     +   /* compute frequency of occurrence of term per term per cluster
27746     +   /*=====================================================================*/
27748     +   proc summary data=&combined nway ;
27749     +      class cluster _term_ ;
27750     +      var _count_ ;
27751     +      output out=&termfreq sum=total ;
27752     +   run ;
27754     +   /*=======================================================================*/
27755     +   /* compute # of documents per cluster
27756     +   /* create _type_ variable for later use (proc summary)
27757     +   /*
27758     +   /* create macro vars containing # of documents for each cluster, CLUSIZEn
27759     +   /* create macro var containing # of documents for document corpus, CLUSALL
27760     +   /*=======================================================================*/
27762     +   proc summary data=&combined( keep= cluster _document_ ) ;
27763     +      class cluster ;
27764     +      var _document_ ;
27765     +      output out=&summary n=n ;
27766     +   run ;
27768     +   /************* bug fix ***************************/
27769     +   /*
27770     +   proc sql noprint &threads;
27771     +      select left( put( max(cluster), best. )) into :_NCLUS_ from &summary ;
27772     +   quit ;
27773     +   */
27775     +   %LET CLUSALL = 0;
27776     +   %DO I = 1 %TO &N_CLUS;
27777     +     %LET CLUSIZE&I = 0;
27778     +   %END;
27779     +   /*
27780     +   data _null_ ; set &summary;
27781     +     if (_N_ = 1) then do;
27782     +       do _i_ = 1 to &_NCLUS_;
27783     +         call symput( 'CLUSIZE' || left( put(_i_, best. )), 0) ;
27784     +       end;
27785     +     end;
27786     +     stop;
27787     +   run ;
27788     +   */
27789     +   /**************************************************/
27791     + data _null_ ;
27792     +  set &summary ;
27793     +  if _type_ = 1 then call
27794     +   symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
27795     +  else
27796     +    if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
27797     + run ;
27799     +   proc sql &threads; drop table &summary; quit;
27801     +   /*====================================================================*/
27802     +   /* sort dataset of term frequencies per cluster into
27803     +      descending frequency per cluster */
27804     +   /*===================================================================*/
27805     +   %tmsort(data=&termfreq, out=&termfreq, by=cluster descending _freq_,
27806     +         options=, threads=&threads);
27808     +   /*======================================================================*/
27809     +   /* select top N most-frequent terms per cluster
27810     +   /*
27811     +   /* remove duplicate terms in list of top N terms from each cluster
27812     +   /*=======================================================================*/
27814     +   data &uniqterm( keep= _term_ _freq_ cluster ) ;
27815     +      set &termfreq ;
27816     +      by cluster ;
27818     +      if first.cluster then n_term = 0 ;
27820     +      n_term + 1 ;
27822     +      if n_term le &TOP_FREQ ;
27823     +   run ;
27825     +   %tmsort(data=&uniqterm, out=&uniqterm( keep= _term_ ), by=_term_,
27826     +         options=nodupkey, threads=&threads);
27828     +   /*=======================================================================*/
27829     +   /* create table containing cluster, term,
27830     +      frequency of term for unique terms only   */
27831     +   /*=======================================================================*/
27833     +   proc sql &threads;
27834     +      create table &clus_cdf as
27835     +      select distinct cluster, _term_, _freq_
27836     +      from &termfreq
27837     +      where _term_ in ( select _term_ from &uniqterm )
27838     +      order by _term_, cluster
27839     +      ;
27840     +   quit ;
27842     +   proc sql &threads; drop table &uniqterm;
27843     +             drop table &termfreq;
27844     +   quit;
27847     +   /*==================================================================*/
27848     +   /* transpose cluster/term/frequency into term/cluster table
27849     +   /* where the observation per term has frequency of term per cluster
27850     +   /*=================================================================*/
27852     +   proc transpose data=&clus_cdf out=&clus_cdf prefix=clus ;
27853     +      by _term_ ;
27854     +      var _freq_ ;
27855     +      id cluster;  /* bug fix */
27856     +   run ;
27858     +   /*=====================================================================*/
27859     +   /* compute cumulative binomial CDF of each term based on its
27860     +     cumulative probability of proportion (presence) in each cluster */
27861     +   /*======================================================================*/
27862     +   /*
27863     +   proc sql noprint &threads;
27864     +      select left( put( max( _segmnt_ ), best. )) into :N_CLUS from &DSN_CLUS ;
27865     +   quit ;
27866     +   */
27868     +   data &clus_cdf ;
27869     +   length _term_ $100;
27870     +      array a_clus ( &N_CLUS ) 4 clus1 - clus&N_CLUS ;
27872     +      set &clus_cdf ;
27874     +      do _i_ = 1 to &N_CLUS ;
27875     +         if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
27876     +      end ;
27879     +      sumfreq = sum( of clus1 - clus&N_CLUS ) ;
27881     +      %do I=1 %to &N_CLUS ;
27882     +        if (clus&I = 0) or (clus&I < &MIN_NUM) then cdf&I = 0;
27883     +        else do;
27884     +          num = sumfreq - clus&I ;
27885     +          div = &CLUSALL - &&CLUSIZE&I;
27886     +          if div > 0 then do;
27887     +            propor = num/div;
27888     +            cdf&I  = CDF( 'binomial', clus&I , propor ,&&CLUSIZE&I ) ;
27889     +          end;
27890     +          else if num = 0 then cdf&I = 1;
27891     +          else cdf&I = 0;
27892     +        end;
27893     +      %end ;
27894     +      /* peel off the plus then put it back*/
27895     +      saveplus=0;
27896     +      if kindex(kleft(ktrim(_term_)),'+')=1 then do;
27897     +         saveplus=1;
27898     +          _term_ = ksubstr(kleft(ktrim(_term_)),3);
27899     +      end;
27900     +      if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
27901     +      else _term_ = kleft(ktrim(_term_)) || ' ';
27902     +      if saveplus=1 then do;
27903     +         _term_='+'||kleft(ktrim(_term_));
27904     +      end;
27905     +      drop _i_ propor sumfreq div num saveplus;
27906     +   run ;
27909     +   /*====================================================================*/
27910     +   /* transpose dataset to create dataset sortable by cluster #
27911     +   /*===================================================================*/
27913     +   data &clus_cdf_transp ;
27914     +      array a_cdf  ( &N_CLUS ) cdf1 - cdf&N_CLUS ;
27915     +      array a_count  ( &N_CLUS ) clus1 - clus&N_CLUS ;
27916     +      length clus 4 ;
27917     +      set &clus_cdf ;
27918     +      keep _term_ cdf clus doc_count;
27919     +      do clus = 1 to &N_CLUS ;
27920     +         cdf = a_cdf( clus ) ;
27921     +         doc_count = a_count( clus ) ;
27922     +         if cdf > 0 then output ;
27923     +      end ;
27924     +   run ;
27927     +   /*====================================================================*/
27928     +   /* sort dataset by term, cumulative binomial CDF within term
27929     +   /* if two cdf values are =, sort by doc_count then by  _term_ alphabetically
27930     +   /*====================================================================*/
27932     +   proc sql &threads; drop table &clus_cdf; quit;
27935     +   %tmsort(data=&clus_cdf_transp, out=&clus_cdf_transp,
27936     +      by= clus descending cdf descending doc_count _term_, options=, threads=&threads);
27938     +   %LET format = %EVAL(30*&N_DESC_TERMS);
27939     +   %LET dsid = %sysfunc(open(&clus_cdf_transp));
27940     +   %LET nobs= %sysfunc(attrn(&dsid,nobs));
27941     +   %LET rc = %sysfunc(close(&dsid));
27943     +   data &DSN_DESC; set &clus_cdf_transp (rename=(clus=cluster));
27944     +   format clus_desc $&format..;
27945     +   retain oldclus 0 clus_desc '' count 0;
27946     +   keep _CLUSTER_ clus_desc ;
27948     +   if _N_ = 1 then do;
27949     +     oldclus = cluster;
27950     +     count = 1;
27951     +   end;
27953     +   if (count <= &N_DESC_TERMS) and (cluster = oldclus) then do;
27955     +     if (_N_ = 1) then clus_desc = left(trim(_term_));
27956     +     else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
27957     +     count = count + 1;
27958     +     if (_N_ = &nobs) then do;
27959     +       _CLUSTER_ = oldclus;
27960     +       clus_desc = left(trim(clus_desc));
27961     +       /* no longer comma to chop off*/
27962     +       /*clus_desc = substr(clus_desc, 1, max(length(clus_desc)-1,1));*/
27963     +       output;
27964     +     end;
27965     +     else delete;
27967     +   end;
27968     +   else if (count > &N_DESC_TERMS) and (cluster = oldclus) then do;
27969     +     if (_N_ = &nobs) then do;
27970     +       _CLUSTER_ = oldclus;
27971     +       clus_desc = left(trim(clus_desc));
27972     +       /* no longer comma to chop off*/
27973     +       /*clus_desc = substr(clus_desc, 1, max(length(clus_desc)-1,1));*/
27974     +       output;
27975     +     end;
27976     +     else delete;
27977     +   end;
27978     +   else do;
27979     +     _CLUSTER_ = oldclus;
27980     +     oldclus = cluster;
27981     +     clus_desc = left(trim(clus_desc));
27982     +     /* no longer comma to chop off*/
27983     +     /*clus_desc = substr(clus_desc, 1, max(length(clus_desc)-1,1));*/
27984     +     output;
27985     +     count = 2;
27986     +     clus_desc = left(trim(_term_));
27987     +     if (_N_ = &nobs) then do;
27988     +       _CLUSTER_ = oldclus;
27989     +       clus_desc = left(trim(clus_desc));
27990     +       /* no longer comma to chop off*/
27991     +       /*clus_desc = substr(clus_desc, 1, max(length(clus_desc)-1,1));*/
27992     +         output;
27993     +     end;
27994     +   end;
27995     +    run;
27997     +   /* delete data sets */
27999     +   proc sql &threads;
28000     +       drop table &clus_cdf_transp;
28001     +       drop view &combined;
28002     +   quit;
28005     +%mend tmterm1 ;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_GETHIERTERMS):   filename temp catalog 'sashelp.emtext.tmsort.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMSORT.SOURCE입니다.
28006     + /*
28007     +PROC SORT macro
28008     +
28009     +%tmsort(data=, out=, by=);
28010     +
28011     +data=      - name of input data set (outtree data set from PROC CLUSTER)
28012     +out=       - name of the output data set
28013     +by=        - by statement
28014     +options=   - proc options
28015     +*/
28016     +
28017     +%macro tmsort(data=, out=, by=, options=, threads=THREADS);
28018     +  %if %BQUOTE(&out) ^= %then %let out = out =  &out;
28019     +  %if &SYSVER < 9 %then %let threads = ;
28020     +
28021     +  proc sort data = %STR(&data) &threads &options
28022     +    &out;
28023     +    by &by;
28024     +  run;
28025     +
28026     +%mend tmsort;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_GETHIERTERMS):   filename temp;
NOTE: Fileref TEMP을(를) 삭제했습니다.
MPRINT(TM_GETHIERTERMS):   data _terms_;
MPRINT(TM_GETHIERTERMS):   set EMWS5.TextFilter5_terms;
MPRINT(TM_GETHIERTERMS):   by key _ispar;
MPRINT(TM_GETHIERTERMS):   if first.key then output;
MPRINT(TM_GETHIERTERMS):   else;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 1376개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TERMS_DATA.에서 읽었습니다.
      WHERE KEEP='Y';
NOTE: 1377개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TERM_STRINGS.에서 읽었습니다.
NOTE: 1376개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TERMS.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 1376개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_GETHIERTERMS):   data _terms_;
MPRINT(TM_GETHIERTERMS):   set _terms_;
MPRINT(TM_GETHIERTERMS):   if _ispar='+' then Term=_ispar || ' ' || term;
MPRINT(TM_GETHIERTERMS):   run;
NOTE: 1376개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 1376개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = EMWS5.TextFilter5_tmout threads out = _tmout_;
MPRINT(TMSORT):   by _termnum_;
MPRINT(TMSORT):   run;
 
NOTE: 4155개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._TMOUT_은(는) 4155개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _tmout_;
MPRINT(TM_GETHIERTERMS):   merge _tmout_ (in=_A_) _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
MPRINT(TM_GETHIERTERMS):   by _termnum_;
MPRINT(TM_GETHIERTERMS):   if _A_;
MPRINT(TM_GETHIERTERMS):   run;
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 1376개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TMOUT_은(는) 4155개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   data EMWS5.TextCluster5_hierds;
MPRINT(TM_GETHIERTERMS):   set EMWS5.TextCluster5_hierds (drop=clus_desc);
MPRINT(TM_GETHIERTERMS):   length clus_desc $2000;
MPRINT(TM_GETHIERTERMS):   clus_desc="";
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   data _hierds;
MPRINT(TM_GETHIERTERMS):   set EMWS5.TextCluster5_hierds;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 WORK._HIERDS은(는) 32개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   select max(level) into :level from _hierds;
MPRINT(TM_GETHIERTERMS):   create table _ancestors as select _cluster_, parent, parent as ancestor, parent as newclus from _hierds;
NOTE: Table WORK._ANCESTORS created, with 32 rows and 4 columns.
 
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a.*, newclus from _hierds a, _ancestors b where a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 32 rows and 7 columns.
 
MPRINT(TM_GETHIERTERMS):   alter table _ancestors add tlevel int;
NOTE: Table WORK._ANCESTORS has been modified, with 5 columns.
MPRINT(TM_GETHIERTERMS):   update _ancestors set tlevel=(select level from EMWS5.TextCluster5_hierds a where a._cluster_=ancestor);
NOTE: 32 rows were updated in WORK._ANCESTORS.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster5_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 31 rows and 5 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 32 rows and 4 columns.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 32개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 31개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 60개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster5_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 29 rows and 5 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 32 rows and 4 columns.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;
 
WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 60개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 29개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 86개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster5_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 26 rows and 5 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 32 rows and 4 columns.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;
 
WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 86개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 26개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 108개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster5_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 22 rows and 5 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 32 rows and 4 columns.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;
 
WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 108개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 22개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 126개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster5_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 18 rows and 5 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 32 rows and 4 columns.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;
 
WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 126개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 18개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 138개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster5_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 12 rows and 5 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 32 rows and 4 columns.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;
 
WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 138개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 12개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 144개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster5_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 6 rows and 5 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 32 rows and 4 columns.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;
 
WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 144개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 6개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 146개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster5_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 2 rows and 5 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 32 rows and 4 columns.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;
 
WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 146개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 2개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 146개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster5_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 0 rows and 5 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 32 rows and 4 columns.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
 
 
MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;
 
WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 146개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 0개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 146개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   insert into _ancestors(_cluster_, ancestor, tlevel) select _cluster_, _cluster_, level from EMWS5.TextCluster5_hierds where freq ne .;
NOTE: 16 rows were inserted into WORK._ANCESTORS.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sort data=_ancestors;
MPRINT(TM_GETHIERTERMS):   by ancestor;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 162개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 162개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster5_hierds where level= 9;
NOTE: Table WORK._LEVEL created, with 2 rows and 1 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel= 9);
NOTE: 496 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.13 초
      cpu 시간            0.12 초
 
 
MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 2개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 33 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 194개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 3개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;
 
NOTE: 3개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;
 
NOTE: 194개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 194개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;
 
NOTE: 194개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 60개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;
 
NOTE: 60개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 7개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 53개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 64 rows and 3 columns.
 
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;
 
NOTE: 64개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 53개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 2 ) 4 clus1 - clus2 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 2 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus2 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 286 - 123;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 123 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 286 - 163;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 163 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;
 
NOTE: 53개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 53개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 2 ) cdf1 - cdf2 ;
MPRINT(TMTERM1):   array a_count ( 2 ) clus1 - clus2 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 2 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;
 
NOTE: 53개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 64개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;
 
NOTE: 64개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 64개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 64) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 64) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 64) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;
 
NOTE: 64개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 2개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster5_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 2 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster5_hierds where level=8;
NOTE: Table WORK._LEVEL created, with 4 rows and 1 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=8);
NOTE: 496 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
 
 
MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 4개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 174 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 646개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 5개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;
 
NOTE: 5개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;
 
NOTE: 646개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 646개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;
 
NOTE: 646개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 120개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;
 
NOTE: 120개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 29개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 91개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 175 rows and 3 columns.
 
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;
 
NOTE: 175개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 91개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 4 ) 4 clus1 - clus4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 4 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus4 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 1047 - 183;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 183 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 1047 - 307;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 307 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 1047 - 286;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 286 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 1047 - 271;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 271 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;
 
NOTE: 91개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 91개의 관측값과 10개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 4 ) cdf1 - cdf4 ;
MPRINT(TMTERM1):   array a_count ( 4 ) clus1 - clus4 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 4 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;
 
NOTE: 91개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 175개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;
 
NOTE: 175개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 175개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 175) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 175) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 175) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;
 
NOTE: 175개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 4개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster5_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 4 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster5_hierds where level=7;
NOTE: Table WORK._LEVEL created, with 6 rows and 1 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=7);
NOTE: 496 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 282 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1224개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 7개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;
 
NOTE: 7개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;
 
NOTE: 1224개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1224개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;
 
NOTE: 1224개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 180개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;
 
NOTE: 180개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 60개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 120개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 325 rows and 3 columns.
 
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;
 
NOTE: 325개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 120개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 6 ) 4 clus1 - clus6 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 6 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus6 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 2025 - 186;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 186 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 2025 - 469;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 469 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 2025 - 578;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 578 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 2025 - 249;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 249 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus5 = 0) or (clus5 < 0) then cdf5 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus5 ;
MPRINT(TMTERM1):   div = 2025 - 343;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf5 = CDF( 'binomial', clus5 , propor , 343 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf5 = 1;
MPRINT(TMTERM1):   else cdf5 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus6 = 0) or (clus6 < 0) then cdf6 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus6 ;
MPRINT(TMTERM1):   div = 2025 - 200;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf6 = CDF( 'binomial', clus6 , propor , 200 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf6 = 1;
MPRINT(TMTERM1):   else cdf6 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;
 
NOTE: 120개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 120개의 관측값과 14개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 6 ) cdf1 - cdf6 ;
MPRINT(TMTERM1):   array a_count ( 6 ) clus1 - clus6 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 6 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;
 
NOTE: 120개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 325개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;
 
NOTE: 325개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 325개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.06 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 325) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 325) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 325) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;
 
NOTE: 325개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster5_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 6 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster5_hierds where level=6;
NOTE: Table WORK._LEVEL created, with 6 rows and 1 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=6);
NOTE: 496 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 356 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1605개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 7개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;
 
NOTE: 7개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;
 
NOTE: 1605개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1605개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;
 
NOTE: 1605개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 180개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;
 
NOTE: 180개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 67개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 113개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 361 rows and 3 columns.
 
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;
 
NOTE: 361개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 113개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 6 ) 4 clus1 - clus6 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 6 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus6 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 2791 - 764;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 764 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 2791 - 268;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 268 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 2791 - 669;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 669 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 2791 - 592;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 592 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus5 = 0) or (clus5 < 0) then cdf5 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus5 ;
MPRINT(TMTERM1):   div = 2791 - 293;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf5 = CDF( 'binomial', clus5 , propor , 293 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf5 = 1;
MPRINT(TMTERM1):   else cdf5 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus6 = 0) or (clus6 < 0) then cdf6 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus6 ;
MPRINT(TMTERM1):   div = 2791 - 205;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf6 = CDF( 'binomial', clus6 , propor , 205 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf6 = 1;
MPRINT(TMTERM1):   else cdf6 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;
 
NOTE: 113개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 113개의 관측값과 14개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 6 ) cdf1 - cdf6 ;
MPRINT(TMTERM1):   array a_count ( 6 ) clus1 - clus6 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 6 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;
 
NOTE: 113개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 361개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;
 
NOTE: 361개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 361개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 361) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 361) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 361) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;
 
NOTE: 361개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster5_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 6 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster5_hierds where level=5;
NOTE: Table WORK._LEVEL created, with 4 rows and 1 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=5);
NOTE: 496 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
 
 
MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 4개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 389 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1612개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 5개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;
 
NOTE: 5개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;
 
NOTE: 1612개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1612개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;
 
NOTE: 1612개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 120개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;
 
NOTE: 120개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 40개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 80개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 231 rows and 3 columns.
 
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;
 
NOTE: 231개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 80개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 4 ) 4 clus1 - clus4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 4 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus4 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 3108 - 1433;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 1433 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 3108 - 561;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 561 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 3108 - 797;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 797 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 3108 - 317;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 317 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;
 
NOTE: 80개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 80개의 관측값과 10개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 4 ) cdf1 - cdf4 ;
MPRINT(TMTERM1):   array a_count ( 4 ) clus1 - clus4 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 4 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;
 
NOTE: 80개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 231개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;
 
NOTE: 231개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 231개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 231) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 231) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 231) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;
 
NOTE: 231개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 4개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster5_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 4 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster5_hierds where level=4;
NOTE: Table WORK._LEVEL created, with 4 rows and 1 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=4);
NOTE: 496 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 4개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
SAS 시스템
 
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 468 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1827개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 5개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;
 
NOTE: 5개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;
 
NOTE: 1827개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1827개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.06 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;
 
NOTE: 1827개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 120개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;
 
NOTE: 120개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 42개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 78개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 225 rows and 3 columns.
 
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;
 
NOTE: 225개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 78개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 4 ) 4 clus1 - clus4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 4 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus4 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 3845 - 1358;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 1358 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 3845 - 1750;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 1750 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 3845 - 409;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 409 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 3845 - 328;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 328 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;
 
NOTE: 78개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 78개의 관측값과 10개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 4 ) cdf1 - cdf4 ;
MPRINT(TMTERM1):   array a_count ( 4 ) clus1 - clus4 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 4 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;
 
NOTE: 78개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 225개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;
 
NOTE: 225개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 225개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 225) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 225) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 225) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;
 
NOTE: 225개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 4개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster5_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 4 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster5_hierds where level=3;
NOTE: Table WORK._LEVEL created, with 3 rows and 1 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=3);
NOTE: 496 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.06 초
 
 
MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 3개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 3개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 496 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1735개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 4개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;
 
NOTE: 1735개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1735개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;
 
NOTE: 1735개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 90개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;
 
NOTE: 90개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 23개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 67개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 171 rows and 3 columns.
 
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;
 
NOTE: 171개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 67개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 3 ) 4 clus1 - clus3 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 3 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus3 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 4155 - 3108;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 3108 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 4155 - 737;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 737 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 4155 - 310;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 310 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;
 
NOTE: 67개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 67개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 3 ) cdf1 - cdf3 ;
MPRINT(TMTERM1):   array a_count ( 3 ) clus1 - clus3 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 3 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;
 
NOTE: 67개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 171개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;
 
NOTE: 171개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 171개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 171) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 171) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 171) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;
 
NOTE: 171개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 3개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 3개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 3개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster5_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 3 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster5_hierds where level=2;
NOTE: Table WORK._LEVEL created, with 2 rows and 1 columns.
 
MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=2);
NOTE: 496 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 2개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 496 rows were updated in WORK._DOCS_.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 496개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1593개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;
 
NOTE: 4155개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 496개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 4155개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 3개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;
 
NOTE: 3개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;
 
NOTE: 1593개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1593개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;
 
NOTE: 1593개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 60개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;
 
NOTE: 60개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 14개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 46개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 84 rows and 3 columns.
 
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;
 
NOTE: 84개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 46개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 2 ) 4 clus1 - clus2 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 2 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus2 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 4155 - 3418;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 3418 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 4155 - 737;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 737 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;
 
NOTE: 46개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 46개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
 
 
MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 2 ) cdf1 - cdf2 ;
MPRINT(TMTERM1):   array a_count ( 2 ) clus1 - clus2 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 2 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;
 
NOTE: 46개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 84개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;
 
NOTE: 84개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 84개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.00 초
 
 
MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 84) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 84) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 84) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;
 
NOTE: 84개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;
 
NOTE: 2개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster5_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 2 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster5_clusters as select a.clus_desc, b.* from EMWS5.TextCluster5_hierds a, EMWS5.TextCluster5_clusters b where a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 clus_desc이(가) 파일 EMWS5.TEXTCLUSTER5_CLUSTERS에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER5_CLUSTERS created, with 16 rows and 49 columns.
 
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster5_hierds set freq=0 where clus_desc="" and _cluster_ ne 1;
NOTE: No rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   data _hd;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster5_hierds;
MPRINT(TMC_DOC_SCORE):   cluster=_cluster_;
MPRINT(TMC_DOC_SCORE):   drop _cluster_ parent;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 WORK._HD은(는) 32개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 5 rows were updated in WORK._HD.
 
MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster5_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 4 rows were updated in WORK._HD.
 
MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster5_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 2 rows were updated in WORK._HD.
 
MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster5_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.04 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.
 
MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster5_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.
 
MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster5_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.
 
MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster5_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.
 
MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster5_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster5_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster5_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.
 
MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster5_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 32 rows were updated in EMWS5.TEXTCLUSTER5_HIERDS.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
 
 
MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster5_hierds(drop=plus pos sub);
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster5_hierds;
MPRINT(TMC_DOC_SCORE):   plus='';
MPRINT(TMC_DOC_SCORE):   if substr(CLUS_DESC, 1, 1) = "+" then plus="+ ";
MPRINT(TMC_DOC_SCORE):   if ktrim(clus_desc) ne "" then do;
MPRINT(TMC_DOC_SCORE):   if(substr(CLUS_DESC, 1, 1)) = "'" then do;
MPRINT(TMC_DOC_SCORE):   pos = findc(CLUS_DESC, "'",2);
MPRINT(TMC_DOC_SCORE):   sub = substr(CLUS_DESC,1,pos);
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   else sub = scan(CLUS_DESC, 1);
MPRINT(TMC_DOC_SCORE):   graphdesc=_CLUSTER_ || ': ' || plus || sub;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   else graphdesc=_CLUSTER_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      95:199   97:29
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sort data=_docdata (rename=(cluster=_cluster_));
MPRINT(TMC_DOC_SCORE):   by _cluster_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCDATA은(는) 496개의 관측값과 47개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   data _rmscalc;
MPRINT(TMC_DOC_SCORE):   merge _docdata(in=inhere) EMWS5.TextCluster5_clusters;
MPRINT(TMC_DOC_SCORE):   array _means(45) _mean1-_mean45;
MPRINT(TMC_DOC_SCORE):   array _svds(45) TextCluster5_SVD1 - TextCluster5_SVD45;
MPRINT(TMC_DOC_SCORE):   by _cluster_;
MPRINT(TMC_DOC_SCORE):   error=0;
MPRINT(TMC_DOC_SCORE):   do i = 1 to 45;
MPRINT(TMC_DOC_SCORE):   error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   drop i ;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 16개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 WORK._RMSCALC은(는) 496개의 관측값과 96개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(TMC_DOC_SCORE):   proc summary data=_rmscalc nway;
MPRINT(TMC_DOC_SCORE):   class _cluster_;
MPRINT(TMC_DOC_SCORE):   var error;
MPRINT(TMC_DOC_SCORE):   output out=_meanerr mean=meane sum=sume;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 496개의 관측값을 데이터셋 WORK._RMSCALC.에서 읽었습니다.
NOTE: 데이터셋 WORK._MEANERR은(는) 16개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   data _rmsse;
MPRINT(TMC_DOC_SCORE):   set _meanerr;
MPRINT(TMC_DOC_SCORE):   if _freq_ gt 1 then do;
MPRINT(TMC_DOC_SCORE):   _rmsstd_=sqrt(sume/((_freq_-1)*(45)));
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   else do;
MPRINT(TMC_DOC_SCORE):   _rmsstd_=0;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   keep _cluster_ _rmsstd_;
MPRINT(TMC_DOC_SCORE):   run;
 
NOTE: 16개의 관측값을 데이터셋 WORK._MEANERR.에서 읽었습니다.
NOTE: 데이터셋 WORK._RMSSE은(는) 16개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table _clusstat2 as select a.*,b.* from EMWS5.TextCluster5_clusters a left join _rmsse b on a._cluster_=b._cluster_;
WARNING: 변수 _cluster_이(가) 파일 WORK._CLUSSTAT2에 이미 존재합니다.
NOTE: Table WORK._CLUSSTAT2 created, with 16 rows and 50 columns.
 
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster5_clusters as select * from _clusstat2;
NOTE: Table EMWS5.TEXTCLUSTER5_CLUSTERS created, with 16 rows and 50 columns.
 
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
 
 
MPRINT(TMC_SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):   * path of the diagram ;
MPRINT(SCORE):   data _null_;
MPRINT(SCORE):   call symput("emwspath", strip(pathname("EMWS5")));
MPRINT(SCORE):   run;
 
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(SCORE):   filename pre "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\PRESCORECODE.sas";
MPRINT(SCORE):   data _null_;
MPRINT(SCORE):   file pre;
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmemclus.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmpred.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtxtext.tmc_doc_score.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmsort.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmsvd.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmfast.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp;';
MPRINT(SCORE):   run;
 
NOTE: 파일 PRE:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\PRESCORECODE.sas,
      RECFM=V,LRECL=32767,파일 크기 (바이트)=0,
      마지막 수정일=2018년 11월 28일 18시15분05초,
      생성 시간=2018년 11월 28일 18시15분05초
 
NOTE: 13개의 레코드를 파일 PRE에 기록했습니다.
      최소 레코드 길이는 14입니다.
      최대 레코드 길이는 62입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(SCORE):   filename tmpre "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextFilter5\PRESCORECODE.sas";
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file pre MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("tmpre",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
 
NOTE: 파일 PRE:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\PRESCORECODE.sas,
      RECFM=V,LRECL=20000,파일 크기 (바이트)=452,
      마지막 수정일=2018년 11월 28일 18시15분05초,
      생성 시간=2018년 11월 28일 18시15분05초
 
NOTE: 23개의 레코드를 파일 PRE에 기록했습니다.
      최소 레코드 길이는 1입니다.
      최대 레코드 길이는 81입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
 
 
MPRINT(SCORE):  ;
MPRINT(SCORE):   filename tmpre;
NOTE: Fileref TMPRE을(를) 삭제했습니다.
MPRINT(SCORE):   data _codeclusters;
MPRINT(SCORE):   set EMWS5.TextCluster5_clusters (drop=clus_desc);
MPRINT(SCORE):   run;
 
NOTE: 16개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 WORK._CODECLUSTERS은(는) 16개의 관측값과 49개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(SCORE):   libname termloc "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5";
NOTE: 라이브러리 참조 TERMLOC은(는) EMWS5과(와) 같은 물리적 라이브러리를 참조합니다.
NOTE: 라이브러리 참조 'TERMLOC'이(가) 다음과 같이 할당되었습니다.
      엔진:        V9
      물리적 경로: C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5
MPRINT(SCORE):   * Now save code, if necessary, for search phrase;
MPRINT(SCORE):   filename _tmscore "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMPUBLISHSCORE.sas";
MPRINT(SCORE):   data _NULL_;
MPRINT(SCORE):   file _tmscore;
MPRINT(SCORE):   string= '%'||"tmc_doc_score(import="||'&em_score_output'||",export=work._newexport,";
MPRINT(SCORE):   put string;
MPRINT(SCORE):   put "      termds=termloc.TextFilter5_filtterms,configds=termloc.TextCluster5_tmconfig,";
MPRINT(SCORE):   put "      clusters=termloc.TextCluster5_clusters, ";
MPRINT(SCORE):   put "      _scrout=work.TextFilter5_out, svd_u=termloc.TextCluster5_svd_u, svd_s=termloc.TextCluster5_svd_s, prefix=TextCluster5);";
MPRINT(SCORE):   put 'data &em_score_output; set work._newexport;';
MPRINT(SCORE):   run;
 
NOTE: 파일 _TMSCORE:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMPUBLISHSCORE.sas,
      RECFM=V,LRECL=32767,파일 크기 (바이트)=0,
      마지막 수정일=2018년 11월 28일 18시15분05초,
      생성 시간=2018년 11월 28일 18시15분05초
 
NOTE: 5개의 레코드를 파일 _TMSCORE에 기록했습니다.
      최소 레코드 길이는 43입니다.
      최대 레코드 길이는 125입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(SCORE):   filename _tmscore;
NOTE: Fileref _TMSCORE을(를) 삭제했습니다.
MPRINT(SCORE):   filename temp;
WARNING: 파일 이름 TEMP이(가) 논리적으로 할당되지 않았습니다.
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End SCORE: TextCluster5;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
28027      *------------------------------------------------------------*;
28028      * End SCORE: TextCluster5;
28029      *------------------------------------------------------------*;
 
28031      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
28032      * TextCluster5: Computing metadata for TRAIN data;
MPRINT(EM_DIAGRAM):   * TextCluster5: Computing metadata for TRAIN data;
28033      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
 
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * &nodeid: Computing Metadata for TRAIN data;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   filename _delta "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\CDELTA_TRAIN.sas";
MPRINT(EMADVISECOLUMNS):   proc display c=sashelp.emmeta.advisecolumns.scl;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    options validvarname=any;
MPRINT(EMADVISECOLUMNS):   proc contents data=EMWS5.TextCluster5_TRAIN out=_tempAdvisor noprint;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):   options validvarname=V7;
MPRINT(EMADVISECOLUMNS):    data _null_;
MPRINT(EMADVISECOLUMNS):   dsid = open('EMWS5.TextCluster5_TRAIN');
MPRINT(EMADVISECOLUMNS):   call symput('_dsidTable', strip(put(dsid, best.)));
MPRINT(EMADVISECOLUMNS):   if dsid then do;
MPRINT(EMADVISECOLUMNS):   call symput('_engineTable', attrc(dsid, 'ENGINE'));
MPRINT(EMADVISECOLUMNS):   dsid = close(dsid);
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    options fmterr;
MPRINT(EMADVISECOLUMNS):   data _metaTestView;
MPRINT(EMADVISECOLUMNS):   set EMWS5.TextCluster5_TRAIN;
MPRINT(EMADVISECOLUMNS):   if _N_=1 then do;
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   stop;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    proc contents data=EMWS5.TextCluster5_TRAIN out=WORK.M01WU0W7 noprint;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M01WU0W7;
MPRINT(EMADVISECOLUMNS):   length NAME $ 64 TYPE $ 1 LABEL $ 200 FORMAT $ 36 INFORMAT $36 INDEX $ 1 INDEXTYPE $ 9;
MPRINT(EMADVISECOLUMNS):   label NAME =;
MPRINT(EMADVISECOLUMNS):   set WORK.M01WU0W7(keep=name type length label format formatl formatd informat informl informd idxusage rename=(type=itype));
MPRINT(EMADVISECOLUMNS):   if itype = 1 then type = 'N';
MPRINT(EMADVISECOLUMNS):   else type = 'C';
MPRINT(EMADVISECOLUMNS):   if formatl > 0 then do;
MPRINT(EMADVISECOLUMNS):   if format ne '' then do;
MPRINT(EMADVISECOLUMNS):   if type='N' then format = strip(format)!!strip(put(formatl, best12.))!!'.'!!strip(put(formatd, best12.));
MPRINT(EMADVISECOLUMNS):   else format = strip(format)!!strip(put(formatl, best12.))!!'.';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else format = strip(put(formatl, best12.))!!'.'!!strip(put(formatd, best12.));
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if format ne '' then format = strip(format)!!'.';
MPRINT(EMADVISECOLUMNS):   if informl > 0 then do;
MPRINT(EMADVISECOLUMNS):   if informat ne ' ' then do;
MPRINT(EMADVISECOLUMNS):   if type='N' then informat = strip(informat)!!strip(put(informl, best12.))!!'.'!!strip(put(informd, best12.));
MPRINT(EMADVISECOLUMNS):   else informat = strip(informat)!!strip(put(informl, best12.))!!'.';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else informat = strip(put(informl, best12.))!!'.'!!strip(put(informd, best12.));
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if informat ne '' then informat = strip(informat)!!'.';
MPRINT(EMADVISECOLUMNS):   if idxusage = 'NONE' then index ="N";
MPRINT(EMADVISECOLUMNS):   else index = "Y";
MPRINT(EMADVISECOLUMNS):   indextype = idxusage;
MPRINT(EMADVISECOLUMNS):   drop idxusage itype formatl formatd informl informd;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M01WU0W7;
MPRINT(EMADVISECOLUMNS):   length UNAME $64;
MPRINT(EMADVISECOLUMNS):   set WORK.M01WU0W7;
MPRINT(EMADVISECOLUMNS):   UNAME = upcase(NAME);
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    proc sort data=WORK.M0QT1WA1 NOTHREADS;
MPRINT(EMADVISECOLUMNS):   by UNAME;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M0QT1WA1;
MPRINT(EMADVISECOLUMNS):   drop UNAME;
MPRINT(EMADVISECOLUMNS):   set WORK.M0QT1WA1;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M28CEPU2(keep=NAME ATTR);
MPRINT(EMADVISECOLUMNS):   length ATTR $ 20;
MPRINT(EMADVISECOLUMNS):   set WORK.M0QT1WA1;
MPRINT(EMADVISECOLUMNS):   if level ne "INTERVAL" then do;
MPRINT(EMADVISECOLUMNS):   if order = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'ORDER';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if format ne ' ' and formattype = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'FORMATTYPE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'ROLE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if level = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'LEVEL';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if type = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'TYPE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if index = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'INDEX';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if report = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'REPORT';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):   proc sort NOTHREADS;
MPRINT(EMADVISECOLUMNS):   by attr;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M0QT1WA1;
MPRINT(EMADVISECOLUMNS):   length NAME $64 ROLE $ 32 LEVEL $ 10 ORDER $ 8 CREATOR $32 FORMATTYPE $ 10 FAMILY $ 10 LOWERLIMIT 8 UPPERLIMIT 8 REPORT $1 DISTRIBUTION $ 20 COMMENT $64;
MPRINT(EMADVISECOLUMNS):   length levelAssigned 8 roleAssigned 8 PRICE 8;
MPRINT(EMADVISECOLUMNS):   set WORK.M0QT1WA1;
MPRINT(EMADVISECOLUMNS):   if formattype = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if format ne ' ' then do;
MPRINT(EMADVISECOLUMNS):   if type = 'N' then do;
MPRINT(EMADVISECOLUMNS):   pos = indexc(format,'.1234567890');
MPRINT(EMADVISECOLUMNS):   if pos > 1 then tempfmt = substr(format,1, pos-1);
MPRINT(EMADVISECOLUMNS):   else tempfmt = ' ';
MPRINT(EMADVISECOLUMNS):   flen = length(tempfmt);
MPRINT(EMADVISECOLUMNS):   select;
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("DATE" "DAY" "DDMMYY" "DOWNAME" "JULDAY" "JULIAN" "MMDDYY" "MMDDYYD" "MMDDYYC" "MMDDYYN" "MMDDYYP" "MMDDYYS" "MONNAME" "MONTH" "MONYY" "NENGO" "QTR" "QTRR" "WEEKDATE" "WEEKDATX" "WEEKDAY" "WORDDATE" "WORDDATX"
"YEAR" "YYMMDD" "YYMON" "YYMMDDC" "YYMMDDD" "YYMMDDN" "YYMMDDP" "YYMMDDS" "EURDFDE" "NJDATE" "NLDATE" "EURDFDD" "EURDFDWN" "EURDFMN" "EURDFMY" "EURDFWK" "EURDFWKX" "EURDFWDX" "EURDFDN" "EURDFDE" )) formattype = 'DATE';
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("DATETIME" "EURDFDT" "TOD" )) formattype = "DATETIME";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("HHMM" "HOUR" "MMSS" "TIME" "TIMEAMPM" )) formattype = "TIME";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("COMMA" "COMMAX" "DOLLAR" "DOLLARX" "E" "FRACT" "NEGPAREN" "PERCENT")) formattype="QUANTITY";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("BINARY" "HEX" "IB" "OCTAL" "PD" "PIB" "PK" "RB" "SSN" "Z" "ZD")) formattype = "CODING";
MPRINT(EMADVISECOLUMNS):   otherwise do;
MPRINT(EMADVISECOLUMNS):   formattype = "USER";
MPRINT(EMADVISECOLUMNS):   if compress(tempfmt, '0123456789.', '') = '' then formattype='NUM';
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 6)='NLDATE' then formattype = "DATE";
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 6)='NLDATM' then formattype = "DATETIME";
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 4)='NLTIM' then formattype = "TIME";
MPRINT(EMADVISECOLUMNS):   else if flen >= 4 then do;
MPRINT(EMADVISECOLUMNS):   str = substr(tempfmt,1,4);
MPRINT(EMADVISECOLUMNS):   if str in ("MMYY" "YYMM" "YYQR") then formattype ="DATE";
MPRINT(EMADVISECOLUMNS):   else if str = "S370" then formattype = "CODING";
MPRINT(EMADVISECOLUMNS):   else if str = "BEST" then formattype = "NUM";
MPRINT(EMADVISECOLUMNS):   drop str;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if flen >=3 and substr(tempfmt,1,3) = "YYQ" then formatType = "DATE";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   drop flen tempfmt pos;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   formatType = "CATEGORY";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if formatType = "NUM" then do;
MPRINT(EMADVISECOLUMNS):   if index = "Y" then formatType = "DISCRETE";
MPRINT(EMADVISECOLUMNS):   else formatType = "QUANTITY";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if level = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if formatType in ("CATEGORY", "CODING", "ID") or type = "C" then level = "NOMINAL";
MPRINT(EMADVISECOLUMNS):   else level = "INTERVAL";
MPRINT(EMADVISECOLUMNS):   levelAssigned = 1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else level = upcase(level);
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   length name_prefix $8 _uname $64;
MPRINT(EMADVISECOLUMNS):   drop name_prefix _uname _freqflag;
MPRINT(EMADVISECOLUMNS):   retain _freqflag;
MPRINT(EMADVISECOLUMNS):   if LENGTH> 80 then ROLE = 'TEXT';
MPRINT(EMADVISECOLUMNS):   _uname = upcase(NAME);
MPRINT(EMADVISECOLUMNS):   select(_uname);
MPRINT(EMADVISECOLUMNS):   when('_PARTIND_') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'ID';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('_WARN_') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_SEGMENT') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('_NODE_') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('EM_CLASSTARGET') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_VALUETARGET') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_PREDICTION') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_PROBABILITY') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_EVENTPROBABILITY') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_CLASSIFICATION') ROLE = 'CLASSIFICATION';
MPRINT(EMADVISECOLUMNS):   when('EM_DECISION') ROLE = 'DECISION';
MPRINT(EMADVISECOLUMNS):   when('EM_PROFIT') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_LOSS') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_ROI') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('URI') ROLE = 'URL';
MPRINT(EMADVISECOLUMNS):   when('FILTERED') ROLE = 'TEXTLOC';
MPRINT(EMADVISECOLUMNS):   otherwise do;
MPRINT(EMADVISECOLUMNS):   if upcase(NAME) =: 'ZIP' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'REJECTED';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   COMMENT = 'Rejected by: Exceed the maximum class level of %s';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if upcase(NAME) in('FREQ', 'FREQUENCY') then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'FREQ';
MPRINT(EMADVISECOLUMNS):   if TYPE = 'C' then ROLE = 'INPUT';
MPRINT(EMADVISECOLUMNS):   else if _freqflag =1 then ROLE='REJECTED';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   name_prefix = scan(_uname, 1, '_');
MPRINT(EMADVISECOLUMNS):   if scan(_uname, 2, '_') = '' then name_prefix='';
MPRINT(EMADVISECOLUMNS):   if name_prefix in('F', 'I', 'U') then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'CLASSIFICATION';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('Q') then ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('P', 'V') then ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('R', 'RS', 'RT', 'RD', 'RDS', 'RDT', 'RA', 'RAS', 'RAT') then ROLE = 'RESIDUAL';
MPRINT(EMADVISECOLUMNS):   else if name_prefix ='D' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'DECISION';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix ='B' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('EP', 'BP', 'CP', 'EL', 'CL', 'BL', 'W', 'ROI', 'IC') then ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   array _ROLE_ (19) $32 _TEMPORARY_ ('ASSESS','CLASSIFICATION','CENSOR', 'COST', 'CROSSID', 'DECISION', 'ID','INPUT', 'LABEL', 'MISSING','PREDICT','REFERRER','REJECTED', 'RESIDUAL','SEGMENT', 'SEQUENCE','TARGET', 'TEXT', 'TIMEID');
MPRINT(EMADVISECOLUMNS):   drop _found_ i;
MPRINT(EMADVISECOLUMNS):   _found_=0;
MPRINT(EMADVISECOLUMNS):   do i=1 to 19 until(_found_=1);
MPRINT(EMADVISECOLUMNS):   if index(_uname, trim(_ROLE_{i}))=1 then do;
MPRINT(EMADVISECOLUMNS):   ROLE=_ROLE_{i};
MPRINT(EMADVISECOLUMNS):   if ROLE = 'ID' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'SEGMENT' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'TIMEID' and TYPE='N' then LEVEL = 'INTERVAL';
MPRINT(EMADVISECOLUMNS):   _found_=1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if length(_uname)>2 then do;
MPRINT(EMADVISECOLUMNS):   if substr(reverse(trim(_uname)), 1, 3) = 'DI_' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'ID';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if ROLE='FREQ' then _freqflag=1;
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'CLASSIFICATION' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   if symexist('RATEMKG_ROLE') then do;
MPRINT(EMADVISECOLUMNS):   if upcase(symget('RATEMKG_ROLE')) in('Y', 'YES') then do;
MPRINT(EMADVISECOLUMNS):   if _uname =: 'POLICY' then ROLE = 'POLICYID';
MPRINT(EMADVISECOLUMNS):   else if _uname in ('PARTITION', '_PARTIND_') then ROLE = 'PARTITION';
MPRINT(EMADVISECOLUMNS):   else if type = 'N' then do;
MPRINT(EMADVISECOLUMNS):   if _uname = 'EXPOSURE' then ROLE = 'EXPOSURE';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'YEAR' then ROLE = 'YEAR';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'WEIGHT' then ROLE = 'WEIGHT';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'OFFSET' then ROLE = 'OFFSET';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if formattype in('DATE', 'DATETIME', 'TIME') then role = 'TIMEID';
MPRINT(EMADVISECOLUMNS):   else role = 'INPUT';
MPRINT(EMADVISECOLUMNS):   roleAssigned = 1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else role = upcase(role);
MPRINT(EMADVISECOLUMNS):   if REPORT = '' then REPORT = 'N';
MPRINT(EMADVISECOLUMNS):   if symexist('dmwb_product') then do;
MPRINT(EMADVISECOLUMNS):   if upcase(symget('dmwb_product')) = 'FACTORYMINER_DATASOURCE' then do;
MPRINT(EMADVISECOLUMNS):   if ROLE ^in('INPUT', 'TARGET', 'REJECTED', 'SEGMENT', 'FREQ', 'ID', 'KEY') then ROLE='REJECTED';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M0QT1WA1;
MPRINT(EMADVISECOLUMNS):   set WORK.M0QT1WA1;
MPRINT(EMADVISECOLUMNS):   label NAME = "변수 이름" TYPE = "유형" ROLE = "역할" LEVEL= "측도 레벨" ORDER= "순서" CREATOR= "생성자" FORMATTYPE= "출력형식 유형" FAMILY= "군" DISTRIBUTION= "분포" PRICE= "가격" LOWERLIMIT= "하한" UPPERLIMIT= "상한" REPORT=
"리 포트" COMMENT= "주석" INDEX= "인덱스" INDEXTYPE= "인덱스 유형" LABEL= "레이블" LENGTH= "길이";
MPRINT(EMADVISECOLUMNS):   drop levelAssigned roleAssigned;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   proc sort data=WORK.COLUMNMETA;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * &nodeid: Merge incoming metadata;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   proc contents data=EMWS5.TextFilter5_TRAIN noprint out=_temp2(keep=NAME);
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc sort data=_temp2;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc sort data=EMWS5.TextFilter5_CMeta_TRAIN out=_temp;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data EMWS5.TextCluster5_CMeta_TRAIN;
MPRINT(EM_DIAGRAM):   merge WORK.COLUMNMETA(in=_a) _temp2(in=_b) _temp(drop=FORMAT INFORMAT LENGTH INDEX INDEXTYPE in=_c) end=_eof_;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   if (^_a and _b) or (^_c and _a and _b) then delete;
MPRINT(EM_DIAGRAM):   if ^_b then CREATOR = "TextCluster5";
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextCluster5: Apply Delta Code;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   if upcase(NAME) = "TEXTCLUSTER5_CLUSTER_" then do;
MPRINT(EM_DIAGRAM):   ROLE = "SEGMENT";
MPRINT(EM_DIAGRAM):   LEVEL = "NOMINAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB1" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB10" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB11" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB12" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB13" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB14" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB15" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB16" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB2" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB3" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB4" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB5" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB6" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB7" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB8" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_PROB9" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD1" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD10" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD11" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD12" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD13" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD14" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD15" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD16" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD17" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD18" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD19" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD2" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD20" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD21" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD22" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD23" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD24" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD25" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD26" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD27" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD28" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD29" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD3" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD30" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD31" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD32" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD33" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD34" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD35" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD36" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD37" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD38" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD39" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD4" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD40" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD41" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD42" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD43" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD44" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD45" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD5" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD6" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD7" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD8" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER5_SVD9" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _delta;
28672      proc sort data = EMWS5.TextFilter5_EMINFO OUT=WORK.SORTEDEMINFO NOTHREADS;
MPRINT(EM_DIAGRAM):    proc sort data = EMWS5.TextFilter5_EMINFO OUT=WORK.SORTEDEMINFO NOTHREADS;
28673      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
28674      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 6개의 관측값을 데이터셋 EMWS5.TEXTFILTER5_EMINFO.에서 읽었습니다.
NOTE: 데이터셋 WORK.SORTEDEMINFO은(는) 6개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
28675      proc sort data = EMWS5.TextCluster5_EMINFO OUT=WORK.TEMP_INFO NOTHREADS;
MPRINT(EM_DIAGRAM):   proc sort data = EMWS5.TextCluster5_EMINFO OUT=WORK.TEMP_INFO NOTHREADS;
28676      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
28677      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 4개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_EMINFO.에서 읽었습니다.
NOTE: 데이터셋 WORK.TEMP_INFO은(는) 4개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
28678      data EMWS5.TextCluster5_EMINFO;
MPRINT(EM_DIAGRAM):   data EMWS5.TextCluster5_EMINFO;
28679      merge WORK.SORTEDEMINFO WORK.TEMP_INFO;
MPRINT(EM_DIAGRAM):   merge WORK.SORTEDEMINFO WORK.TEMP_INFO;
28680      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
28681      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 6개의 관측값을 데이터셋 WORK.SORTEDEMINFO.에서 읽었습니다.
NOTE: 4개의 관측값을 데이터셋 WORK.TEMP_INFO.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_EMINFO은(는) 7개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
28682      proc datasets lib=work nolist;
MPRINT(EM_DIAGRAM):   proc datasets lib=work nolist;
28683      delete TEMP_INFO SORTEDEMINFO;
MPRINT(EM_DIAGRAM):   delete TEMP_INFO SORTEDEMINFO;
28684      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: WORK.TEMP_INFO(memtype=DATA)을(를) 삭제하는 중입니다.
NOTE: WORK.SORTEDEMINFO(memtype=DATA)을(를) 삭제하는 중입니다.
28685      quit;
MPRINT(EM_DIAGRAM):   quit;
 
NOTE: 프로시저 DATASETS 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
 
 
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 28일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "18시15분06초" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 리포트 로그";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* 리포트 로그
날짜:                2018년 11월 28일
시간:                18시15분06초
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O2SMSEAV "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster5\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O2SMSEAV new;
MPRINT(EM_DIAGRAM):   run;
28709      %let EMEXCEPTIONSTRING=;
28710      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
28711      * REPORT: TextCluster5;
MPRINT(EM_DIAGRAM):   * REPORT: TextCluster5;
28712      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
28713      %let EM_ACTION = REPORT;
28714      %let syscc = 0;
28715      %macro main();
28716
28717         %if %upcase(&EM_ACTION) eq CREATE %then %do;
28718            filename temp catalog 'sashelp.emtxtext.cluster_create.source';
28719            %include temp;
28720            %create();
28721         %end;
28722         %if %upcase(&EM_ACTION) eq TRAIN %then %do;
28723            filename temp catalog 'sashelp.emtxtext.cluster_train.source';
28724            %include temp;
28725            %train();
28726         %end;
28727         %if %upcase(&EM_ACTION) eq REPORT %then %do;
28728            filename temp catalog 'sashelp.emtxtext.cluster_report.source';
28729            %include temp;
28730            %report();
28731         %end;
28732         %if %upcase(&EM_ACTION) eq SCORE %then %do;
28733            filename temp catalog 'sashelp.emtxtext.cluster_score.source';
28734            %include temp;
28735            %score();
28736         %end;
28737      %mend main;
28738
28739      %main();
MPRINT(EM_DIAGRAM):
MPRINT(MAIN):   filename temp catalog 'sashelp.emtxtext.cluster_report.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.CLUSTER_REPORT.SOURCE입니다.
28740     +%macro report();
28741     +
28742     +    %EM_GETNAME(KEY=GRAPH_TABLE, TYPE=DATA);
28743     +    %EM_GETNAME(KEY=clusters, TYPE=DATA);
28744     +    %EM_GETNAME(KEY=prescorecode, type=file, extension=sas);
28745     +    %em_getname(key=svd_s, type=data);
28746     +    %em_getname(key=hierds, type=data);
28747     +
28748     +    proc sql noprint;
28749     +        select count(*) into :svdkeep
28750     +            from &em_user_svd_s
28751     +            where keep=1;
28752     +        select count(*) into :nclus
28753     +            from &em_user_clusters;
28754     +    quit;
28755     +    %let svdkeep=%left(&svdkeep);
28756     +    %let nclus=%left(&nclus);
28757     +    %let clusterid=%sysfunc(sasmsg(sashelp.tmine, rpt_text_clusterid_vlabel, NOQUOTE));
28758     +    %let frequency=%sysfunc(sasmsg(sashelp.tmine, rpt_text_frequency_vlabel, NOQUOTE));
28759     +    %let percentage=%sysfunc(sasmsg(sashelp.tmine, rpt_text_percentage_vlabel, NOQUOTE));
28760     +    %let descterms=%sysfunc(sasmsg(sashelp.tmine, rpt_text_descterms_vlabel, NOQUOTE));
28761     +    %let rmsstd=%sysfunc(sasmsg(sashelp.tmine, rpt_text_rmsstd_vlabel, NOQUOTE));
28762     +    %let coordinate=%sysfunc(sasmsg(sashelp.tmine, rpt_text_coordinate_vlabel, NOQUOTE));
28763     +    %let parent=%sysfunc(sasmsg(sashelp.tmine, rpt_text_parent_vlabel, NOQUOTE));
28764     +    %let hierlevel=%sysfunc(sasmsg(sashelp.tmine, rpt_text_hierlevel_vlabel, NOQUOTE));
28765     +    %let graphdesc=%sysfunc(sasmsg(sashelp.tmine, rpt_text_graphdesc_vlabel, NOQUOTE));
28766     +    %let descshort=%sysfunc(sasmsg(sashelp.tmine, rpt_text_descshort_vlabel, NOQUOTE));
28767     +
28768     +    data &em_user_graph_table;
28769     +        set &em_user_clusters;
28770     +        label _cluster_="&clusterid"
28771     +              clus_desc="&DescTerms"
28772     +              freq="&Frequency"
28773     +              percent="&Percentage"
28774     +              _rmsstd_="&rmsstd"
28775     +              %do i=1 %to &svdkeep;
28776     +                _mean&i="&Coordinate &i"
28777     +              %end;
28778     +              ;
28779     +        format percent percent10.;
28780     +        desc_short = clus_desc;
28781     +        if COUNTW(clus_desc, ' ') > 5 then do;
28782     +            call scan(clus_desc, 6, position, len, ' ');
28783     +            desc_short=substr(clus_desc, 1, position-1) || '...';
28784     +            drop position len;
28785     +            label desc_short="&descshort";
28786     +        end;
28787     +    run;
28788     +
28789     +    proc sql noprint;
28790     +        create table &em_user_graph_table as
28791     +        select _cluster_, clus_desc, freq, percent, *
28792     +        from &em_user_graph_table;
28793     +    quit;
28794     +
28795     +    %let block = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusters_title, NOQUOTE));
28796     +
28797     +    %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_prescore_title, NOQUOTE));
28798     +    %EM_REPORT(KEY=PRESCORECODE, VIEWTYPE=SOURCE, DESCRIPTION=%nrbquote(&desc),
28799     +              BLOCK=Scoring, AUTODISPLAY=N);
28800     +
28801     +    %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusfreqbyrms_title, NOQUOTE));
28802     +    %EM_REPORT(KEY=GRAPH_TABLE, VIEWTYPE=SCATTER, X=FREQ, Y=_RMSSTD_, DESCRIPTION=%nrbquote(&desc),
28803     +            BLOCK=%nrbquote(&block), AUTODISPLAY=Y, TIP=%if &em_property_nDescTerms > 5 %then desc_short; %else clus_desc;);
28804     +
28805     +    %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusters_title, NOQUOTE));
28806     +    %EM_REPORT(KEY=GRAPH_TABLE, VIEWTYPE=DATA, DESCRIPTION=%nrbquote(&desc), BLOCK=%nrbquote(&block), AUTODISPLAY=Y);
28807     +
28808     +    %if &nclus > 2 %then %do;
28809     +        data work.graph_table(drop=_cluster_);
28810     +            set &em_user_graph_table;
28811     +            cluster=put(_cluster_,best12.);
28812     +        run;
28813     +        proc distance data=work.graph_table out=work.graph_table method=EUCLID nostd;
28814     +            var RATIO(_mean1-_mean&svdkeep);
28815     +            id cluster;
28816     +        run;
28817     +        proc mds data=work.graph_table out=work.graph_table
28818     +            level=ratio dimension=2 noprint;
28819     +        run;
28820     +        data work.graph_table;
28821     +            set work.graph_table;
28822     +            if _name_ ne '';
28823     +            Cluster=input(substr(_name_,2),8.);
28824     +            LABEL dim1='X' dim2='Y';
28825     +        run;
28826     +        proc sql noprint;
28827     +            create table &em_user_graph_table as
28828     +            select a.*, b.dim1, b.dim2
28829     +            from &em_user_graph_table a, work.graph_table b
28830     +            where a._cluster_=b.cluster;
28831     +        quit;
28832     +
28833     +        %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusterdist_title, NOQUOTE));
28834     +        %EM_REPORT(KEY=GRAPH_TABLE, VIEWTYPE=SCATTER, X=DIM1, Y=DIM2, BLOCK=%nrbquote(&BLOCK),
28835     +            DESCRIPTION=%nrbquote(&desc), AUTODISPLAY=Y, TIP=%if &em_property_nDescTerms > 5 %then desc_short; %else clus_desc;,
28836     +            GROUP=_CLUSTER_, LEGEND=N);
28837     +    %end;
28838     +    %else %do;
28839     +        %put &em_codebar;
28840     +        %let errormsg=%sysfunc(sasmsg(sashelp.tmine, EMTOOL.NODISTANCEREPORT_NOTE, NOQUOTE));
28841     +        %put &errormsg;
28842     +        %put &em_codebar;
28843     +    %end;
28844     +
28845     +    %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusterfreq_title, NOQUOTE));
28846     +    %EM_REPORT(KEY=GRAPH_TABLE, VIEWTYPE=PIE, X=_cluster_, Y=freq, DESCRIPTION=%nrbquote(&desc),
28847     +        TOOLTIP=clus_desc, BLOCK=%nrbquote(&block), AUTODISPLAY=Y);
28848     +
28849     +    %if &EM_PROPERTY_ALGORITHM=2.0 %then %do;
28850     +
28851     +        proc sql noprint;
28852     +            create table &em_user_hierds as
28853     +            select level, _cluster_, parent, clus_desc, *
28854     +            from &em_user_hierds;
28855     +        quit;
28856     +        filename temp catalog 'sashelp.emtext.tmsort.source';
28857     +        %include temp;
28858     +        %tmsort(data=&em_user_hierds, out=, by=level parent _cluster_);
28859     +
28860     +        data &em_user_hierds;
28861     +            set &em_user_hierds;
28862     +            label _cluster_="&clusterid"
28863     +                  clus_desc="&descterms"
28864     +                  freq="&frequency"
28865     +                  parent="&parent"
28866     +                  level="&hierlevel"
28867     +                  graphdesc="&graphdesc";
28868     +        run;
28869     +        %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_clusterhierarchy_title, NOQUOTE));
28870     +        %em_report(viewtype=constellation, linkkey=hierds, nodekey=hierds, method=HIERARCHY,
28871     +            linkfrom=_CLUSTER_,linkto=PARENT,linkid=_cluster_,nodeid=_CLUSTER_,nodesize=FREQ,nodelabel=graphdesc,
28872     +            nodetip=clus_desc, BLOCK=%nrbquote(&block), DESCRIPTION=%nrbquote(&desc), AUTODISPLAY=Y);
28873     +
28874     +        %let desc = %sysfunc(sasmsg(sashelp.tmine, rpt_text_hierarchydata_title, NOQUOTE));
28875     +        %em_report(KEY=hierds, VIEWTYPE=data, DESCRIPTION=%nrbquote(&DESC), AUTODISPLAY=Y, BLOCK=%nrbquote(&BLOCK));
28876     +    %end;
28877     +
28878     +    proc sql noprint;
28879     +        drop table work.graph_table;
28880     +    quit;
28881     +
28882     +%mend report;
28883     +
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(REPORT):  ;
MPRINT(REPORT):  ;
MPRINT(REPORT):  ;
MPRINT(REPORT):  ;
MPRINT(REPORT):  ;
MPRINT(REPORT):   proc sql noprint;
MPRINT(REPORT):   select count(*) into :svdkeep from EMWS5.TextCluster5_svd_s where keep=1;
MPRINT(REPORT):   select count(*) into :nclus from EMWS5.TextCluster5_clusters;
MPRINT(REPORT):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(REPORT):   data EMWS5.TextCluster5_GRAPH_TABLE;
MPRINT(REPORT):   set EMWS5.TextCluster5_clusters;
MPRINT(REPORT):   label _cluster_= "클러스터 ID" clus_desc= "기술 용어" freq= "빈도" percent= "비율" _rmsstd_= "RMS 표준편차" _mean1= "조합 1" _mean2= "조합 2" _mean3= "조합 3" _mean4= "조합 4" _mean5= "조합 5" _mean6= "조합 6" _mean7= "조합 7" _mean8=
"조 합 8" _mean9= "조합 9" _mean10= "조합 10" _mean11= "조합 11" _mean12= "조합 12" _mean13= "조합 13" _mean14= "조합 14" _mean15= "조합 15" _mean16= "조합 16" _mean17= "조합 17" _mean18= "조합 18" _mean19= "조합 19" _mean20= "조합 20" _mean21= "조합 21"
_mean22= "조합 22" _mean23= "조합 23" _mean24= "조합 24" _mean25= "조합 25" _mean26= "조합 26" _mean27= "조합 27" _mean28= "조합 28" _mean29= "조합 29" _mean30= "조합 30" _mean31= "조합 31" _mean32= "조합 32" _mean33= "조합 33" _mean34= "조합 34" _mean35=
"조합 35" _mean36= "조합 36" _mean37= "조합 37" _mean38= "조합 38" _mean39= "조합 39" _mean40= "조합 40" _mean41= "조합 41" _mean42= "조합 42" _mean43= "조합 43" _mean44= "조합 44" _mean45= "조합 45" ;
MPRINT(REPORT):   format percent percent10.;
MPRINT(REPORT):   desc_short = clus_desc;
MPRINT(REPORT):   if COUNTW(clus_desc, ' ') > 5 then do;
MPRINT(REPORT):   call scan(clus_desc, 6, position, len, ' ');
MPRINT(REPORT):   desc_short=substr(clus_desc, 1, position-1) || '...';
MPRINT(REPORT):   drop position len;
MPRINT(REPORT):   label desc_short= "기술 용어 샘플";
MPRINT(REPORT):   end;
MPRINT(REPORT):   run;
 
NOTE: 16개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_GRAPH_TABLE은(는) 16개의 관측값과 51개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.01 초
 
 
MPRINT(REPORT):   proc sql noprint;
MPRINT(REPORT):   create table EMWS5.TextCluster5_GRAPH_TABLE as select _cluster_, clus_desc, freq, percent, * from EMWS5.TextCluster5_GRAPH_TABLE;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 clus_desc이(가) 파일 EMWS5.TEXTCLUSTER5_GRAPH_TABLE에 이미 존재합니다.
WARNING: 변수 _CLUSTER_이(가) 파일 EMWS5.TEXTCLUSTER5_GRAPH_TABLE에 이미 존재합니다.
WARNING: 변수 freq이(가) 파일 EMWS5.TEXTCLUSTER5_GRAPH_TABLE에 이미 존재합니다.
WARNING: 변수 percent이(가) 파일 EMWS5.TEXTCLUSTER5_GRAPH_TABLE에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER5_GRAPH_TABLE created, with 16 rows and 51 columns.
 
MPRINT(REPORT):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   retain id 0;
MPRINT(EM_REPORT):   id + 1;
MPRINT(EM_REPORT):   length VIEW 8 NAME $32 VALUE $400;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "PRESCORECODE";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "SOURCE";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "SAS Prescore 코드";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "Scoring";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.43272929425944;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   run;
 
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 132개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.09 초
 
 
MPRINT(REPORT):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   set WORK.EM_USER_REPORT end=eof;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   if eof then do;
MPRINT(EM_REPORT):   id+1;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "GRAPH_TABLE";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "SCATTER";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "RMS별 클러스터 빈도";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "FREQ";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y";
MPRINT(EM_REPORT):   VALUE = "_RMSSTD_";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "desc_short";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.27358056664167;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   end;
MPRINT(EM_REPORT):   run;
 
NOTE: 132개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 265개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
 
 
MPRINT(REPORT):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   set WORK.EM_USER_REPORT end=eof;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   if eof then do;
MPRINT(EM_REPORT):   id+1;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "GRAPH_TABLE";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "DATA";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.10891484800209;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   end;
MPRINT(EM_REPORT):   run;
 
NOTE: 265개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 397개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
 
 
MPRINT(REPORT):  ;
MPRINT(REPORT):   data work.graph_table(drop=_cluster_);
MPRINT(REPORT):   set EMWS5.TextCluster5_GRAPH_TABLE;
MPRINT(REPORT):   cluster=put(_cluster_,best12.);
MPRINT(REPORT):   run;
 
NOTE: 16개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_GRAPH_TABLE.에서 읽었습니다.
NOTE: 데이터셋 WORK.GRAPH_TABLE은(는) 16개의 관측값과 51개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
 
 
MPRINT(REPORT):   proc distance data=work.graph_table out=work.graph_table method=EUCLID nostd;
MPRINT(REPORT):   var RATIO(_mean1-_mean45);
MPRINT(REPORT):   id cluster;
MPRINT(REPORT):   run;
 
WARNING: Found negative value(s) in the ratio variable(s). The distance matrix may be meaningless.
NOTE: 데이터셋 WORK.GRAPH_TABLE은(는) 16개의 관측값과 17개의 변수를 가지고 있습니다.
NOTE: 프로시저 DISTANCE 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
 
 
MPRINT(REPORT):   proc mds data=work.graph_table out=work.graph_table level=ratio dimension=2 noprint;
MPRINT(REPORT):   run;
 
NOTE: Convergence reached in 8 iterations.
NOTE: 데이터셋 WORK.GRAPH_TABLE은(는) 18개의 관측값과 7개의 변수를 가지고 있습니다.
NOTE: 프로시저 MDS 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(REPORT):   data work.graph_table;
MPRINT(REPORT):   set work.graph_table;
MPRINT(REPORT):   if _name_ ne '';
MPRINT(REPORT):   Cluster=input(substr(_name_,2),8.);
MPRINT(REPORT):   LABEL dim1= 'X' dim2= 'Y';
MPRINT(REPORT):   run;
 
NOTE: 18개의 관측값을 데이터셋 WORK.GRAPH_TABLE.에서 읽었습니다.
NOTE: 데이터셋 WORK.GRAPH_TABLE은(는) 16개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(REPORT):   proc sql noprint;
MPRINT(REPORT):   create table EMWS5.TextCluster5_GRAPH_TABLE as select a.*, b.dim1, b.dim2 from EMWS5.TextCluster5_GRAPH_TABLE a, work.graph_table b where a._cluster_=b.cluster;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS5.TEXTCLUSTER5_GRAPH_TABLE created, with 16 rows and 53 columns.
 
MPRINT(REPORT):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   set WORK.EM_USER_REPORT end=eof;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   if eof then do;
MPRINT(EM_REPORT):   id+1;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "GRAPH_TABLE";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "SCATTER";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "클러스터 간 거리";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "DIM1";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y";
MPRINT(EM_REPORT):   VALUE = "DIM2";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "_CLUSTER_";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "desc_short";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.52382177185445;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   end;
MPRINT(EM_REPORT):   run;
 
NOTE: 397개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 530개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.09 초
 
 
MPRINT(REPORT):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   set WORK.EM_USER_REPORT end=eof;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   if eof then do;
MPRINT(EM_REPORT):   id+1;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "GRAPH_TABLE";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "PIE";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "클러스터 빈도";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "_cluster_";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y";
MPRINT(EM_REPORT):   VALUE = "freq";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "clus_desc";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.30692220772938;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   end;
MPRINT(EM_REPORT):   run;
 
NOTE: 530개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 663개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.09 초
 
 
MPRINT(REPORT):  ;
MPRINT(REPORT):   proc sql noprint;
MPRINT(REPORT):   create table EMWS5.TextCluster5_hierds as select level, _cluster_, parent, clus_desc, * from EMWS5.TextCluster5_hierds;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 parent이(가) 파일 EMWS5.TEXTCLUSTER5_HIERDS에 이미 존재합니다.
WARNING: 변수 level이(가) 파일 EMWS5.TEXTCLUSTER5_HIERDS에 이미 존재합니다.
WARNING: 변수 _CLUSTER_이(가) 파일 EMWS5.TEXTCLUSTER5_HIERDS에 이미 존재합니다.
WARNING: 변수 clus_desc이(가) 파일 EMWS5.TEXTCLUSTER5_HIERDS에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER5_HIERDS created, with 32 rows and 6 columns.
 
MPRINT(REPORT):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(REPORT):   filename temp catalog 'sashelp.emtext.tmsort.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMSORT.SOURCE입니다.
28884     + /*
28885     +PROC SORT macro
28886     +
28887     +%tmsort(data=, out=, by=);
28888     +
28889     +data=      - name of input data set (outtree data set from PROC CLUSTER)
28890     +out=       - name of the output data set
28891     +by=        - by statement
28892     +options=   - proc options
28893     +*/
28894     +
28895     +%macro tmsort(data=, out=, by=, options=, threads=THREADS);
28896     +  %if %BQUOTE(&out) ^= %then %let out = out =  &out;
28897     +  %if &SYSVER < 9 %then %let threads = ;
28898     +
28899     +  proc sort data = %STR(&data) &threads &options
28900     +    &out;
28901     +    by &by;
28902     +  run;
28903     +
28904     +%mend tmsort;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TMSORT):   proc sort data = EMWS5.TextCluster5_hierds THREADS ;
MPRINT(TMSORT):   by level parent _cluster_;
MPRINT(TMSORT):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
 
 
MPRINT(REPORT):  ;
MPRINT(REPORT):   data EMWS5.TextCluster5_hierds;
MPRINT(REPORT):   set EMWS5.TextCluster5_hierds;
MPRINT(REPORT):   label _cluster_= "클러스터 ID" clus_desc= "기술 용어" freq= "빈도" parent= "상위" level= "계층 레벨" graphdesc= "그래프 설명";
MPRINT(REPORT):   run;
 
NOTE: 32개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER5_HIERDS은(는) 32개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   set WORK.EM_USER_REPORT end=eof;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   if eof then do;
MPRINT(EM_REPORT):   id+1;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "constellation";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "HIERARCHY";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "FALSE";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "클러스터 계층";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "FREQ";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "hierds";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "hierds";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "_CLUSTER_";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "CIRCLE";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "graphdesc";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "clus_desc";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "_cluster_";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "_CLUSTER_";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "PARENT";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "HIERARCHY";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.44963177733571;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   end;
MPRINT(EM_REPORT):   run;
 
NOTE: 663개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 795개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
 
 
MPRINT(REPORT):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   set WORK.EM_USER_REPORT end=eof;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   if eof then do;
MPRINT(EM_REPORT):   id+1;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "hierds";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "data";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "계층 데이터";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "클러스터";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.75024366972513;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   end;
MPRINT(EM_REPORT):   run;
 
NOTE: 795개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 927개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.12 초
 
 
MPRINT(REPORT):  ;
MPRINT(REPORT):   proc sql noprint;
MPRINT(REPORT):   drop table work.graph_table;
NOTE: 테이블 WORK.GRAPH_TABLE 을(를) 삭제했습니다.
MPRINT(REPORT):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
 
 
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End REPORT: TextCluster5;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
28905      *------------------------------------------------------------*;
28906      * End REPORT: TextCluster5;
28907      *------------------------------------------------------------*;
 
28908      /* Reset EM Options */
28909      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):    options formchar="|----|+|---+=|-/\<>*";
28910      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
28911      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
28912      proc sort data=WORK.EM_USER_REPORT;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_USER_REPORT;
28913      by ID VIEW;
MPRINT(EM_DIAGRAM):   by ID VIEW;
28914      run;
MPRINT(EM_DIAGRAM):   run;
 
NOTE: 927개의 관측값을 데이터셋 WORK.EM_USER_REPORT.에서 읽었습니다.
NOTE: 데이터셋 WORK.EM_USER_REPORT은(는) 927개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
 
 
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
