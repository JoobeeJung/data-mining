MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "2018년 11월 28일" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "21시07분42초" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* 스코어 로그";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* 스코어 로그
날짜:                2018년 11월 28일
시간:                21시07분42초
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O2M1W_U8 "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster6\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O2M1W_U8 new;
MPRINT(EM_DIAGRAM):   run;
26175      %let EMEXCEPTIONSTRING=;
26176      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
26177      * SCORE: TextCluster6;
MPRINT(EM_DIAGRAM):   * SCORE: TextCluster6;
26178      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
26179      %let EM_ACTION = SCORE;
26180      %let syscc = 0;
26181      %macro main();
26182      
26183         %if %upcase(&EM_ACTION) eq CREATE %then %do;
26184            filename temp catalog 'sashelp.emtxtext.cluster_create.source';
26185            %include temp;
26186            %create();
26187         %end;
26188         %if %upcase(&EM_ACTION) eq TRAIN %then %do;
26189            filename temp catalog 'sashelp.emtxtext.cluster_train.source';
26190            %include temp;
26191            %train();
26192         %end;
26193         %if %upcase(&EM_ACTION) eq REPORT %then %do;
26194            filename temp catalog 'sashelp.emtxtext.cluster_report.source';
26195            %include temp;
26196            %report();
26197         %end;
26198         %if %upcase(&EM_ACTION) eq SCORE %then %do;
26199            filename temp catalog 'sashelp.emtxtext.cluster_score.source';
26200            %include temp;
26201            %score();
26202         %end;
26203      %mend main;
26204      
26205      %main();
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emtxtext.cluster_score.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.CLUSTER_SCORE.SOURCE입니다.
26206     +%macro tmc_score(import_ds=,configdata=,export_ds=,term_ds=,export_out=,clusters_ds=,svdu=,svds=,
26207     +    import_out=,em_outstat=,prefixstring=,ocluster=,ndescterms=,ftmout=,fterms=,hier=);
26208     +  %if &import_ds ne %then %do;
26210     +    %let syscc=0;
26212     +    %tmc_doc_score(import=&import_ds,export=&export_ds,emoutstat=&em_outstat,
26213     +                termds=&term_ds,clusters=&clusters_ds,configds=&configdata,
26214     +                _scrout=&import_out, svd_u=&svdu, svd_s=&svds, prefix=&prefixstring,
26215     +                outclusters=&ocluster, descterms=&ndescterms, filterterms=&fterms,
26216     +                filtertmout=&ftmout, hierds=&hier);
26218     +  %end;
26220     +%mend tmc_score;
26221     +%macro score();
26223     +    %global last_parse_node last_filter_node last_prescore_node server_err
26224     +      parsevar EM_SASMSG ;
26225     +    %let syscc=0;
26226     +    %if ^%symexist(tm_debug) %then %let tm_debug=0;
26227     +    /*use saved version of em_info in case macro is not populated*/
26228     +    %em_getname(key=last_tm_nodes, type=data);
26230     +    filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
26231     +    %include temp;
26232     +    %tm_get_last_filter(eminfo=&em_user_last_tm_nodes,em_lib=&em_lib,
26233     +                        em_variableset=&em_data_variableset);
26234     +    %if &EMEXCEPTIONSTRING ne %then %goto end_cluster_score;
26235     +    %let lastparsenode=&last_parse_node;
26236     +    %let lastfilternode=&last_filter_node;
26237     +    %let lastprescore=&last_prescore_node;
26238     +    %let filt_node=;
26240     +   %em_getname(key=terms, type=data);
26241     +   %em_getname(key=docs, type=data);
26242     +   %em_getname(key=clusters, type=data);
26243     +   %em_getname(key=svd_u, type=data);
26244     +   %em_getname(key=svd_s, type=data);
26245     +   %em_getname(key=emoutstat, type=data);
26246     +   %em_getname(key=tmconfig, type=data);
26248     +   %em_getname(key=tmout, type=data);
26249     +   %em_getname(key=validout, type=data);
26250     +   %em_getname(key=testout, type=data);
26251     +   %em_getname(key=scoreout, type=data);
26252     +   %em_getname(key=PRESCORECODE, type=file, extension=sas);
26253     +   %let systmutil=;
26255     +    filename temp catalog 'sashelp.emtxtext.tm_data2code.source';
26256     +    %include temp;
26257     +    filename temp catalog 'sashelp.emtext.tmemclus.source';
26258     +    %include temp;
26259     +    filename temp catalog 'sashelp.emtext.tmpred.source';
26260     +    %include temp;
26261     +    filename temp catalog 'sashelp.emtext.tmsort.source';
26262     +    %include temp;
26263     +    filename temp catalog 'sashelp.emtxtext.tmc_doc_score.source';
26264     +    %include temp;
26265     +    filename temp catalog 'sashelp.emtext.tmsvd.source';
26266     +    %include temp;
26267     +    filename temp catalog 'sashelp.emtext.tmfast.source';
26268     +    %include temp;
26270     +   %let EM_PUBLISHCODE = PUBLISH;
26271     +   %let EM_SCORECODEFORMAT = DATASTEP;
26272     +   %let overwrite_pre = ;
26274     +   %let lastprescore=%trim(%left(&lastprescore));
26276     +   /* Create indexed term table for writing out score code */
26277     +   proc sql noprint;
26278     +       select count(*) into :svdkeep
26279     +       from &em_user_svd_s
26280     +       where keep=1;
26281     +   create table _clusterms as
26282     +      select key, term, role, keep, freq, numdocs, parent, _ispar, weight from &em_user_terms;
26284     +   data _filter_tmout;
26285     +      set &EM_LIB..&lastfilternode._tmout;
26286     +   run;
26288     +   %tmc_score(import_ds=&em_import_data,export_ds=&em_export_train,
26289     +              import_out=_filter_tmout,
26290     +              export_out=&EM_export_transaction,
26291     +              term_ds=_clusterms,
26292     +              clusters_ds=&em_user_clusters,
26293     +              svdu=&em_user_svd_u,
26294     +              svds=&em_user_svd_s,
26295     +              em_outstat=&em_user_emoutstat,
26296     +              configdata=&em_user_tmconfig,
26297     +              prefixstring=&EM_NODEID,
26298     +              ocluster=&em_user_clusters,
26299     +              ndescterms=&em_property_ndescterms,
26300     +              fterms=&EM_LIB..&lastfilternode._terms,
26301     +              ftmout=&EM_LIB..&lastfilternode._tmout,
26302     +              hier=&em_user_hierds);
26304     +   %tmc_score(import_ds=&em_import_validate,export_ds=&em_export_validate,
26305     +              export_out=&EM_USER_validout,
26306     +              import_out=&EM_LIB..&lastfilternode._validout,
26307     +              term_ds=_clusterms,
26308     +              clusters_ds=&em_user_clusters,
26309     +              svdu=&em_user_svd_u,
26310     +              svds=&em_user_svd_s,
26311     +              em_outstat=&em_user_emoutstat,
26312     +              configdata=&em_user_tmconfig,
26313     +              prefixstring=&EM_NODEID);
26314     +   %tmc_score(import_ds=&em_import_test,export_ds=&em_export_test,
26315     +              export_out=&EM_USER_testout,
26316     +              import_out=&EM_LIB..&lastfilternode._testout,
26317     +              term_ds=_clusterms,
26318     +              clusters_ds=&em_user_clusters,
26319     +              svdu=&em_user_svd_u,
26320     +              svds=&em_user_svd_s,
26321     +              em_outstat=&em_user_emoutstat,
26322     +              configdata=&em_user_tmconfig,
26323     +              prefixstring=&EM_NODEID);
26325     +   %if &syscc>4 %then %do;
26326     +       %let syscc=0;
26327     +       %goto end_cluster_score;
26328     +   %end;
26330     +   * path of the diagram ;
26331     +   %let emwspath = ;
26332     +   data _null_;
26333     +      call symput("emwspath", strip(pathname("&EM_LIB")));
26334     +   run;
26336     +   filename pre "&EM_USER_PRESCORECODE";
26337     +   data _null_;
26338     +       file pre;
26339     +       put 'filename temp catalog "sashelp.emtext.tmemclus.source";';
26340     +       put '%include temp;';
26341     +       put 'filename temp catalog "sashelp.emtext.tmpred.source";';
26342     +       put '%include temp;';
26343     +       put 'filename temp catalog "sashelp.emtxtext.tmc_doc_score.source";';
26344     +       put '%include temp;';
26345     +       put 'filename temp catalog "sashelp.emtext.tmsort.source";';
26346     +       put '%include temp;';
26347     +       put 'filename temp catalog "sashelp.emtext.tmsvd.source";';
26348     +       put '%include temp;';
26349     +       put 'filename temp catalog "sashelp.emtext.tmfast.source";';
26350     +       put '%include temp;';
26351     +       put 'filename temp;';
26352     +   run;
26355     +   /* We need to use last prescore */
26356     +   %if &lastprescore ne %then %do;
26357     +      %let tmprescoreFile = %bquote(&emwspath)&em_dsep&lastprescore&em_dsep.PRESCORECODE.sas;
26358     +      filename tmpre "&tmprescoreFile";
26359     +      %em_copyfile(infref=tmpre, outfref=pre, append=Y);
26360     +      filename tmpre;
26361     +   %end;
26363     +   data _codeclusters;
26364     +        set &em_user_clusters (drop=clus_desc);
26365     +   run;
26367     +     %if not %symexist(em_term_loc) %then %do;
26368     +       %let em_term_loc = %bquote(%sysfunc(pathname(&EM_LIB)));
26369     +         libname termloc "&em_term_loc";
26371     +      %let scored_terms = termloc.&lastfilternode._filtterms;
26372     +       %let scored_clust = termloc.&EM_NODEID._clusters;
26373     +       %let scored_config = termloc.&EM_NODEID._tmconfig;
26374     +       %let scored_svd_u = termloc.&EM_NODEID._svd_u;
26375     +       %let scored_svd_s= termloc.&EM_NODEID._svd_s;
26377     +       %if &em_property_algorithm=1.0 %then  %do;
26378     +          %let scored_emoutstat= termloc.&EM_NODEID._emoutstat;
26379     +       %end;
26381     +   %end;
26382     +   %else %do; /* Write out data sets to external directory */
26383     +       libname termloc "&em_term_loc";
26384     +        %if %sysfunc(libref(termloc)) ne 0 %then %do;
26385     +           %let  EMEXCEPTIONSTRING = EMTOOL.EMTERMLOC,&em_term_loc;
26386     +           %goto end_cluster_score;
26387     +       %end;
26389     +      /* copy datasets to use for prescore code*/
26390     +       data termloc.&EM_LIB._&EM_NODEID._CLUSTERS;
26391     +         set _codeclusters;
26392     +       run;
26394     +       data termloc.&EM_LIB._&EM_NODEID._svd_u;
26395     +         set &em_user_svd_u;
26396     +       run;
26398     +       data termloc.&EM_LIB._&EM_NODEID._svd_s;
26399     +         set &em_user_svd_s;
26400     +       run;
26402     +       data termloc.&EM_LIB._&EM_NODEID._tmconfig;
26403     +         set &em_user_tmconfig;
26404     +       run;
26406     +       %let scored_terms = termloc.&EM_LIB._&lastfilternode._filtterms;
26407     +       %let scored_clust = termloc.&EM_LIB._&EM_NODEID._CLUSTERS;
26408     +       %let scored_config = termloc.&EM_LIB._&EM_NODEID._tmconfig;
26409     +       %let scored_svd_u = termloc.&EM_LIB._&EM_NODEID._svd_u;
26410     +       %let scored_svd_s= termloc.&EM_LIB._&EM_NODEID._svd_s;
26412     +       %if &em_property_algorithm=1.0 %then  %do;
26413     +         data termloc.&EM_LIB._&EM_NODEID._emoutstat;
26414     +         set &em_user_emoutstat;
26415     +         run;
26416     +           %let scored_emoutstat= termloc.&EM_LIB._&EM_NODEID._emoutstat;
26417     +       %end;
26418     +   %end;
26422     +   %let _score_append=;
26424     +   * Now save code, if necessary, for search phrase;
26425     +   filename _tmscore "&EM_FILE_EMPUBLISHSCORECODE";
26426     +   %if &em_property_algorithm=1.0 %then %do;
26427     +   data _NULL_;
26428     +     file _tmscore;
26429     +     length string $200;
26430     +     string ='%tmc_doc_score(import='||'&em_score_output'||",export=work._newexport,";
26431     +     put string;
26432     +     string="      termds=&scored_terms, configds=&scored_config,";
26433     +     put string;
26434     +     string= "      clusters=&scored_clust, emoutstat=&scored_emoutstat, ";
26435     +     put string;
26436     +     string = "      _scrout=work.&lastfilternode._out, svd_u=&scored_svd_u, svd_s=&scored_svd_s, prefix=&em_nodeid);";
26437     +     put string;
26438     +     string='data &em_score_output; set work._newexport;';
26439     +     put string;
26440     +    run;
26441     +    %end;
26442     +    %else %do;
26443     +    data _NULL_;
26444     +     file _tmscore;
26445     +     string= '%'||"tmc_doc_score(import="||'&em_score_output'||",export=work._newexport,";
26446     +     put string;
26447     +     put "      termds=&scored_terms,configds=&scored_config,";
26448     +     put "      clusters=&scored_clust, ";
26449     +     put "      _scrout=work.&lastfilternode._out, svd_u=&scored_svd_u, svd_s=&scored_svd_s, prefix=&em_nodeid);";
26450     +     put 'data &em_score_output; set work._newexport;';
26451     +    run;
26452     +    %end;
26453     +   filename _tmscore;
26455     +%end_cluster_score:
26456     +    filename temp;
26457     +    %if &tm_debug =0 %then %do;
26458     +    proc sql noprint;
26459     +        drop table _clusterms;
26460     +        drop table _filter_tmout;
26461     +        drop table _codeclusters;
26462     +    quit;
26463     +    %end;
26465     +%mend score;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):  ;
MPRINT(SCORE):   filename temp catalog 'sashelp.emtxtext.tm_get_last_filter.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_GET_LAST_FILTER.SOURCE입니다.
26467     +/* ****************************************************************
26468     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
26469     + *
26470     + * Name:             tm_get_last_filter.sas
26471     + * Product:          SAS Text Miner
26472     + * Language:         Sas
26473     + * Script:
26474     + *
26475     + * Usage:
26476     + *
26477     + * Purpose:  macro to get the last filter node and the last parse node in the
26478     + *   diagram that corresponds to the current parse variable.  If there is no filter
26479     + *   node, the filter node is set to the last parse node.
26480     + *
26481     + *
26482     + *
26483     + * History:
26484     + * 14Aug09 Initial Coding
26485     + *
26486     + * Notes:
26487     + *    Returns an error in the following cases:
26488     + *      1. There is no preceding parse node.
26489     + *      2. There is no parse node with the current parse variable.
26490     + *
26491     + * Last Modified By:
26492     + * Last Modified On: Wed Sep 23 15:35:04 2009
26493     + *
26494     + * End
26495     + * ************************************************************** */
26496     +%macro tm_get_last_filter(eminfo=,em_lib=, em_variableset=);
26497     +   %let last_parse_node=;
26498     +   %let last_filter_node=;
26499     +   %let last_prescore_node=;
26500     +   %let server_err=;
26501     +   %let EMEXCEPTIONSTRING=;
26502     +   %let syscc=0;
26503     +
26504     +    /* verify that setinit for SAS Text Miner is currently active */
26505     +    %if %sysfunc(sysprod(PRODNUM107)) ne 1 %then %do;
26506     +       %let EMEXCEPTIONSTRING = EMTOOL.NOTMLICENSE;
26507     +        %goto end_macro;
26508     +        %end;
26509     +
26510     +
26511     +    * find last filter or text parse node if no filter node. ;
26512     +   %if %sysfunc(exist(&eminfo)) %then %do;
26513     +      proc sql noprint;
26514     +      select data into :last_parse_node from &eminfo where key="LastTextParsing";
26515     +         select data into :last_filter_node from &eminfo where key="LastTextFilter";
26516     +         select data into :last_prescore_node from &eminfo where kupcase(key)="PRESCORECODE";
26517     +      quit;
26518     +
26519     +   %end;
26520     +
26521     +   %if &last_parse_node= %then %do;
26522     +      %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGNODE;
26523     +      %goto end_macro;
26524     +      %end;
26525     +
26526     +   %else %if &last_filter_node= %then %let last_filter_node = %ktrim(&last_parse_node);
26527     +   %else %let last_filter_node = %ktrim(&last_filter_node);
26528     +   %let last_parse_node = %ktrim(&last_parse_node);
26529     +
26530     +   * Check to make sure parse variable is present and still exists;
26531     +   %let parsevar = ;
26532     +   proc sql noprint;
26533     +    select parsevar into :parsevar
26534     +    from &em_lib..&last_filter_node._tmconfig;
26535     +    quit;
26536     +
26537     +    *check for dropped parsevar on input dataset;
26538     +       %let parsevarOK= ;
26539     +       %let parsevarN=%kupcase(%ktrim(&parsevar));
26540     +       data _null_;
26541     +         set &em_variableset(where=(kupcase(NAME)="&parsevarN" and USE in('Y' 'D')));
26542     +         if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
26543     +         run;
26544     +       %if(&parsevarOK eq ) %then %do;
26545     +          %let EMEXCEPTIONSTRING = EMTOOL.NOPARSINGVAR;
26546     +          %goto end_macro;
26547     +          %end;
26548     +%end_macro:
26549     +
26550     +%mend tm_get_last_filter;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_GET_LAST_FILTER):   * find last filter or text parse node if no filter node. ;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select data into :last_parse_node from EMWS5.TextCluster6_last_tm_nodes where key="LastTextParsing";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_filter_node from EMWS5.TextCluster6_last_tm_nodes where key="LastTextFilter";
MPRINT(TM_GET_LAST_FILTER):   select data into :last_prescore_node from EMWS5.TextCluster6_last_tm_nodes where kupcase(key)="PRESCORECODE";
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GET_LAST_FILTER):   * Check to make sure parse variable is present and still exists;
MPRINT(TM_GET_LAST_FILTER):   proc sql noprint;
MPRINT(TM_GET_LAST_FILTER):   select parsevar into :parsevar from EMWS5.TextFilter6_tmconfig;
MPRINT(TM_GET_LAST_FILTER):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
      

MPRINT(TM_GET_LAST_FILTER):   *check for dropped parsevar on input dataset;
MPRINT(TM_GET_LAST_FILTER):   data _null_;
MPRINT(TM_GET_LAST_FILTER):   set EMWS5.TextCluster6_VariableSet(where=(kupcase(NAME)="REVIEW" and USE in('Y' 'D')));
MPRINT(TM_GET_LAST_FILTER):   if (ROLE='TEXT' or ROLE='TEXTLOC') then call symput('parsevarOK', strip(ROLE));
MPRINT(TM_GET_LAST_FILTER):   run;

NOTE: 1개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_VARIABLESET.에서 읽었습니다.
      WHERE (KUPCASE(NAME)='REVIEW') and USE in ('D', 'Y');
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):   filename temp catalog 'sashelp.emtxtext.tm_data2code.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TM_DATA2CODE.SOURCE입니다.
26551     +/* ****************************************************************
26552     + * Copyright (C) 2009 by SAS Institute Inc., Cary, NC 27513
26553     + *
26554     + * Name:             tm_data2code.sas
26555     + * Product:          SAS Text Miner
26556     + * Language:         Sas
26557     + * Script:
26558     + *
26559     + * Usage:  %tm_data2code(data=, outdata=WORK.DATA);
26560     + *
26561     + * Purpose:          To do a data2code (like %em_data2code()) but allow the input data
26562     + *  to be view or data.
26563     + *
26564     + *    PARAMETERS:
26565     + *        DATA        = data set
26566     + *        OUTDATA     = out data set
26567     + *        OUTFILE     = file where to saved the code
26568     + *        APPEND      = append (Y/N)
26569     + * History:
26570     + * 11Jun09 Initial Coding
26571     + *
26572     + * Notes:
26573     + *
26574     + * Last Modified By:
26575     + * Last Modified On: Thu Jul 23 11:00:06 2009
26576     + *
26577     + * End
26578     + * ************************************************************** */
26579     +%macro tm_data2code(data=, outdata=WORK.DATA, outfile=, append=N);
26580     +%if &data eq %then %do;
26581     +   %put ERROR: Data set not defined;
26582     +   %end;
26583     +%else %do;
26584     +   %if (^%sysfunc(exist(&data)) and ^%sysfunc(exist(&data, view))) %then %do;
26585     +       %put ERROR: Data set does not exist;
26586     +       %end;
26587     +   %else %do;
26588     +      %global em_data em_outdata em_codefile em_append;
26589     +      %let em_data=&data;
26590     +      %let em_outdata=&outdata;
26591     +      %let em_codefile=&outfile;
26592     +      %let em_append=&append;
26593     +      proc display c=sashelp.emutil.data2code.scl; run;
26594     +      %end;
26595     +   %end;
26596     +%mend;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmemclus.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMEMCLUS.SOURCE입니다.
26597     +
26598     + /*
26599     +
26600     +  Macro:   tmemclus.sas
26601     +  Purpose: Call proc emclus with given defaults and parameters.
26602     +  Syntax:  %tmemclus(data=, role=, clusters=, seed=,
26603     +                   outstat=, out=, vars=, cov=, iter=, secclus=,
26604     +                   seciter=, min=, method=, eps=, init=, print=,
26605     +                   p=, outliers=, decvar=, initstd=, dist=,
26606     +                   secstd=, nobs=, threads=);
26607     +  Required Parameters:  data=      The input data set.
26608     +                        role=      Train or score
26609     +                        clusters=  The number of primary clusters
26610     +
26611     +  Optional Parameters:  vars=      Variables to be used
26612     +                   cov=       Type of covariance matrix
26613     +                   iter=      Number of EM iterations
26614     +                   secclus    Number of secondary clusters
26615     +                   seciter    Number of k-means iterations
26616     +                   min=       Minimum number of obs in a cluster
26617     +                   method=    Standard or scaled
26618     +                   eps=       Stopping tolerance
26619     +                   init=      Random, Fastclus, or Emclus
26620     +                   print=     All, last, or none
26621     +                   p=
26622     +                   outliers=  Keep, cluster, or ignore
26623     +                   outstat=   Name of OUTSTAT data set
26624     +                   out=       Name of OUT data set
26625     +                   seed=      Name of SEED data set
26626     +                   decvar=    Proportion to decrease variances
26627     +                   initstd=   Initial standard deviation
26628     +                   dist=      Minimum distance between clusters
26629     +                   secstd=    Secondary cluster max std dev.
26630     +                   nobs=      Number of obs read in each iteration
26631     +  History:
26632     +  2001/01/16 - Bill Wheeler - Initial Coding.
26633     +  2001/11/29 - Bill Wheeler - Updated for version 8 or 9
26634     +*/
26635     +%MACRO tmemclus(data=, role=, clusters=, seed=,
26636     + outstat=, out=, vars=, cov=, iter=, secclus=,
26637     + seciter=, min=, method=, eps=, init=, print=,
26638     + p=, outliers=, decvar=, initstd=, dist=, secstd=, nobs=, threads=);
26639     +
26640     + %local saveout saveseed op1 op2 op3 op4;
26641     +
26642     + %LET saveout = &out;
26643     + %LET saveseed = &outstat;
26644     +
26645     + /* defaults */
26646     + %if &role= %then %let role = TRAIN;
26647     + %if &seed ne %then %let seed = seed=&seed;
26648     + %if &vars= %then %let var = ;
26649     + %else %let var = var &vars;
26650     + %if &cov ne %then %let cov = cov = &cov;
26651     + %if &iter ne %then %let iter = iter = &iter;
26652     + %if &init ne %then %let init = init = &init;
26653     + %if &eps ne  %then %let eps = eps = &eps;
26654     + %if &min ne %then %let min = min = &min;
26655     + %if &seciter ne %then %let seciter = seciter = &seciter;
26656     + %if &print ne %then %let print = print = &print;
26657     + %if &p ne %then %let p = p = &p;
26658     + %if &outliers ne %then %let outliers = outliers = &outliers;
26659     + %if &method ne %then %let method = method = &method;
26660     + %if &decvar ne %then %let decvar = decvar = &decvar;
26661     + %if &outstat ne %then %let outstat = outstat = &outstat;
26662     + %if &out ne %then %let out = out = &out;
26663     + %if (&threads >= 0)  %then %let threads = threads = &threads;
26664     + %else %let threads = ;
26665     +
26666     + %LET op1 = ;
26667     + %LET op2 = ;
26668     + %LET op3 = ;
26669     + %LET op4 = ;
26670     + %if ^(&initstd=) %then %let op1 = %str(initstd = &initstd);
26671     + %if ^(&dist=) %then %let op2 = %str(dist = &dist);
26672     + %if ^(&secstd=) %then %let op3 = %str(secstd = &secstd);
26673     + %if ^(&nobs=) %then %let op4 = %str(nobs = &nobs);
26674     +
26675     +
26676     + %IF &SYSVER < 9 %THEN %DO;
26677     +    %LET cov = ;
26678     +    %LET decvar = ;
26679     +    %LET outliers = ;
26680     +    %LET out = ;
26681     + %END;
26682     +
26683     +
26684     + %if %upcase(&role) = TRAIN %then
26685     + %do;
26686     +   proc emclus data = &data
26687     +   clusters = &clusters
26688     +   &seed
26689     +   &outstat
26690     +   &out
26691     +   &init
26692     +   &eps
26693     +   &method
26694     +   &secclus
26695     +   &min
26696     +   &print
26697     +   &outliers
26698     +   &iter
26699     +   &op1 &op2
26700     +   &op3 &op4
26701     +   &decvar
26702     +   &cov
26703     +   &threads
26704     +   ;
26705     +   &var;
26706     + %end;
26707     + %else
26708     +  %do;
26709     +    proc emclus data = &data
26710     +    role = score
26711     +    clusters = &clusters
26712     +    &seed
26713     +    &out
26714     +    &cov
26715     +    ;
26716     +    &var;
26717     +  %end;
26718     +
26719     + %IF &SYSVER < 9 and &saveout ^= %THEN %DO;
26720     +   proc emclus data = &data
26721     +   role = score
26722     +   clusters = &clusters
26723     +   seed = &saveseed
26724     +   &saveout
26725     +   ;
26726     +   &var;
26727     + %END;
26728     +
26729     +
26730     +%MEND tmemclus;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmpred.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMPRED.SOURCE입니다.
26731     +
26732     +/*
26733     +  Macro: tmpred(inds,outds,clusters,type=,ignore=,freqDS=)
26734     +
26735     +  Description: This macro will take output from
26736     +     emclus and generate predicted
26737     +      predicted clusters.
26738     +
26739     +  Parms: inds - input data set, produced by emclus.
26740     +   outds - data set with clusters created by this macro.
26741     +   clusters - number of clusters that should be on this data set
26742     +   type - valid values: 'max' or 'prob'.  Max will just take the
26743     +      cluster with the highest probability as the predicted cluster.
26744     +      In the case of a tie the first cluster with that value will
26745     +       selected.
26746     +      Prob will attempt to select multiple clusters based on
26747     +      how many clusters were requested.  That is if 3 clusters
26748     +      were requested, any cluster with prob>1/3 will be selected
26749     +      as the predicted cluster. THIS OPTION IS UNTESTED.
26750     +*/
26751     +
26752     +%macro tmpred(inds,outds,clusters,type=, ignore=0, freqDS=, compress=1);
26753     +
26754     +  %local _str newfreqDS _flag;
26755     +
26756     +  * set the optional arguments;
26757     +  %if &type= %then %let type=max;
26758     +  %if &ignore = 1 %then %let
26759     +    _str = if _CLUSTER_ = &clusters then _CLUSTER_ = .;
26760     +  %else %let _str = ;
26761     +  %if %str(&freqDS) ^= %str() %then %do;
26762     +   %let newfreqDS = &freqDS(keep=_c1-_c&clusters);
26763     +   %let _flag = 1;
26764     +  %end;
26765     +  %else %let _flag = 0;
26766     +
26767     +  %if &compress = 1 %then %let compress = compress=Y;
26768     +  %else %let compress = ;
26769     +
26770     +  data &outds(&compress drop=_c1-_c&clusters)
26771     +    %if &_flag = 1 %then %do;
26772     +    &newfreqDS
26773     +    %end;
26774     +    ;
26775     +    set &inds end=eof;
26776     +   * array for holding all probabilities;
26777     +    array _p prob1--prob&clusters;
26778     +    array _c(&clusters);
26779     +    retain _c 0;
26780     +   * get rid of working columns;
26781     +    drop _max_ _i /*prob1--prob&clusters*/ _WARN_;
26782     +    /* keep the largest probability and the cluster */
26783     +    _max_ = 0;
26784     +    do _i = 1 to &clusters;
26785     +      if _p(_i) > _max_ then do;
26786     +        _max_ = _p(_i);
26787     +        _CLUSTER_ = _i;
26788     +      end;
26789     +    end;
26790     +    if (_CLUSTER_ >= 1) and (_CLUSTER_ <= &clusters) then
26791     +      _c(_CLUSTER_) = _c(_CLUSTER_) + 1;
26792     +    else _CLUSTER_ = .;
26793     +    &_str;
26794     +    %if &_flag = 1 %then %do;
26795     +      if eof then do;
26796     +        output &freqDS;
26797     +                output &outDS;
26798     +          end;
26799     +          else output &outDS;
26800     +        %end;
26801     +
26802     +    run;
26803     +%mend tmpred;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmsort.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMSORT.SOURCE입니다.
26804     + /*
26805     +PROC SORT macro
26806     +
26807     +%tmsort(data=, out=, by=);
26808     +
26809     +data=      - name of input data set (outtree data set from PROC CLUSTER)
26810     +out=       - name of the output data set
26811     +by=        - by statement
26812     +options=   - proc options
26813     +*/
26814     +
26815     +%macro tmsort(data=, out=, by=, options=, threads=THREADS);
26816     +  %if %BQUOTE(&out) ^= %then %let out = out =  &out;
26817     +  %if &SYSVER < 9 %then %let threads = ;
26818     +
26819     +  proc sort data = %STR(&data) &threads &options
26820     +    &out;
26821     +    by &by;
26822     +  run;
26823     +
26824     +%mend tmsort;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtxtext.tmc_doc_score.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TMC_DOC_SCORE.SOURCE입니다.
26825     +/*****************************************************************************
26826     +*
26827     +* tmc_doc_score
26828     +*
26829     +*  import  =  the doc data set of _document_ ids's as input
26830     +*  export = the new doc dataset with the svd dimensions and cluster results as output
26831     +*  termds = the terms table as input
26832     +*  clusters = input dataset of clusters from train
26833     +*  emoutstat = input dataset of seeds from training
26834     +*  _scrout = input OUT data set to be scored, may be trimmed based on conent of termds
26835     +*  svd_u = input singular vectors
26836     +
26837     +
26838     +*  svd_s = input singular values
26839     +*  prefxi = variable prefix string identifier.
26840     +*
26841     +**************************************************************************************/
26842     +
26843     +%macro tmc_doc_score(import=,export=,termds=,export_out=,clusters=,emoutstat=,
26844     +                 _scrout=,svd_u=,svd_s=,configds=,prefix=, outclusters=,hierds=,
26845     +                filterterms=,filtertmout=, descterms=);
26846     +
26847     +   %if ^%symexist(tm_debug) %then %let tm_debug=0;
26848     +
26849     +    proc sql noprint;
26850     +        select cellwgt into: cellwgt
26851     +            from &configds;
26852     +        select clus_alg into: algorithm
26853     +            from &configds;
26854     +        select parseVar into :textvar
26855     +            from &configds;
26856     +        select count(*) into :nclus
26857     +            from &clusters;
26858     +        select count(*) into :svdkeep
26859     +            from &svd_s
26860     +            where keep=1;
26861     +    quit;
26862     +
26863     +    %let svdkeep=%left(&svdkeep);
26864     +    %let nclus=%left(&nclus);
26865     +    %let algorithm=%left(&algorithm);
26866     +    %Let cellwgt=%left(&cellwgt);
26867     +    data _import_ds;
26868     +        set &import;
26869     +    run;
26870     +
26871     +
26872     +    %tmsort(data=&termds(where=(keep='Y')), out=_terms(keep= KEY PARENT),
26873     +            by=KEY);
26874     +    %tmsort(data=&_scrout, out=&_scrout, by=_termnum_);
26875     +
26876     +    data _svdm1;
26877     +        merge _terms (where=(PARENT ne _termnum_) in=_b_ keep=KEY PARENT rename=(KEY=_TERMNUM_))
26878     +              &_scrout (in = _A_ rename=(_COUNT_=COUNT));
26879     +        by _termnum_;
26880     +        if _B_;
26881     +        if (_A_ and _B_ and (PARENT ne .))
26882     +          then _TERMNUM_ = PARENT;
26883     +
26884     +        keep _TERMNUM_ _DOCUMENT_ COUNT;
26885     +        if (_DOCUMENT_=.) or (COUNT=.) then delete;
26886     +    run;
26887     +
26888     +    proc sql ;
26889     +       create table _scrout as select distinct _TERMNUM_, _DOCUMENT_,
26890     +        sum(COUNT) as _COUNT_ from _svdm1
26891     +        group by _TERMNUM_, _DOCUMENT_;
26892     +
26893     +       drop table _svdm1;
26894     +       drop table _terms;
26895     +    quit;
26896     +
26897     +    %tmsort(data=&termds(where=(KEEP='Y' and PARENT=.)),
26898     +         out=_weights (rename=(KEY=INDEX WEIGHT=GWGT) keep=KEY WEIGHT),
26899     +         by=KEY, options=, threads=);
26900     +
26901     +
26902     +    %tmsort(data=_scrout, out=_scrout, by=_DOCUMENT_, options=, threads=);
26903     +      %let svdkeep=%left(&svdkeep);
26904     +      data &svd_u;
26905     +         set &svd_u(keep= index col1-col&svdkeep);
26906     +      run;
26907     +
26908     +      proc sql;
26909     +         create table  _inweights as
26910     +         select a.*
26911     +         from _weights a right join &svd_u b
26912     +         on a.index=b.index
26913     +         ;
26914     +       quit;
26915     +    %if %lowcase(&cellwgt) = bin %then %let cellwgt=BINARY;
26916     +    proc spsvd data=_scrout IN_U=&svd_u
26917     +        local = &cellwgt global = none in_global = _inweights ;
26918     +        row _TERMNUM_;
26919     +        col _DOCUMENT_;
26920     +        entry _COUNT_;
26921     +        output colpro=_COLPRO bigpro normcol prefix="&prefix._SVD";
26922     +    run;
26923     +    proc sort data=_import_ds;
26924     +    by _DOCUMENT_; run;
26925     +
26926     +    proc sort data=_colpro;
26927     +    by INDEX;
26928     +    run;
26929     +
26930     +    data &export;
26931     +        merge _import_ds (in=_C_ ) _colpro (rename=(INDEX=_DOCUMENT_));
26932     +        by _DOCUMENT_;
26933     +        if _C_;
26934     +    run;
26935     +
26936     +    data &export;
26937     +       set  &export;
26938     +       array svd_array &prefix._SVD1 - &prefix._SVD&svdkeep.;
26939     +       do i = 1 to dim(svd_array);
26940     +          if svd_array(i)=. then svd_array(i)=0;
26941     +       end;
26942     +       drop i;
26943     +    run;
26944     +
26945     +
26946     +    %tmsort(data=&export, out=, by=_document_, options=, threads=);
26947     +
26948     +    %if %left(&algorithm)=1.0 %then %do;
26949     +
26950     +        %tmemclus(data=&export,
26951     +            role=SCORE, clusters=&nclus,
26952     +            seed=&emoutstat,
26953     +            outstat=, out=&export,
26954     +            vars=%STR(&prefix._SVD1 - &prefix._SVD&SVDKEEP),
26955     +            cov=, iter=5, secclus=,
26956     +            seciter=, min=, method=, eps=.1, init=, print=,
26957     +            p=, outliers=, decvar=0,
26958     +            initstd=, dist=, secstd=, nobs=);
26959     +        run;
26960     +
26961     +        %tmpred(&export, &export, &nclus, type=, ignore=0,
26962     +                  freqDS=, compress=1);
26963     +
26964     +        data &export;
26965     +           set &export;
26966     +           rename prob1-prob&nClus = &prefix._prob1-&prefix._prob&nclus;
26967     +           rename _cluster_=&prefix._cluster_;
26968     +        run;
26969     +
26970     +        %if &outclusters ne %then %do;
26971     +              %let memloc = _tmmem;
26972     +              proc tmutil data=&_scrout key=&filterterms ;
26973     +                 control init memloc="&memloc" release;
26974     +                 output keeponly out=_outtmutil;
26975     +              run;
26976     +
26977     +              data _docdata;
26978     +                 set &export (rename=(&prefix._cluster_=cluster));
26979     +              run;
26980     +
26981     +              /* Recalculate desc terms */
26982     +              data _terms_;
26983     +               set &filterterms;
26984     +               by key _ispar;
26985     +               if first.key then
26986     +                output;
26987     +               else;
26988     +              run;
26989     +
26990     +              data _terms_;
26991     +               set _terms_;
26992     +               if _ispar='+' then
26993     +                  Term=_ispar || ' ' || term;
26994     +              run;
26995     +
26996     +             %tmsort(data=_outtmutil,
26997     +               out=_tmout_,
26998     +               by=_termnum_,
26999     +                  options=,
27000     +               threads=threads);
27001     +
27002     +
27003     +             data _tmout_;
27004     +               merge _tmout_ (in=_A_)
27005     +                  _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
27006     +               by _termnum_;
27007     +               if _A_;
27008     +             run;
27009     +
27010     +             data _docs_;
27011     +               set _docdata (rename=(cluster=_cluster_) keep=_document_ cluster);
27012     +               _SEGMNT_=_cluster_;
27013     +             run;
27014     +
27015     +             %tmterm1(DSN_TPARS=_tmout_,
27016     +              DSN_CLUS=_docs_,
27017     +              DSN_DESC=_desc_,
27018     +              N_DESC_TERMS=&descterms,
27019     +              N_CLUS=&nclus,
27020     +              top_freq=%eval(&descterms*2),
27021     +              key=);
27022     +
27023     +             %tmsort(data=_desc_,
27024     +               out=_desc_,
27025     +               by=_cluster_,
27026     +                  options=,
27027     +               threads=threads);
27028     +
27029     +             proc sql noprint;
27030     +               create table &outclusters as
27031     +                 select a.clus_desc, b.* from &outclusters b left join _desc_ a
27032     +                 on a._cluster_=b._cluster_;
27033     +             quit;
27034     +
27035     +       %end;
27036     +
27037     +    %end;
27038     +    %else %do;
27039     +
27040     +        data _clustermean;
27041     +            set &clusters(keep=_cluster_ _mean1-_mean&svdkeep. freq);
27042     +        run;
27043     +
27044     +        proc sql;
27045     +        create table _meandocs as
27046     +            select a.*, b.*
27047     +            from &export(keep=&prefix._SVD1 - &prefix._SVD&SVDKEEP _document_) a , _clustermean b;
27048     +        quit;
27049     +
27050     +
27051     +        proc sort data=_meandocs;
27052     +        by _document_;
27053     +        run;
27054     +
27055     +        %if (&syscc>4) %then %do;
27056     +            %let emexceptionstring=EMTOOL.INSUFFICIENTMEM;
27057     +            %goto end_tmc;
27058     +        %end;
27059     +
27060     +        %tmsort(data=_meandocs,out=,by=_document_);
27061     +
27062     +          data _docdata(drop=_mean1-_mean&svdkeep. j _CLUSTER_ _freq_ rename=(_cluster_=&prefix._cluster_ distance=&prefix._distance));
27063     +            set _meandocs;
27064     +            drop _minDist_ _dist_ j freq;
27065     +            label CLUSTER = 'Cluster ID';
27066     +            array _means(&svdkeep) _mean1-_mean&svdkeep.;
27067     +            array _cols(&svdkeep) &prefix._SVD1-&prefix._SVD&svdkeep.;
27068     +            by _document_;
27069     +            retain CLUSTER _mindist_;
27070     +            _dist_ = 0;
27071     +            /* innner product*/
27072     +            do j = 1 to &svdkeep;
27073     +                _dist_ = _dist_ + (_cols(j)-_means(j))*(_cols(j)-_means(j));
27074     +            end;
27075     +
27076     +            /* initialization*/
27077     +            if first._document_ then do;
27078     +                _minDist_ = _dist_;
27079     +                CLUSTER = _cluster_;
27080     +            end;
27081     +            /*optimization*/
27082     +            if (_dist_ < _minDist_) then do;
27083     +                _minDist_ = _dist_;
27084     +                CLUSTER = _cluster_;
27085     +            end;
27086     +            if last._document_ then do;
27087     +               output;
27088     +            end;
27089     +        run;
27090     +        proc sort data=_docdata;
27091     +           by _document_;
27092     +        proc sort data=&export;
27093     +           by _document_;
27094     +        run;
27095     +
27096     +        data &export;
27097     +           merge &export _docdata;
27098     +           by _document_;
27099     +           rename cluster=&prefix._cluster_;
27100     +        run;
27101     +    %end;
27102     +
27103     +    /* Reorder variables in exported data set */
27104     +    proc sql noprint;
27105     +        create table &export as
27106     +        select &textvar, &prefix._cluster_, *
27107     +        from &export;
27108     +    quit;
27109     +
27110     +
27111     +    %if &outclusters ne %then %do;
27112     +
27113     +        /* update freqencies in cluster table */
27114     +         proc freq data =_docdata ;
27115     +            tables cluster/out=_tempfreqtable;
27116     +         run;
27117     +
27118     +        proc sql noprint;
27119     +            create table &outclusters as
27120     +            select  a.*, b.count as freq, b.percent/100 as percent
27121     +            from &clusters (drop= freq percent _rmsstd_) a, _tempfreqtable b
27122     +           where a._cluster_=b.cluster;
27123     +
27124     +        quit;
27125     +
27126     +        %if %left(&algorithm)=2.0 %then %do;
27127     +
27128     +          proc sql noprint;
27129     +
27130     +             create table &hierds as select a.freq, b.*
27131     +                from &outclusters a right join &hierds b on a._cluster_=b._cluster_;
27132     +          quit;
27133     +
27134     +          /* Find descriptive terms for clusters & parents */
27135     +          filename temp catalog 'sashelp.emtxtext.tmgethierterms.source';
27136     +          %include temp;
27137     +          filename temp;
27138     +
27139     +          %tm_getHierTerms(hierds=&hierds,
27140     +                         docs=_docdata,
27141     +                         tmout=&filtertmout,
27142     +                         terms= &filterterms,
27143     +                         ndescterms=&descterms);
27144     +
27145     +          proc sql noprint;
27146     +             create table &outclusters as
27147     +                select a.clus_desc, b.* from &hierds a, &outclusters b
27148     +                where a._cluster_=b._cluster_;
27149     +
27150     +             update &hierds set freq=0 where clus_desc="" and _cluster_ ne 1;
27151     +          quit;
27152     +
27153     +          /* Add frequencies to ancestors */
27154     +          data _hd;
27155     +             set &hierds;
27156     +             cluster=_cluster_;
27157     +             drop _cluster_ parent;
27158     +          run;
27159     +
27160     +          %let empty=1;
27161     +
27162     +          %do %while (&empty);
27163     +
27164     +            proc sql noprint;
27165     +                update _hd set freq=
27166     +                    (select sum(freq) from &HIERDS
27167     +                    where parent=cluster)
27168     +                    where freq=. and cluster not in
27169     +                    (select parent from &hierds where freq=.);
27170     +                select count(*) into :empty from _hd
27171     +                    where freq=.;
27172     +                update &hierds set freq=(select freq from _hd where _cluster_=cluster);
27173     +            quit;
27174     +
27175     +          %end;
27176     +
27177     +          /* Set graphdesc variable for graph display */
27178     +          data &hierds(drop=plus pos sub);
27179     +            set &hierds;
27180     +            plus='';
27181     +            if substr(CLUS_DESC, 1, 1) = "+" then plus="+ ";
27182     +            if ktrim(clus_desc) ne "" then do;
27183     +              if(substr(CLUS_DESC, 1, 1)) = "'" then do;
27184     +                 pos = findc(CLUS_DESC, "'",2);
27185     +                 sub = substr(CLUS_DESC,1,pos);
27186     +              end;
27187     +              else sub = scan(CLUS_DESC, 1);
27188     +              graphdesc=_CLUSTER_ || ': ' || plus || sub;
27189     +            end;
27190     +            else graphdesc=_CLUSTER_;
27191     +          run;
27192     +        %end;
27193     +
27194     +         /*calculate residual for each doc */
27195     +
27196     +         proc sort data=_docdata (rename=(cluster=_cluster_));
27197     +            by _cluster_;
27198     +         run;
27199     +
27200     +         data _rmscalc;
27201     +            merge _docdata(in=inhere) &outclusters;
27202     +            array _means(&svdkeep) _mean1-_mean&svdkeep.;
27203     +            array _svds(&svdkeep) &prefixstring._SVD1 - &prefixstring._SVD&svdkeep.;
27204     +            by _cluster_;
27205     +            error=0;
27206     +            do i = 1 to &svdkeep;
27207     +               error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
27208     +            end;
27209     +
27210     +            drop i ;
27211     +         run;
27212     +
27213     +          /*calc standardized residual for clusters*/
27214     +         proc summary data=_rmscalc nway;
27215     +            class _cluster_;
27216     +            var error;
27217     +            output out=_meanerr mean=meane sum=sume;
27218     +         run;
27219     +
27220     +         data _rmsse;
27221     +            set _meanerr;
27222     +            /* original code divides by number of svd dims*/
27223     +            if _freq_ gt 1 then do;
27224     +              _rmsstd_=sqrt(sume/((_freq_-1)*(&svdkeep.)));
27225     +            end;
27226     +            else do;
27227     +              _rmsstd_=0;
27228     +            end;
27229     +            keep _cluster_  _rmsstd_;
27230     +         run;
27231     +
27232     +
27233     +         proc sql noprint;
27234     +           create table _clusstat2 as
27235     +           select a.*,b.*
27236     +           from &outclusters a left join _rmsse b
27237     +           on a._cluster_=b._cluster_;
27238     +
27239     +           create table &outclusters as
27240     +           select * from _clusstat2;
27241     +         quit;
27242     +
27243     +
27244     +    %end;
27245     +
27246     +
27247     +%end_tmc:
27248     +    %if &tm_debug =0  %then %do;
27249     +    proc sql noprint;
27250     +        drop table _weights;
27251     +        drop table _colpro;
27252     +        drop table _scrout;
27253     +        drop table _svdm1;
27254     +        drop table _inweights;
27255     +        drop table _clustermean;
27256     +        drop table _clusstat2;
27257     +        drop table _outtmutil;
27258     +        drop table _rmscalc;
27259     +        drop table _rmsse;
27260     +        drop table _meanerr;
27261     +        drop table _meandocs;
27262     +        drop table _import_ds;
27263     +        drop table _hd;
27264     +        drop table _terms_;
27265     +        drop table _docs_;
27266     +        drop table _tmout_;
27267     +        drop table _desc_;
27268     +        drop table _docdata;
27269     +    quit;
27270     +    %end;
27271     +
27272     +%mend tmc_doc_score;
27273     +
27274     +
27275     +
27276     +
27277     +
27278     +
27279     +
27280     +
27281     +
27282     +
27283     +
27284     +
27285     +
27286     +
27287     +
27288     +
27289     +
27290     +
27291     +
27292     +
27293     +
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmsvd.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMSVD.SOURCE입니다.
27295     + /*
27297     +  Macro:     tmsvd.sas
27298     +  Purpose:  Call proc spsvd with given defaults and parameters.
27299     +  Syntax:   %tmsvd(in,k=,global=,local=,row=,col=,entry=,scaleOp=,normOp=,
27300     +            in_global=,in_u=,in_s=,in_v=,u=,s=,v=,wgt=,wordPro=,
27301     +           colPro=, p=, tol=, gwgt=, mink=, maxk=, res=, remote=, compact=,bigpro=0);
27303     +  Required Parameters:  in     The data= data set.
27304     +  Optional Parameters:  k= The number of dimensions to reduce to
27305     +                   global=  The global weight to use, defaults to IDF.
27306     +                   local=  The local weight to use, defaults to BINARY.
27307     +                   row=   Column in the input data set that represents
27308     +                          the matrix row,
27309     +                       defaults to _termnum_.
27310     +            col=   Column in the input data set that represents
27311     +                          the matrix column,
27312     +                         defaults to _document_.
27313     +            entry= Column in the input data set that represents the
27314     +                          value in the
27315     +                         given row,column cell.  Defaults to _count_.
27316     +             scaleOp= Scale options: scalerow scalecol scaleall
27317     +            normOp=  Normalization options: normrow normcol normall
27318     +            in_global= The gwgt= output data set from a prior spsvd run.
27319     +                   in_u=  The u= output from a prior spsvd run.
27320     +                   in_s=  The s= output from a prior spsvd run.
27321     +                   in_v=  The v= output from a prior spsvd run.
27322     +                   u=     matrix U data set
27323     +                   s=     matrix S data set
27324     +                   v=     matrix V data set
27325     +                  wgt=   weighted input matrix data set
27326     +                  wordPro= projections of rows of A onto columns of V
27327     +                  colPro=  projection of columns of A onto columns of U
27328     +                  p=   number of iterations
27329     +                  tol= convergence tolerance
27330     +                   gwgt= global weights data set
27331     +                  mink=
27332     +                  maxk=
27333     +                  res=
27334     +                  remote= name of file
27336     +  History:
27337     +  2001/01/16 - Kevin Daly - Initial coding.
27338     +  2001/01/19 - Kevin Daly - Fixed so that when global=NONE and local=NONE,
27339     +             no gwgt data set
27340     +               is requested.  This was causing an error and the proc
27341     +              would terminate.
27342     +  2001/02/21 - Bill Wheeler - Allowd all options to be specified
27343     +  2001/05/14 - Bill Wheeler - Added version 9 options min_k, max_k, resolution
27344     +  2001/08/14 - Bill Wheeler - Added remote option
27345     +  2001/11/29 - Bill Wheeler - Updated for version 8 or 9
27346     +*/
27348     +%macro tmsvd(in,k=,global=,local=,row=,col=,entry=,scaleOp=,normOp=,
27349     +             in_global=, in_u=, in_s=, in_v=, u=, s=, v=,
27350     +             wgt=, wordPro=, colPro=, p=, tol=, gwgt=, mink=, maxk=, res=,
27351     +             remote=, compact=,bigpro= );
27353     +  %put;
27354     +  /* Defaults */
27355     +  %if &k ^= %then %let k = k = &k;
27356     +  %if &global ^= %then %let global = global = &global;
27357     +  %if %lowcase(&local) = bin %then %let local=BINARY;
27358     +  %if &local ^= %then %let local=local=&local;
27359     +  %if &row= %then %let row=_termnum_;
27360     +  %if &col= %then %let col=_document_;
27361     +  %if &entry= %then %let entry=_count_;
27362     +  %if &scaleOp ^= %then %let scaleOp = scaledoc;
27363     +  %if &normOp ^= %then %let normOp = normdoc;
27364     +  %if &compact ^= %then %let compact = compact;
27365     +  %else %let compact = ;
27367     +  %if &in_global ^= %then %let in_global = in_global=&in_global;
27368     +  %if &in_u ^= %then %let in_u = in_u=&in_u;
27369     +  %if &in_s ^= %then %let in_s = in_s=&in_s;
27370     +  %if &in_v ^= %then %let in_v = in_v=&in_v;
27371     +  %if ((&p ^= ) and (&p ^= .)) %then %let p = p=&p;
27372     +  %else %let p = ;
27373     +  %if ((&tol ^= ) and (&tol ^= .)) %then %let tol = tol=&tol;
27374     +  %else %let tol = ;
27376     +  %IF &SYSVER < 9 %THEN %DO;
27377     +    %IF &k = %THEN %DO;
27378     +      %IF &maxk ^= %THEN %LET k = k = &maxk;
27379     +      %ELSE %LET k = k = 100;
27380     +    %END;
27381     +    %LET mink = ;
27382     +    %LET maxk = ;
27383     +    %LET res = ;
27384     +    %LET remote = ;
27385     +    %LET compact = ;
27386     +  %END;
27389     +  %if &colPro ^= %then %let colPro = COLPRO=&colPro;
27390     +  %if &gwgt ^= %then %let gwgt = GWGT=&gwgt;
27391     +  %if &s ^= %then %let s = S=&s;
27392     +  %if &u ^= %then %let u = U=&u;
27393     +  %if &v ^= %then %let v = V=&v;
27394     +  %if &wordPro ^= %then %let wordPro = WORDPRO=&wordPro;
27395     +  %if &wgt ^= %then %let wgt = WGT=&wgt;
27396     +  %if (&mink ^=  ) and (&mink ^= .) %then %let mink = min_k = &mink;
27397     +  %else %let mink = ;
27398     +  %if &maxk ^= %then %let maxk = max_k = &maxk;
27399     +  %if &res ^= %then %let res = res = &res;
27400     +  proc sort data=&in; by &col;
27401     +  /* Run the proc */
27402     +  proc spsvd data=&in
27403     +      &mink
27404     +      &maxk
27405     +      &res
27406     +      &k &compact
27407     +    &local &global &in_global
27408     +    &in_u &in_s &in_v &p &tol;
27409     +    row &row; col &col; entry &entry;
27410     +      output &colPro &gwgt &normOp &scaleOp &s &u &v
27411     +           &wordPro &wgt &bigpro;
27412     +    &remote;
27413     +  run;
27415     +%mend tmsvd;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   filename temp catalog 'sashelp.emtext.tmfast.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMFAST.SOURCE입니다.
27416     + /*
27417     +
27418     +  Macro:   tmfast.sas
27419     +  Purpose: Call proc fastclus with given defaults and parameters.
27420     +  Syntax:  %tmfast(data=, clusters=, outstat=, vars=);
27421     +
27422     +  Required Parameters:  data=      The input data set.
27423     +                        clusters=  The maximum number of clusters
27424     +
27425     +  Optional Parameters:  vars=      Variables to be used
27426     +                        outstat=   The name of the OUTSTAT data set
27427     +                        outseed=   The name of the OUTSEED data set
27428     +
27429     +  Either outstat or outseed mut be given, but not both.
27430     +  History:
27431     +  2001/01/16 - Bill Wheeler - Initial Coding.
27432     +
27433     +*/
27434     +%MACRO tmfast(data=, clusters=, outstat=, outseed=,
27435     +                 id=, out=, vars=);
27436     + /* defaults */
27437     + %if (&id ne ) %then %let id = id &id;
27438     + %if (&out ne ) %then %let out = out = &out;
27439     + %if (&vars ne ) %then %let var = var &vars;
27440     + %else %let var = ;
27441     +
27442     + %if &outseed= %then
27443     + %do;
27444     +   proc fastclus data = &data
27445     +   maxclusters = &clusters noprint
27446     +   outstat = &outstat &out;
27447     +   &var;
27448     +   &id;
27449     + %end;
27450     + %else
27451     + %do;
27452     +   proc fastclus data = &data
27453     +   maxclusters = &clusters noprint
27454     +   outseed = &outseed &out;
27455     +   &var;
27456     +   &id;
27457     + %end;
27458     +%MEND tmfast;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(SCORE):   proc sql noprint;
MPRINT(SCORE):   select count(*) into :svdkeep from EMWS5.TextCluster6_svd_s where keep=1;
MPRINT(SCORE):   create table _clusterms as select key, term, role, keep, freq, numdocs, parent, _ispar, weight from EMWS5.TextCluster6_terms;
NOTE: Table WORK._CLUSTERMS created, with 1144 rows and 9 columns.

NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(SCORE):   data _filter_tmout;
MPRINT(SCORE):   set EMWS5.TextFilter6_tmout;
MPRINT(SCORE):   run;

NOTE: 3289개의 관측값을 데이터셋 EMWS5.TEXTFILTER6_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._FILTER_TMOUT은(는) 3289개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   select cellwgt into: cellwgt from EMWS5.TextCluster6_tmconfig;
MPRINT(TMC_DOC_SCORE):   select clus_alg into: algorithm from EMWS5.TextCluster6_tmconfig;
MPRINT(TMC_DOC_SCORE):   select parseVar into :textvar from EMWS5.TextCluster6_tmconfig;
MPRINT(TMC_DOC_SCORE):   select count(*) into :nclus from EMWS5.TextCluster6_clusters;
MPRINT(TMC_DOC_SCORE):   select count(*) into :svdkeep from EMWS5.TextCluster6_svd_s where keep=1;
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TMC_DOC_SCORE):   data _import_ds;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextFilter6_TRAIN;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTPARSING6_TRAIN.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTFILTER6_DOC_IDS.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTFILTER6_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 WORK._IMPORT_DS은(는) 500개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.12 초
      cpu 시간            0.15 초
      

MPRINT(TMSORT):   proc sort data = _clusterms(where=(keep='Y')) THREADS out = _terms(keep= KEY PARENT);
MPRINT(TMSORT):   by KEY;
MPRINT(TMSORT):   run;

NOTE: 입력 데이터셋이 이미 정렬되어 있습니다; 출력 데이터셋에 복사되었습니다.
NOTE: 1144개의 관측값을 데이터셋 WORK._CLUSTERMS.에서 읽었습니다.
      WHERE keep='Y';
NOTE: 데이터셋 WORK._TERMS은(는) 1144개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMSORT):   proc sort data = _filter_tmout THREADS out = _filter_tmout;
MPRINT(TMSORT):   by _termnum_;
MPRINT(TMSORT):   run;

NOTE: 3289개의 관측값을 데이터셋 WORK._FILTER_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._FILTER_TMOUT은(는) 3289개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
      

MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data _svdm1;
MPRINT(TMC_DOC_SCORE):   merge _terms (where=(PARENT ne _termnum_) in=_b_ keep=KEY PARENT rename=(KEY=_TERMNUM_)) _filter_tmout (in = _A_ rename=(_COUNT_=COUNT));
MPRINT(TMC_DOC_SCORE):   by _termnum_;
MPRINT(TMC_DOC_SCORE):   if _B_;
MPRINT(TMC_DOC_SCORE):   if (_A_ and _B_ and (PARENT ne .)) then _TERMNUM_ = PARENT;
MPRINT(TMC_DOC_SCORE):   keep _TERMNUM_ _DOCUMENT_ COUNT;
MPRINT(TMC_DOC_SCORE):   if (_DOCUMENT_=.) or (COUNT=.) then delete;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 1144개의 관측값을 데이터셋 WORK._TERMS.에서 읽었습니다.
      WHERE PARENT not = _termnum_;
NOTE: 3289개의 관측값을 데이터셋 WORK._FILTER_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._SVDM1은(는) 3289개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TMC_DOC_SCORE):   proc sql ;
MPRINT(TMC_DOC_SCORE):   create table _scrout as select distinct _TERMNUM_, _DOCUMENT_, sum(COUNT) as _COUNT_ from _svdm1 group by _TERMNUM_, _DOCUMENT_;
NOTE: Table WORK._SCROUT created, with 3289 rows and 3 columns.

MPRINT(TMC_DOC_SCORE):   drop table _svdm1;
NOTE: 테이블 WORK._SVDM1 을(를) 삭제했습니다.
MPRINT(TMC_DOC_SCORE):   drop table _terms;
NOTE: 테이블 WORK._TERMS 을(를) 삭제했습니다.
MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
      

MPRINT(TMSORT):   proc sort data = _clusterms(where=(KEEP='Y' and PARENT=.)) out = _weights (rename=(KEY=INDEX WEIGHT=GWGT) keep=KEY WEIGHT);
MPRINT(TMSORT):   by KEY;
MPRINT(TMSORT):   run;

NOTE: 입력 데이터셋이 이미 정렬되어 있습니다; 출력 데이터셋에 복사되었습니다.
NOTE: 1144개의 관측값을 데이터셋 WORK._CLUSTERMS.에서 읽었습니다.
      WHERE (KEEP='Y') and (PARENT=.);
NOTE: 데이터셋 WORK._WEIGHTS은(는) 1144개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMSORT):   proc sort data = _scrout out = _scrout;
MPRINT(TMSORT):   by _DOCUMENT_;
MPRINT(TMSORT):   run;

NOTE: 3289개의 관측값을 데이터셋 WORK._SCROUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._SCROUT은(는) 3289개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster6_svd_u;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster6_svd_u(keep= index col1-col44);
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 436개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_SVD_U.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER6_SVD_U은(는) 436개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TMC_DOC_SCORE):   proc sql;
MPRINT(TMC_DOC_SCORE):   create table _inweights as select a.* from _weights a right join EMWS5.TextCluster6_svd_u b on a.index=b.index ;
NOTE: Table WORK._INWEIGHTS created, with 436 rows and 2 columns.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):   proc spsvd data=_scrout IN_U=EMWS5.TextCluster6_svd_u local = LOG global = none in_global = _inweights ;
MPRINT(TMC_DOC_SCORE):   row _TERMNUM_;
MPRINT(TMC_DOC_SCORE):   col _DOCUMENT_;
MPRINT(TMC_DOC_SCORE):   entry _COUNT_;
MPRINT(TMC_DOC_SCORE):   output colpro=_COLPRO bigpro normcol prefix="TextCluster6_SVD";
MPRINT(TMC_DOC_SCORE):   run;

WARNING: There are entries to be projected that are not on the IN_U dataset.
NOTE: 3289개의 관측값을 데이터셋 WORK._SCROUT.에서 읽었습니다.
NOTE: 436개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_SVD_U.에서 읽었습니다.
NOTE: 436개의 관측값을 데이터셋 WORK._INWEIGHTS.에서 읽었습니다.
NOTE: 데이터셋 WORK._COLPRO은(는) 439개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: 프로시저 SPSVD 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):   proc sort data=_import_ds;
MPRINT(TMC_DOC_SCORE):   by _DOCUMENT_;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._IMPORT_DS.에서 읽었습니다.
NOTE: 데이터셋 WORK._IMPORT_DS은(는) 500개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMC_DOC_SCORE):   proc sort data=_colpro;
MPRINT(TMC_DOC_SCORE):   by INDEX;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 439개의 관측값을 데이터셋 WORK._COLPRO.에서 읽었습니다.
NOTE: 데이터셋 WORK._COLPRO은(는) 439개의 관측값과 45개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster6_TRAIN;
MPRINT(TMC_DOC_SCORE):   merge _import_ds (in=_C_ ) _colpro (rename=(INDEX=_DOCUMENT_));
MPRINT(TMC_DOC_SCORE):   by _DOCUMENT_;
MPRINT(TMC_DOC_SCORE):   if _C_;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._IMPORT_DS.에서 읽었습니다.
NOTE: 439개의 관측값을 데이터셋 WORK._COLPRO.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER6_TRAIN은(는) 500개의 관측값과 47개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster6_TRAIN;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster6_TRAIN;
MPRINT(TMC_DOC_SCORE):   array svd_array TextCluster6_SVD1 - TextCluster6_SVD44;
MPRINT(TMC_DOC_SCORE):   do i = 1 to dim(svd_array);
MPRINT(TMC_DOC_SCORE):   if svd_array(i)=. then svd_array(i)=0;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   drop i;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER6_TRAIN은(는) 500개의 관측값과 47개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMSORT):   proc sort data = EMWS5.TextCluster6_TRAIN ;
MPRINT(TMSORT):   by _document_;
MPRINT(TMSORT):   run;

NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_TRAIN.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER6_TRAIN은(는) 500개의 관측값과 47개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data _clustermean;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster6_clusters(keep=_cluster_ _mean1-_mean44 freq);
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 15개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLUSTERMEAN은(는) 15개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):   proc sql;
MPRINT(TMC_DOC_SCORE):   create table _meandocs as select a.*, b.* from EMWS5.TextCluster6_TRAIN(keep=TextCluster6_SVD1 - TextCluster6_SVD44 _document_) a , _clustermean b;
NOTE: The execution of this query involves performing one or more Cartesian product joins that can not be optimized.
NOTE: Table WORK._MEANDOCS created, with 7500 rows and 91 columns.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
      

MPRINT(TMC_DOC_SCORE):   proc sort data=_meandocs;
MPRINT(TMC_DOC_SCORE):   by _document_;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 7500개의 관측값을 데이터셋 WORK._MEANDOCS.에서 읽었습니다.
NOTE: 데이터셋 WORK._MEANDOCS은(는) 7500개의 관측값과 91개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
      

MPRINT(TMSORT):   proc sort data = _meandocs THREADS ;
MPRINT(TMSORT):   by _document_;
MPRINT(TMSORT):   run;

NOTE: 입력 데이터셋이 이미 정렬되어 있어서, 정렬을 실행하지 않았습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
      

MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   data _docdata(drop=_mean1-_mean44 j _CLUSTER_ _freq_ rename=(_cluster_=TextCluster6_cluster_ distance=TextCluster6_distance));
MPRINT(TMC_DOC_SCORE):   set _meandocs;
MPRINT(TMC_DOC_SCORE):   drop _minDist_ _dist_ j freq;
MPRINT(TMC_DOC_SCORE):   label CLUSTER = 'Cluster ID';
MPRINT(TMC_DOC_SCORE):   array _means(44) _mean1-_mean44;
MPRINT(TMC_DOC_SCORE):   array _cols(44) TextCluster6_SVD1-TextCluster6_SVD44;
MPRINT(TMC_DOC_SCORE):   by _document_;
MPRINT(TMC_DOC_SCORE):   retain CLUSTER _mindist_;
MPRINT(TMC_DOC_SCORE):   _dist_ = 0;
MPRINT(TMC_DOC_SCORE):   do j = 1 to 44;
MPRINT(TMC_DOC_SCORE):   _dist_ = _dist_ + (_cols(j)-_means(j))*(_cols(j)-_means(j));
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   if first._document_ then do;
MPRINT(TMC_DOC_SCORE):   _minDist_ = _dist_;
MPRINT(TMC_DOC_SCORE):   CLUSTER = _cluster_;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   if (_dist_ < _minDist_) then do;
MPRINT(TMC_DOC_SCORE):   _minDist_ = _dist_;
MPRINT(TMC_DOC_SCORE):   CLUSTER = _cluster_;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   if last._document_ then do;
MPRINT(TMC_DOC_SCORE):   output;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   run;

WARNING: DROP, KEEP 또는 RENAME의 변수 j은(는) 참조되지 않습니다.
WARNING: DROP, KEEP 또는 RENAME의 변수 _freq_은(는) 참조되지 않습니다.
WARNING: DROP, KEEP 또는 RENAME의 변수 _cluster_은(는) 참조되지 않습니다.
WARNING: DROP, KEEP 또는 RENAME의 변수 distance은(는) 참조되지 않습니다.
NOTE: 7500개의 관측값을 데이터셋 WORK._MEANDOCS.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCDATA은(는) 500개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.07 초
      

MPRINT(TMC_DOC_SCORE):   proc sort data=_docdata;
MPRINT(TMC_DOC_SCORE):   by _document_;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCDATA은(는) 500개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TMC_DOC_SCORE):   proc sort data=EMWS5.TextCluster6_TRAIN;
MPRINT(TMC_DOC_SCORE):   by _document_;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 입력 데이터셋이 이미 정렬되어 있어서, 정렬을 실행하지 않았습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
      

MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster6_TRAIN;
MPRINT(TMC_DOC_SCORE):   merge EMWS5.TextCluster6_TRAIN _docdata;
MPRINT(TMC_DOC_SCORE):   by _document_;
MPRINT(TMC_DOC_SCORE):   rename cluster=TextCluster6_cluster_;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 500개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_TRAIN.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER6_TRAIN은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster6_TRAIN as select review , TextCluster6_cluster_, * from EMWS5.TextCluster6_TRAIN;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 Review이(가) 파일 EMWS5.TEXTCLUSTER6_TRAIN에 이미 존재합니다.
WARNING: 변수 TextCluster6_cluster_이(가) 파일 EMWS5.TEXTCLUSTER6_TRAIN에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER6_TRAIN created, with 500 rows and 48 columns.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TMC_DOC_SCORE):   proc freq data =_docdata ;
MPRINT(TMC_DOC_SCORE):   tables cluster/out=_tempfreqtable;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._TEMPFREQTABLE은(는) 15개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 출력 결과 (프로시저: FREQ, 페이지: 2)
NOTE: 프로시저 FREQ 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster6_clusters as select a.*, b.count as freq, b.percent/100 as percent from EMWS5.TextCluster6_clusters (drop= freq percent _rmsstd_) a, _tempfreqtable b where a._cluster_=b.cluster;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS5.TEXTCLUSTER6_CLUSTERS created, with 15 rows and 48 columns.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster6_hierds as select a.freq, b.* from EMWS5.TextCluster6_clusters a right join EMWS5.TextCluster6_hierds b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 Freq이(가) 파일 EMWS5.TEXTCLUSTER6_HIERDS에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER6_HIERDS created, with 31 rows and 6 columns.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):   filename temp catalog 'sashelp.emtxtext.tmgethierterms.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTXTEXT.TMGETHIERTERMS.SOURCE입니다.
27459     +%macro tm_getHierTerms(hierds=,docs=,tmout=,terms=,ndescterms=);
27460     +
27461     +      filename temp catalog 'sashelp.emtext.tmterm1.source';
27462     +      %include temp;
27463     +      filename temp catalog 'sashelp.emtext.tmsort.source';
27464     +      %include temp;
27465     +      filename temp;
27466     +
27467     +      data _terms_;
27468     +       set &terms;
27469     +       by key _ispar;
27470     +       if first.key then
27471     +          output;
27472     +       else;
27473     +    run;
27474     +
27475     +    /* Concatenate + to terms */
27476     +    data _terms_;
27477     +        set _terms_;
27478     +        if _ispar='+' then
27479     +            Term=_ispar || ' ' || term;
27480     +    run;
27481     +
27482     +    %tmsort(data=&tmout,
27483     +         out=_tmout_,
27484     +         by=_termnum_,
27485     +            options=,
27486     +         threads=threads);
27487     +
27488     +
27489     +    data _tmout_;
27490     +      merge _tmout_ (in=_A_)
27491     +            _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
27492     +      by _termnum_;
27493     +      if _A_;
27494     +    run;
27495     +
27496     +
27497     +      data &hierds;
27498     +            set &hierds (drop=clus_desc);
27499     +            length clus_desc $2000;
27500     +            clus_desc="";
27501     +      run;
27502     +
27503     +      data _hierds; set &hierds; run;
27504     +
27505     +      /* initialize tables to create table of ancestors */
27506     +      proc sql noprint;
27507     +            select max(level) into :level from _hierds;
27508     +            create table _ancestors as select _cluster_, parent, parent as ancestor,
27509     +                  parent as newclus from _hierds;
27510     +            create table _hierds as select a.*, newclus from _hierds a, _ancestors b
27511     +                  where a._cluster_=b._cluster_;
27512     +
27513     +            alter table _ancestors add tlevel int;
27514     +            update _ancestors set tlevel=(select level from &hierds a where
27515     +                a._cluster_=ancestor);
27516     +      quit;
27517     +
27518     +      %let nottop=1;
27519     +
27520     +      /* create ancestors table, one record for each ancestor of a cluster */
27521     +      %do %while (&nottop);
27522     +            proc sql noprint;
27523     +                  create table _ancestors2 as select a._cluster_, a.parent,
27524     +                  b.parent as ancestor, b.parent as newcluster,
27525     +                  (select level from &hierds c where c._cluster_=b.parent) as tlevel
27526     +                  from _hierds a, _hierds b where a.newclus=b._cluster_;
27527     +
27528     +                  select count(*) into :nottop from _ancestors2;
27529     +
27530     +                  create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level
27531     +                  from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
27532     +            quit;
27533     +
27534     +            data _ancestors (drop=newclus newcluster parent);
27535     +                  set _ancestors _ancestors2;
27536     +                  if ancestor ne .;
27537     +            run;
27538     +      %end;
27539     +
27540     +
27541     +      proc sql noprint;
27542     +           insert into _ancestors(_cluster_, ancestor, tlevel)
27543     +                select _cluster_, _cluster_, level
27544     +                from &hierds
27545     +                where freq ne .;
27546     +      quit;
27547     +
27548     +      proc sort data=_ancestors; by ancestor; run;
27549     +
27550     +      /* Find desc terms for each cluster */
27551     +      %do %while(&level ne 1);
27552     +
27553     +            data _docs_ ;
27554     +                  set &docs;
27555     +                  _SEGMNT_=.;
27556     +                  ancestor=.;
27557     +            run;
27558     +
27559     +            proc sql noprint;
27560     +                  create table _level as select _cluster_ as clust
27561     +                        from &hierds where level=&level;
27562     +
27563     +                  select count(*) into :nclus from _level;
27564     +
27565     +                  update _docs_ set ancestor=(select ancestor from _ancestors
27566     +                         where _cluster_=cluster and tlevel=&level);
27567     +
27568     +            quit;
27569     +
27570     +            data _level;
27571     +                  set _level;
27572     +                  segmnt=_n_;
27573     +            run;
27574     +
27575     +            proc sql noprint;
27576     +                  update _docs_ set _SEGMNT_=(select segmnt from _level where
27577     +                        clust=ancestor) where ancestor in (select clust from _level);
27578     +            quit;
27579     +
27580     +            data _docs_;
27581     +                set _docs_(rename=(cluster=_CLUSTER_));
27582     +            run;
27583     +
27584     +            %tmterm1(DSN_TPARS=_tmout_,
27585     +              DSN_CLUS=_docs_,
27586     +              DSN_DESC=_desc_,
27587     +              N_DESC_TERMS=&ndescterms,
27588     +              N_CLUS=&nclus,
27589     +              top_freq=%eval(&ndescterms*2),
27590     +              key=);
27591     +
27592     +            data _desc_(rename=(_CLUSTER_=clus));
27593     +                 set _desc_;
27594     +            run;
27595     +
27596     +            proc sql noprint;
27597     +                  update &hierds set clus_desc=(select clus_desc
27598     +                        from _desc_ where clus=(select segmnt
27599     +                        from _level where clust=_cluster_)) where _cluster_ in
27600     +                        (select clust from _level);
27601     +            quit;
27602     +
27603     +            %let level=%eval(&level-1);
27604     +      %end;
27605     +
27606     +%end_getdesc:
27607     +   %if &tm_debug =0 %then %do;
27608     +        proc sql noprint;
27609     +            drop table _ancestors;
27610     +            drop table _ancestors2;
27611     +            drop table _terms_;
27612     +            drop table _docs_;
27613     +            drop table _tmout_;
27614     +            drop table _desc_;
27615     +            drop table _hierds;
27616     +            drop table _level;
27617     +        quit;
27618     +    %end;
27619     +
27620     +%mend;
27621     +
27622     +
27623     +
27624     +
27625     +
27626     +
27627     +
27628     +
27629     +
27630     +
27631     +
27632     +
27633     +
27634     +
27635     +
27636     +
27637     +
27638     +
27639     +
27640     +
27641     +
27642     +
27643     +
27644     +
27645     +
27646     +
27647     +
27648     +
27649     +
27650     +
27651     +
27652     +
27653     +
27654     +
27655     +
27656     +
27657     +
27658     +
27659     +
27660     +
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TMC_DOC_SCORE):   filename temp;
NOTE: Fileref TEMP을(를) 삭제했습니다.
MPRINT(TM_GETHIERTERMS):   filename temp catalog 'sashelp.emtext.tmterm1.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMTERM1.SOURCE입니다.
27662     + %macro tmterm1( DSN_TPARS=
27663     +                        , DSN_CLUS=
27664     +                        , DSN_DESC=
27665     +                        , DSN_OUT=
27666     +                        , MIN_PROB=.5
27667     +                        , TOP_FREQ=20
27668     +                        , N_DESC_TERMS=5
27669     +                        , key=
27670     +                        , threads=THREADS
27671     +                        , N_CLUS=
27672     +                        , MIN_NUM=0
27673     +                        ) ;
27675     +   /* PURPOSE: compute &TOP_FREQ terms which represent
27676     +      descriptive drivers of particular cluster
27677     +    *
27678     +    * NOTE:    &MIN_PROB represents minimum CDF probability at which
27679     +         term is included in cluster
27680     +    *          terms failing this criterion will be set to blank to
27681     +         indicate missingness
27682     +    *
27683     +    *          test is made after all terms have been ranked and sorted by
27684     +           descending CDF value
27685     +    *
27686     +    * NOTE:    &TOP_FREQ terms, ranked by frequency,
27687     +       will be selected from each cluster
27688     +    *
27689     +    * EXAMPLE OF USE:
27690     +    *    libname DATALIB '.' ;
27691     +    *
27692     +    *    *** use PROC TPARS   to create dataset DATALIB.TPARS_OUT ***
27693     +    *    *** use PROC CLUSTER to create dataset DATALIB.CLUS_OUT  ***
27694     +    *
27695     +    *    %CLUSTERTERMDRIVER( DSN_TPARS=DATALIB.TPARS_OUT
27696     +    *                      , DSN_CLUS=DATALIB.CLUS_OUT
27697     +    *                      , DSN_DESC=DATALIB.CLUS_DESC
27698     +    *                      , DSN_OUT=DATALIB.TOP_FREQ_OUT
27699     +    *                      , MIN_PROB=.75
27700     +    *                      , TOP_FREQ=10
27701     +    *                      )
27702     +    */
27704     +   /*#################################################################*/
27705     +   /* begin executable statements
27706     +   /*##################################################################*/
27708     +   %local combined termfreq summary uniqterm clus_cdf clus_cdf_transp;
27709     +   %local format dsid nobs rc CLUSALL;
27712     +   %if &SYSVER < 9 %then %let threads = ;
27714     +   %LET combined = _CMB&key;
27715     +   %LET termfreq = _TFREQ&key;
27716     +   %LET summary = _SUM&key;
27717     +   %LET uniqterm = _UNQT&key;
27718     +   %LET clus_cdf = _CLCDF&key;
27719     +   %LET clus_cdf_transp = _CLCDFTR&key;
27721     +   /*====================================================================*/
27722     +   /* create view which joins cluster # to document # so each term has
27723     +      a cluster # and a document #
27724     +      rename '_segmnt_' to 'cluster'  */
27725     +   /*=====================================================================*/
27727     +   proc sql &threads;
27728     +      create view &combined as
27729     +      select t1.*, t2._segmnt_ as cluster
27730     +      from &DSN_TPARS t1, &DSN_CLUS t2
27731     +      where t1._document_ = t2._document_ ;
27732     +   quit ;
27735     +   /*=====================================================================*/
27736     +   /* compute frequency of occurrence of term per term per cluster
27737     +   /*=====================================================================*/
27739     +   proc summary data=&combined nway ;
27740     +      class cluster _term_ ;
27741     +      var _count_ ;
27742     +      output out=&termfreq sum=total ;
27743     +   run ;
27745     +   /*=======================================================================*/
27746     +   /* compute # of documents per cluster
27747     +   /* create _type_ variable for later use (proc summary)
27748     +   /*
27749     +   /* create macro vars containing # of documents for each cluster, CLUSIZEn
27750     +   /* create macro var containing # of documents for document corpus, CLUSALL
27751     +   /*=======================================================================*/
27753     +   proc summary data=&combined( keep= cluster _document_ ) ;
27754     +      class cluster ;
27755     +      var _document_ ;
27756     +      output out=&summary n=n ;
27757     +   run ;
27759     +   /************* bug fix ***************************/
27760     +   /*
27761     +   proc sql noprint &threads;
27762     +      select left( put( max(cluster), best. )) into :_NCLUS_ from &summary ;
27763     +   quit ;
27764     +   */
27766     +   %LET CLUSALL = 0;
27767     +   %DO I = 1 %TO &N_CLUS;
27768     +     %LET CLUSIZE&I = 0;
27769     +   %END;
27770     +   /*
27771     +   data _null_ ; set &summary;
27772     +     if (_N_ = 1) then do;
27773     +       do _i_ = 1 to &_NCLUS_;
27774     +         call symput( 'CLUSIZE' || left( put(_i_, best. )), 0) ;
27775     +       end;
27776     +     end;
27777     +     stop;
27778     +   run ;
27779     +   */
27780     +   /**************************************************/
27782     + data _null_ ;
27783     +  set &summary ;
27784     +  if _type_ = 1 then call
27785     +   symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
27786     +  else
27787     +    if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
27788     + run ;
27790     +   proc sql &threads; drop table &summary; quit;
27792     +   /*====================================================================*/
27793     +   /* sort dataset of term frequencies per cluster into
27794     +      descending frequency per cluster */
27795     +   /*===================================================================*/
27796     +   %tmsort(data=&termfreq, out=&termfreq, by=cluster descending _freq_,
27797     +         options=, threads=&threads);
27799     +   /*======================================================================*/
27800     +   /* select top N most-frequent terms per cluster
27801     +   /*
27802     +   /* remove duplicate terms in list of top N terms from each cluster
27803     +   /*=======================================================================*/
27805     +   data &uniqterm( keep= _term_ _freq_ cluster ) ;
27806     +      set &termfreq ;
27807     +      by cluster ;
27809     +      if first.cluster then n_term = 0 ;
27811     +      n_term + 1 ;
27813     +      if n_term le &TOP_FREQ ;
27814     +   run ;
27816     +   %tmsort(data=&uniqterm, out=&uniqterm( keep= _term_ ), by=_term_,
27817     +         options=nodupkey, threads=&threads);
27819     +   /*=======================================================================*/
27820     +   /* create table containing cluster, term,
27821     +      frequency of term for unique terms only   */
27822     +   /*=======================================================================*/
27824     +   proc sql &threads;
27825     +      create table &clus_cdf as
27826     +      select distinct cluster, _term_, _freq_
27827     +      from &termfreq
27828     +      where _term_ in ( select _term_ from &uniqterm )
27829     +      order by _term_, cluster
27830     +      ;
27831     +   quit ;
27833     +   proc sql &threads; drop table &uniqterm;
27834     +             drop table &termfreq;
27835     +   quit;
27838     +   /*==================================================================*/
27839     +   /* transpose cluster/term/frequency into term/cluster table
27840     +   /* where the observation per term has frequency of term per cluster
27841     +   /*=================================================================*/
27843     +   proc transpose data=&clus_cdf out=&clus_cdf prefix=clus ;
27844     +      by _term_ ;
27845     +      var _freq_ ;
27846     +      id cluster;  /* bug fix */
27847     +   run ;
27849     +   /*=====================================================================*/
27850     +   /* compute cumulative binomial CDF of each term based on its
27851     +     cumulative probability of proportion (presence) in each cluster */
27852     +   /*======================================================================*/
27853     +   /*
27854     +   proc sql noprint &threads;
27855     +      select left( put( max( _segmnt_ ), best. )) into :N_CLUS from &DSN_CLUS ;
27856     +   quit ;
27857     +   */
27859     +   data &clus_cdf ;
27860     +   length _term_ $100;
27861     +      array a_clus ( &N_CLUS ) 4 clus1 - clus&N_CLUS ;
27863     +      set &clus_cdf ;
27865     +      do _i_ = 1 to &N_CLUS ;
27866     +         if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
27867     +      end ;
27870     +      sumfreq = sum( of clus1 - clus&N_CLUS ) ;
27872     +      %do I=1 %to &N_CLUS ;
27873     +        if (clus&I = 0) or (clus&I < &MIN_NUM) then cdf&I = 0;
27874     +        else do;
27875     +          num = sumfreq - clus&I ;
27876     +          div = &CLUSALL - &&CLUSIZE&I;
27877     +          if div > 0 then do;
27878     +            propor = num/div;
27879     +            cdf&I  = CDF( 'binomial', clus&I , propor ,&&CLUSIZE&I ) ;
27880     +          end;
27881     +          else if num = 0 then cdf&I = 1;
27882     +          else cdf&I = 0;
27883     +        end;
27884     +      %end ;
27885     +      /* peel off the plus then put it back*/
27886     +      saveplus=0;
27887     +      if kindex(kleft(ktrim(_term_)),'+')=1 then do;
27888     +         saveplus=1;
27889     +          _term_ = ksubstr(kleft(ktrim(_term_)),3);
27890     +      end;
27891     +      if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
27892     +      else _term_ = kleft(ktrim(_term_)) || ' ';
27893     +      if saveplus=1 then do;
27894     +         _term_='+'||kleft(ktrim(_term_));
27895     +      end;
27896     +      drop _i_ propor sumfreq div num saveplus;
27897     +   run ;
27900     +   /*====================================================================*/
27901     +   /* transpose dataset to create dataset sortable by cluster #
27902     +   /*===================================================================*/
27904     +   data &clus_cdf_transp ;
27905     +      array a_cdf  ( &N_CLUS ) cdf1 - cdf&N_CLUS ;
27906     +      array a_count  ( &N_CLUS ) clus1 - clus&N_CLUS ;
27907     +      length clus 4 ;
27908     +      set &clus_cdf ;
27909     +      keep _term_ cdf clus doc_count;
27910     +      do clus = 1 to &N_CLUS ;
27911     +         cdf = a_cdf( clus ) ;
27912     +         doc_count = a_count( clus ) ;
27913     +         if cdf > 0 then output ;
27914     +      end ;
27915     +   run ;
27918     +   /*====================================================================*/
27919     +   /* sort dataset by term, cumulative binomial CDF within term
27920     +   /* if two cdf values are =, sort by doc_count then by  _term_ alphabetically
27921     +   /*====================================================================*/
27923     +   proc sql &threads; drop table &clus_cdf; quit;
27926     +   %tmsort(data=&clus_cdf_transp, out=&clus_cdf_transp,
27927     +      by= clus descending cdf descending doc_count _term_, options=, threads=&threads);
27929     +   %LET format = %EVAL(30*&N_DESC_TERMS);
27930     +   %LET dsid = %sysfunc(open(&clus_cdf_transp));
27931     +   %LET nobs= %sysfunc(attrn(&dsid,nobs));
27932     +   %LET rc = %sysfunc(close(&dsid));
27934     +   data &DSN_DESC; set &clus_cdf_transp (rename=(clus=cluster));
27935     +   format clus_desc $&format..;
27936     +   retain oldclus 0 clus_desc '' count 0;
27937     +   keep _CLUSTER_ clus_desc ;
27939     +   if _N_ = 1 then do;
27940     +     oldclus = cluster;
27941     +     count = 1;
27942     +   end;
27944     +   if (count <= &N_DESC_TERMS) and (cluster = oldclus) then do;
27946     +     if (_N_ = 1) then clus_desc = left(trim(_term_));
27947     +     else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
27948     +     count = count + 1;
27949     +     if (_N_ = &nobs) then do;
27950     +       _CLUSTER_ = oldclus;
27951     +       clus_desc = left(trim(clus_desc));
27952     +       /* no longer comma to chop off*/
27953     +       /*clus_desc = substr(clus_desc, 1, max(length(clus_desc)-1,1));*/
27954     +       output;
27955     +     end;
27956     +     else delete;
27958     +   end;
27959     +   else if (count > &N_DESC_TERMS) and (cluster = oldclus) then do;
27960     +     if (_N_ = &nobs) then do;
27961     +       _CLUSTER_ = oldclus;
27962     +       clus_desc = left(trim(clus_desc));
27963     +       /* no longer comma to chop off*/
27964     +       /*clus_desc = substr(clus_desc, 1, max(length(clus_desc)-1,1));*/
27965     +       output;
27966     +     end;
27967     +     else delete;
27968     +   end;
27969     +   else do;
27970     +     _CLUSTER_ = oldclus;
27971     +     oldclus = cluster;
27972     +     clus_desc = left(trim(clus_desc));
27973     +     /* no longer comma to chop off*/
27974     +     /*clus_desc = substr(clus_desc, 1, max(length(clus_desc)-1,1));*/
27975     +     output;
27976     +     count = 2;
27977     +     clus_desc = left(trim(_term_));
27978     +     if (_N_ = &nobs) then do;
27979     +       _CLUSTER_ = oldclus;
27980     +       clus_desc = left(trim(clus_desc));
27981     +       /* no longer comma to chop off*/
27982     +       /*clus_desc = substr(clus_desc, 1, max(length(clus_desc)-1,1));*/
27983     +         output;
27984     +     end;
27985     +   end;
27986     +    run;
27988     +   /* delete data sets */
27990     +   proc sql &threads;
27991     +       drop table &clus_cdf_transp;
27992     +       drop view &combined;
27993     +   quit;
27996     +%mend tmterm1 ;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_GETHIERTERMS):   filename temp catalog 'sashelp.emtext.tmsort.source';
NOTE: %INCLUDE(레벨 1) 파일 TEMP은(는) 파일 SASHELP.EMTEXT.TMSORT.SOURCE입니다.
27997     + /*
27998     +PROC SORT macro
27999     +
28000     +%tmsort(data=, out=, by=);
28001     +
28002     +data=      - name of input data set (outtree data set from PROC CLUSTER)
28003     +out=       - name of the output data set
28004     +by=        - by statement
28005     +options=   - proc options
28006     +*/
28007     +
28008     +%macro tmsort(data=, out=, by=, options=, threads=THREADS);
28009     +  %if %BQUOTE(&out) ^= %then %let out = out =  &out;
28010     +  %if &SYSVER < 9 %then %let threads = ;
28011     +
28012     +  proc sort data = %STR(&data) &threads &options
28013     +    &out;
28014     +    by &by;
28015     +  run;
28016     +
28017     +%mend tmsort;
NOTE: %INCLUDE(레벨 1)를 종료 중입니다.
MPRINT(TM_GETHIERTERMS):   filename temp;
NOTE: Fileref TEMP을(를) 삭제했습니다.
MPRINT(TM_GETHIERTERMS):   data _terms_;
MPRINT(TM_GETHIERTERMS):   set EMWS5.TextFilter6_terms;
MPRINT(TM_GETHIERTERMS):   by key _ispar;
MPRINT(TM_GETHIERTERMS):   if first.key then output;
MPRINT(TM_GETHIERTERMS):   else;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 1144개의 관측값을 데이터셋 EMWS5.TEXTFILTER6_TERMS_DATA.에서 읽었습니다.
      WHERE KEEP='Y';
NOTE: 1145개의 관측값을 데이터셋 EMWS5.TEXTFILTER6_TERM_STRINGS.에서 읽었습니다.
NOTE: 1144개의 관측값을 데이터셋 EMWS5.TEXTFILTER6_TERMS.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 1144개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.13 초
      cpu 시간            0.17 초
      

MPRINT(TM_GETHIERTERMS):   data _terms_;
MPRINT(TM_GETHIERTERMS):   set _terms_;
MPRINT(TM_GETHIERTERMS):   if _ispar='+' then Term=_ispar || ' ' || term;
MPRINT(TM_GETHIERTERMS):   run;
NOTE: 1144개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TERMS_은(는) 1144개의 관측값과 13개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMSORT):   proc sort data = EMWS5.TextFilter6_tmout threads out = _tmout_;
MPRINT(TMSORT):   by _termnum_;
MPRINT(TMSORT):   run;

NOTE: 3289개의 관측값을 데이터셋 EMWS5.TEXTFILTER6_TMOUT.에서 읽었습니다.
NOTE: 데이터셋 WORK._TMOUT_은(는) 3289개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _tmout_;
MPRINT(TM_GETHIERTERMS):   merge _tmout_ (in=_A_) _terms_ (rename=(key=_termnum_ term=_term_) keep=key term );
MPRINT(TM_GETHIERTERMS):   by _termnum_;
MPRINT(TM_GETHIERTERMS):   if _A_;
MPRINT(TM_GETHIERTERMS):   run;
NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 1144개의 관측값을 데이터셋 WORK._TERMS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._TMOUT_은(는) 3289개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   data EMWS5.TextCluster6_hierds;
MPRINT(TM_GETHIERTERMS):   set EMWS5.TextCluster6_hierds (drop=clus_desc);
MPRINT(TM_GETHIERTERMS):   length clus_desc $2000;
MPRINT(TM_GETHIERTERMS):   clus_desc="";
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 31개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER6_HIERDS은(는) 31개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   data _hierds;
MPRINT(TM_GETHIERTERMS):   set EMWS5.TextCluster6_hierds;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 31개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 WORK._HIERDS은(는) 31개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   select max(level) into :level from _hierds;
MPRINT(TM_GETHIERTERMS):   create table _ancestors as select _cluster_, parent, parent as ancestor, parent as newclus from _hierds;
NOTE: Table WORK._ANCESTORS created, with 31 rows and 4 columns.

MPRINT(TM_GETHIERTERMS):   create table _hierds as select a.*, newclus from _hierds a, _ancestors b where a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 31 rows and 7 columns.

MPRINT(TM_GETHIERTERMS):   alter table _ancestors add tlevel int;
NOTE: Table WORK._ANCESTORS has been modified, with 5 columns.
MPRINT(TM_GETHIERTERMS):   update _ancestors set tlevel=(select level from EMWS5.TextCluster6_hierds a where a._cluster_=ancestor);
NOTE: 31 rows were updated in WORK._ANCESTORS.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.12 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster6_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where 
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 30 rows and 5 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 31 rows and 4 columns.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.10 초
      

MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 31개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 30개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 58개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster6_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where 
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 28 rows and 5 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 31 rows and 4 columns.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.23 초
      cpu 시간            0.09 초
      

MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;

WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 58개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 28개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 82개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster6_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where 
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 24 rows and 5 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 31 rows and 4 columns.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.11 초
      

MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;

WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 82개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 24개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 101개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster6_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where 
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 19 rows and 5 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 31 rows and 4 columns.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
      

MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;

WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 101개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 19개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 116개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster6_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where 
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 15 rows and 5 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 31 rows and 4 columns.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.10 초
      

MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;

WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 116개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 15개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 127개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster6_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where 
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 11 rows and 5 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 31 rows and 4 columns.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
      

MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;

WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 127개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 11개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 132개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster6_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where 
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 5 rows and 5 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 31 rows and 4 columns.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.09 초
      

MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;

WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 132개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 5개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 135개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster6_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where 
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 3 rows and 5 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 31 rows and 4 columns.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.09 초
      

MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;

WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 135개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 3개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 137개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster6_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where 
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 2 rows and 5 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 31 rows and 4 columns.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.10 초
      

MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;

WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 137개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 2개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 137개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _ancestors2 as select a._cluster_, a.parent, b.parent as ancestor, b.parent as newcluster, (select level from EMWS5.TextCluster6_hierds c where c._cluster_=b.parent) as tlevel from _hierds a, _hierds b where 
a.newclus=b._cluster_;
NOTE: Table WORK._ANCESTORS2 created, with 0 rows and 5 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nottop from _ancestors2;
MPRINT(TM_GETHIERTERMS):   create table _hierds as select a._cluster_, a.parent, b.newcluster as newclus, level from _hierds a left join _ancestors2 b on a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table WORK._HIERDS created, with 31 rows and 4 columns.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.15 초
      cpu 시간            0.12 초
      

MPRINT(TM_GETHIERTERMS):   data _ancestors (drop=newclus newcluster parent);
MPRINT(TM_GETHIERTERMS):   set _ancestors _ancestors2;
MPRINT(TM_GETHIERTERMS):   if ancestor ne .;
MPRINT(TM_GETHIERTERMS):   run;

WARNING: DROP, KEEP 또는 RENAME의 변수 newclus은(는) 참조되지 않습니다.
NOTE: 137개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 0개의 관측값을 데이터셋 WORK._ANCESTORS2.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 137개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   insert into _ancestors(_cluster_, ancestor, tlevel) select _cluster_, _cluster_, level from EMWS5.TextCluster6_hierds where freq ne .;
NOTE: 15 rows were inserted into WORK._ANCESTORS.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):   proc sort data=_ancestors;
MPRINT(TM_GETHIERTERMS):   by ancestor;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 152개의 관측값을 데이터셋 WORK._ANCESTORS.에서 읽었습니다.
NOTE: 데이터셋 WORK._ANCESTORS은(는) 152개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster6_hierds where level= 10;
NOTE: Table WORK._LEVEL created, with 2 rows and 1 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel= 10);
NOTE: 500 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.20 초
      cpu 시간            0.20 초
      

MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 2개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 94 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 228개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.09 초
      

MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 3개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;

NOTE: 3개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;

NOTE: 228개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 228개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.12 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;

NOTE: 228개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 60개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;

NOTE: 60개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 5개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 55개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 61 rows and 3 columns.

MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;

NOTE: 61개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 55개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 2 ) 4 clus1 - clus2 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 2 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus2 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 280 - 146;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 146 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 280 - 134;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 134 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;

NOTE: 55개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 55개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 2 ) cdf1 - cdf2 ;
MPRINT(TMTERM1):   array a_count ( 2 ) clus1 - clus2 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 2 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;

NOTE: 55개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 61개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;

NOTE: 61개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 61개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 61) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 61) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 61) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;

NOTE: 61개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 2개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster6_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 2 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster6_hierds where level=9;
NOTE: Table WORK._LEVEL created, with 1 rows and 1 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=9);
NOTE: 500 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.22 초
      cpu 시간            0.21 초
      

MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 1개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 1개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 94 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 218개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 2개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;

NOTE: 2개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;

NOTE: 218개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 218개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;

NOTE: 218개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 30개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;

NOTE: 30개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 0개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 30개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 30 rows and 3 columns.

MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;

NOTE: 30개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 30개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 1 ) 4 clus1 - clus1 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 1 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus1 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 280 - 280;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 280 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;

NOTE: 30개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 30개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 1 ) cdf1 - cdf1 ;
MPRINT(TMTERM1):   array a_count ( 1 ) clus1 - clus1 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 1 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;

NOTE: 30개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 30개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;

NOTE: 30개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 30개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 30) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 30) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 30) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;

NOTE: 30개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 1개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 1개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 1개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster6_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 1 row was updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster6_hierds where level=8;
NOTE: Table WORK._LEVEL created, with 2 rows and 1 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=8);
NOTE: 500 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.20 초
      cpu 시간            0.20 초
      

MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 2개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 113 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 305개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 3개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;

NOTE: 3개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;

NOTE: 305개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 305개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;

NOTE: 305개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 60개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;

NOTE: 60개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 10개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 50개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 64 rows and 3 columns.

MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;

NOTE: 64개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 50개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 2 ) 4 clus1 - clus2 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 2 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus2 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 431 - 280;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 280 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 431 - 151;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 151 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;

NOTE: 50개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 50개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 2 ) cdf1 - cdf2 ;
MPRINT(TMTERM1):   array a_count ( 2 ) clus1 - clus2 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 2 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;

NOTE: 50개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 64개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;

NOTE: 64개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 64개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.10 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 64) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 64) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 64) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;

NOTE: 64개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 2개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster6_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 2 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster6_hierds where level=7;
NOTE: Table WORK._LEVEL created, with 6 rows and 1 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=7);
NOTE: 500 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.15 초
      cpu 시간            0.15 초
      

MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 6개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 279 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1120개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 7개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;

NOTE: 7개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;

NOTE: 1120개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1120개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;

NOTE: 1120개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 180개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;

NOTE: 180개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 48개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 132개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 302 rows and 3 columns.

MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;

NOTE: 302개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 132개의 관측값과 8개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 6 ) 4 clus1 - clus6 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 6 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus6 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 1724 - 431;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 431 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 1724 - 199;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 199 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 1724 - 314;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 314 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 1724 - 414;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 414 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus5 = 0) or (clus5 < 0) then cdf5 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus5 ;
MPRINT(TMTERM1):   div = 1724 - 266;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf5 = CDF( 'binomial', clus5 , propor , 266 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf5 = 1;
MPRINT(TMTERM1):   else cdf5 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus6 = 0) or (clus6 < 0) then cdf6 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus6 ;
MPRINT(TMTERM1):   div = 1724 - 100;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf6 = CDF( 'binomial', clus6 , propor , 100 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf6 = 1;
MPRINT(TMTERM1):   else cdf6 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;

NOTE: 132개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 132개의 관측값과 14개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.09 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 6 ) cdf1 - cdf6 ;
MPRINT(TMTERM1):   array a_count ( 6 ) clus1 - clus6 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 6 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;

NOTE: 132개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 302개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;

NOTE: 302개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 302개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.13 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 302) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 302) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 302) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;

NOTE: 302개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 6개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 6개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster6_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 6 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster6_hierds where level=6;
NOTE: Table WORK._LEVEL created, with 4 rows and 1 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=6);
NOTE: 500 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.12 초
      cpu 시간            0.12 초
      

MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 4개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 311 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1095개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 5개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;

NOTE: 5개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;

NOTE: 1095개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1095개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;

NOTE: 1095개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 120개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;

NOTE: 120개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 38개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 82개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 199 rows and 3 columns.

MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;

NOTE: 199개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 82개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 4 ) 4 clus1 - clus4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 4 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus4 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 1906 - 630;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 630 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 1906 - 680;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 680 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 1906 - 414;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 414 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 1906 - 182;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 182 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;

NOTE: 82개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 82개의 관측값과 10개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 4 ) cdf1 - cdf4 ;
MPRINT(TMTERM1):   array a_count ( 4 ) clus1 - clus4 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 4 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;

NOTE: 82개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 199개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;

NOTE: 199개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 199개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 199) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 199) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 199) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;

NOTE: 199개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 4개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster6_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 4 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster6_hierds where level=5;
NOTE: Table WORK._LEVEL created, with 4 rows and 1 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=5);
NOTE: 500 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.11 초
      

MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 4개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 379 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1323개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.09 초
      

MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 5개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;

SAS 시스템

NOTE: 5개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;

NOTE: 1323개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1323개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;

NOTE: 1323개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 120개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;

NOTE: 120개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 43개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 77개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 201 rows and 3 columns.

MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;

NOTE: 201개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 77개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 4 ) 4 clus1 - clus4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 4 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus4 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 2512 - 1310;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 1310 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 2512 - 596;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 596 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 2512 - 395;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 395 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 2512 - 211;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 211 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;

NOTE: 77개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 77개의 관측값과 10개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 4 ) cdf1 - cdf4 ;
MPRINT(TMTERM1):   array a_count ( 4 ) clus1 - clus4 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 4 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;

NOTE: 77개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 201개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.00 초
      

MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;

NOTE: 201개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 201개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 201) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 201) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 201) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;

NOTE: 201개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 4개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster6_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 4 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.07 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster6_hierds where level=4;
NOTE: Table WORK._LEVEL created, with 5 rows and 1 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=4);
NOTE: 500 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.07 초
      

MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 5개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 5개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 464 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1529개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 6개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;

NOTE: 6개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;

NOTE: 1529개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1529개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;

NOTE: 1529개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 150개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;

NOTE: 150개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 53개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 97개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 270 rows and 3 columns.

MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;

NOTE: 270개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 97개의 관측값과 7개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 5 ) 4 clus1 - clus5 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 5 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus5 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 3077 - 1906;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 1906 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 3077 - 187;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 187 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 3077 - 191;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 191 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 3077 - 606;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 606 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus5 = 0) or (clus5 < 0) then cdf5 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus5 ;
MPRINT(TMTERM1):   div = 3077 - 187;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf5 = CDF( 'binomial', clus5 , propor , 187 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf5 = 1;
MPRINT(TMTERM1):   else cdf5 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;

NOTE: 97개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 97개의 관측값과 12개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 5 ) cdf1 - cdf5 ;
MPRINT(TMTERM1):   array a_count ( 5 ) clus1 - clus5 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 5 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;

NOTE: 97개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 270개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;

NOTE: 270개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 270개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 270) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 270) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 270) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;

NOTE: 270개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 5개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 5개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 5개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster6_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 5 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster6_hierds where level=3;
NOTE: Table WORK._LEVEL created, with 4 rows and 1 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=3);
NOTE: 500 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
      

MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 4개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 500 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1539개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.08 초
      cpu 시간            0.09 초
      

MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 5개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;

NOTE: 5개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;

NOTE: 1539개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1539개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.11 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;

NOTE: 1539개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 120개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;

NOTE: 120개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 42개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 78개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 221 rows and 3 columns.

MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;

NOTE: 221개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 78개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 4 ) 4 clus1 - clus4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 4 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus4 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 3289 - 2093;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 2093 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 3289 - 606;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 606 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus3 = 0) or (clus3 < 0) then cdf3 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus3 ;
MPRINT(TMTERM1):   div = 3289 - 378;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf3 = CDF( 'binomial', clus3 , propor , 378 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf3 = 1;
MPRINT(TMTERM1):   else cdf3 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus4 = 0) or (clus4 < 0) then cdf4 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus4 ;
MPRINT(TMTERM1):   div = 3289 - 212;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf4 = CDF( 'binomial', clus4 , propor , 212 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf4 = 1;
MPRINT(TMTERM1):   else cdf4 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;

NOTE: 78개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 78개의 관측값과 10개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 4 ) cdf1 - cdf4 ;
MPRINT(TMTERM1):   array a_count ( 4 ) clus1 - clus4 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 4 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;

NOTE: 78개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 221개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;

NOTE: 221개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 221개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 221) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 221) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 221) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;

NOTE: 221개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 4개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 4개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster6_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 4 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_ ;
MPRINT(TM_GETHIERTERMS):   set _docdata;
MPRINT(TM_GETHIERTERMS):   _SEGMNT_=.;
MPRINT(TM_GETHIERTERMS):   ancestor=.;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   create table _level as select _cluster_ as clust from EMWS5.TextCluster6_hierds where level=2;
NOTE: Table WORK._LEVEL created, with 2 rows and 1 columns.

MPRINT(TM_GETHIERTERMS):   select count(*) into :nclus from _level;
MPRINT(TM_GETHIERTERMS):   update _docs_ set ancestor=(select ancestor from _ancestors where _cluster_=cluster and tlevel=2);
NOTE: 500 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
      

MPRINT(TM_GETHIERTERMS):   data _level;
MPRINT(TM_GETHIERTERMS):   set _level;
MPRINT(TM_GETHIERTERMS):   segmnt=_n_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 2개의 관측값을 데이터셋 WORK._LEVEL.에서 읽었습니다.
NOTE: 데이터셋 WORK._LEVEL은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update _docs_ set _SEGMNT_=(select segmnt from _level where clust=ancestor) where ancestor in (select clust from _level);
NOTE: 500 rows were updated in WORK._DOCS_.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TM_GETHIERTERMS):   data _docs_;
MPRINT(TM_GETHIERTERMS):   set _docs_(rename=(cluster=_CLUSTER_));
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCS_은(는) 500개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create view _CMB as select t1.*, t2._segmnt_ as cluster from _tmout_ t1, _docs_ t2 where t1._document_ = t2._document_ ;
NOTE: SQL view WORK._CMB has been defined.
MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc summary data=_CMB nway ;
MPRINT(TMTERM1):   class cluster _term_ ;
MPRINT(TMTERM1):   var _count_ ;
MPRINT(TMTERM1):   output out=_TFREQ sum=total ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1314개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   proc summary data=_CMB( keep= cluster _document_ ) ;
MPRINT(TMTERM1):   class cluster ;
MPRINT(TMTERM1):   var _document_ ;
MPRINT(TMTERM1):   output out=_SUM n=n ;
MPRINT(TMTERM1):   run ;

NOTE: 3289개의 관측값을 데이터셋 WORK._TMOUT_.에서 읽었습니다.
NOTE: 500개의 관측값을 데이터셋 WORK._DOCS_.에서 읽었습니다.
NOTE: 3289개의 관측값을 데이터셋 WORK._CMB.에서 읽었습니다.
NOTE: 데이터셋 WORK._SUM은(는) 3개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):   data _null_ ;
MPRINT(TMTERM1):   set _SUM ;
MPRINT(TMTERM1):   if _type_ = 1 then call symput( 'CLUSIZE' || left( put( cluster, best. )), put( _freq_, best. ));
MPRINT(TMTERM1):   else if _type_ = 0 then call symput( 'CLUSALL', put( _freq_, best. )) ;
MPRINT(TMTERM1):   run ;

NOTE: 3개의 관측값을 데이터셋 WORK._SUM.에서 읽었습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _SUM;
NOTE: 테이블 WORK._SUM 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(TMSORT):   proc sort data = _TFREQ THREADS out = _TFREQ;
MPRINT(TMSORT):   by cluster descending _freq_;
MPRINT(TMSORT):   run;

NOTE: 1314개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._TFREQ은(는) 1314개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _UNQT( keep= _term_ _freq_ cluster ) ;
MPRINT(TMTERM1):   set _TFREQ ;
MPRINT(TMTERM1):   by cluster ;
MPRINT(TMTERM1):   if first.cluster then n_term = 0 ;
MPRINT(TMTERM1):   n_term + 1 ;
MPRINT(TMTERM1):   if n_term le 30 ;
MPRINT(TMTERM1):   run ;

NOTE: 1314개의 관측값을 데이터셋 WORK._TFREQ.에서 읽었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 60개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _UNQT THREADS nodupkey out = _UNQT( keep= _term_ );
MPRINT(TMSORT):   by _term_;
MPRINT(TMSORT):   run;

NOTE: 60개의 관측값을 데이터셋 WORK._UNQT.에서 읽었습니다.
NOTE: 중복 키값을 가지고 있는 17개의 관측값이 삭제되었습니다.
NOTE: 데이터셋 WORK._UNQT은(는) 43개의 관측값과 1개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.06 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   create table _CLCDF as select distinct cluster, _term_, _freq_ from _TFREQ where _term_ in ( select _term_ from _UNQT ) order by _term_, cluster ;
NOTE: Table WORK._CLCDF created, with 79 rows and 3 columns.

MPRINT(TMTERM1):   quit ;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _UNQT;
NOTE: 테이블 WORK._UNQT 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop table _TFREQ;
NOTE: 테이블 WORK._TFREQ 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMTERM1):   proc transpose data=_CLCDF out=_CLCDF prefix=clus ;
MPRINT(TMTERM1):   by _term_ ;
MPRINT(TMTERM1):   var _freq_ ;
MPRINT(TMTERM1):   id cluster;
MPRINT(TMTERM1):   run ;

NOTE: 79개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 43개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 TRANSPOSE 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   data _CLCDF ;
MPRINT(TMTERM1):   length _term_ $100;
MPRINT(TMTERM1):   array a_clus ( 2 ) 4 clus1 - clus2 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   do _i_ = 1 to 2 ;
MPRINT(TMTERM1):   if a_clus( _i_ ) = . then a_clus( _i_ ) = 0 ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   sumfreq = sum( of clus1 - clus2 ) ;
MPRINT(TMTERM1):   if (clus1 = 0) or (clus1 < 0) then cdf1 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus1 ;
MPRINT(TMTERM1):   div = 3289 - 2699;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf1 = CDF( 'binomial', clus1 , propor , 2699 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf1 = 1;
MPRINT(TMTERM1):   else cdf1 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (clus2 = 0) or (clus2 < 0) then cdf2 = 0;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   num = sumfreq - clus2 ;
MPRINT(TMTERM1):   div = 3289 - 590;
MPRINT(TMTERM1):   if div > 0 then do;
MPRINT(TMTERM1):   propor = num/div;
MPRINT(TMTERM1):   cdf2 = CDF( 'binomial', clus2 , propor , 590 ) ;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if num = 0 then cdf2 = 1;
MPRINT(TMTERM1):   else cdf2 = 0;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   saveplus=0;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),'+')=1 then do;
MPRINT(TMTERM1):   saveplus=1;
MPRINT(TMTERM1):   _term_ = ksubstr(kleft(ktrim(_term_)),3);
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if kindex(kleft(ktrim(_term_)),' ')>0 then _term_ = "'"||kleft(ktrim(_term_)) || "'  ";
MPRINT(TMTERM1):   else _term_ = kleft(ktrim(_term_)) || ' ';
MPRINT(TMTERM1):   if saveplus=1 then do;
MPRINT(TMTERM1):   _term_='+'||kleft(ktrim(_term_));
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   drop _i_ propor sumfreq div num saveplus;
MPRINT(TMTERM1):   run ;

NOTE: 43개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDF은(는) 43개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   data _CLCDFTR ;
MPRINT(TMTERM1):   array a_cdf ( 2 ) cdf1 - cdf2 ;
MPRINT(TMTERM1):   array a_count ( 2 ) clus1 - clus2 ;
MPRINT(TMTERM1):   length clus 4 ;
MPRINT(TMTERM1):   set _CLCDF ;
MPRINT(TMTERM1):   keep _term_ cdf clus doc_count;
MPRINT(TMTERM1):   do clus = 1 to 2 ;
MPRINT(TMTERM1):   cdf = a_cdf( clus ) ;
MPRINT(TMTERM1):   doc_count = a_count( clus ) ;
MPRINT(TMTERM1):   if cdf > 0 then output ;
MPRINT(TMTERM1):   end ;
MPRINT(TMTERM1):   run ;

NOTE: 43개의 관측값을 데이터셋 WORK._CLCDF.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 79개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDF;
NOTE: 테이블 WORK._CLCDF 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TMSORT):   proc sort data = _CLCDFTR THREADS out = _CLCDFTR;
MPRINT(TMSORT):   by clus descending cdf descending doc_count _term_;
MPRINT(TMSORT):   run;

NOTE: 79개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._CLCDFTR은(는) 79개의 관측값과 4개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.07 초
      

MPRINT(TMTERM1):  ;
MPRINT(TMTERM1):   data _desc_;
MPRINT(TMTERM1):   set _CLCDFTR (rename=(clus=cluster));
MPRINT(TMTERM1):   format clus_desc $450.;
MPRINT(TMTERM1):   retain oldclus 0 clus_desc '' count 0;
MPRINT(TMTERM1):   keep _CLUSTER_ clus_desc ;
MPRINT(TMTERM1):   if _N_ = 1 then do;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   count = 1;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   if (count <= 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 1) then clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   else clus_desc = kleft(trim(clus_desc)) || "  " || kleft(trim(_term_));
MPRINT(TMTERM1):   count = count + 1;
MPRINT(TMTERM1):   if (_N_ = 79) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else if (count > 15) and (cluster = oldclus) then do;
MPRINT(TMTERM1):   if (_N_ = 79) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else delete;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   else do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   oldclus = cluster;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   count = 2;
MPRINT(TMTERM1):   clus_desc = left(trim(_term_));
MPRINT(TMTERM1):   if (_N_ = 79) then do;
MPRINT(TMTERM1):   _CLUSTER_ = oldclus;
MPRINT(TMTERM1):   clus_desc = left(trim(clus_desc));
MPRINT(TMTERM1):   output;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   end;
MPRINT(TMTERM1):   run;

NOTE: 79개의 관측값을 데이터셋 WORK._CLCDFTR.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.04 초
      

MPRINT(TMTERM1):   proc sql THREADS;
MPRINT(TMTERM1):   drop table _CLCDFTR;
NOTE: 테이블 WORK._CLCDFTR 을(를) 삭제했습니다.
MPRINT(TMTERM1):   drop view _CMB;
NOTE: View WORK._CMB 을(를) 삭제했습니다.
MPRINT(TMTERM1):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(TM_GETHIERTERMS):  ;
MPRINT(TM_GETHIERTERMS):   data _desc_(rename=(_CLUSTER_=clus));
MPRINT(TM_GETHIERTERMS):   set _desc_;
MPRINT(TM_GETHIERTERMS):   run;

NOTE: 2개의 관측값을 데이터셋 WORK._DESC_.에서 읽었습니다.
NOTE: 데이터셋 WORK._DESC_은(는) 2개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TM_GETHIERTERMS):   proc sql noprint;
MPRINT(TM_GETHIERTERMS):   update EMWS5.TextCluster6_hierds set clus_desc=(select clus_desc from _desc_ where clus=(select segmnt from _level where clust=_cluster_)) where _cluster_ in (select clust from _level);
NOTE: 2 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TM_GETHIERTERMS):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
      

MPRINT(TMC_DOC_SCORE):  ;
MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster6_clusters as select a.clus_desc, b.* from EMWS5.TextCluster6_hierds a, EMWS5.TextCluster6_clusters b where a._cluster_=b._cluster_;
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
WARNING: 변수 clus_desc이(가) 파일 EMWS5.TEXTCLUSTER6_CLUSTERS에 이미 존재합니다.
NOTE: Table EMWS5.TEXTCLUSTER6_CLUSTERS created, with 15 rows and 48 columns.

MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster6_hierds set freq=0 where clus_desc="" and _cluster_ ne 1;
NOTE: No rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.04 초
      cpu 시간            0.04 초
      

MPRINT(TMC_DOC_SCORE):   data _hd;
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster6_hierds;
MPRINT(TMC_DOC_SCORE):   cluster=_cluster_;
MPRINT(TMC_DOC_SCORE):   drop _cluster_ parent;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 31개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 WORK._HD은(는) 31개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster6_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster6_hierds where freq=.);
NOTE: 5 rows were updated in WORK._HD.

MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster6_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 31 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.10 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster6_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster6_hierds where freq=.);
NOTE: 4 rows were updated in WORK._HD.

MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster6_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 31 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.10 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster6_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster6_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.

MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster6_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 31 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.12 초
      cpu 시간            0.12 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster6_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster6_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.

MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster6_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 31 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.12 초
      cpu 시간            0.12 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster6_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster6_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.

MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster6_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 31 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.11 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster6_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster6_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.

MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster6_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 31 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.11 초
      cpu 시간            0.12 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster6_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster6_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.

MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster6_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 31 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.10 초
      cpu 시간            0.09 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster6_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster6_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.

MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster6_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 31 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.12 초
      cpu 시간            0.12 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   update _hd set freq= (select sum(freq) from EMWS5.TextCluster6_hierds where parent=cluster) where freq=. and cluster not in (select parent from EMWS5.TextCluster6_hierds where freq=.);
NOTE: 1 row was updated in WORK._HD.

MPRINT(TMC_DOC_SCORE):   select count(*) into :empty from _hd where freq=.;
MPRINT(TMC_DOC_SCORE):   update EMWS5.TextCluster6_hierds set freq=(select freq from _hd where _cluster_=cluster);
NOTE: 31 rows were updated in EMWS5.TEXTCLUSTER6_HIERDS.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.12 초
      cpu 시간            0.12 초
      

MPRINT(TMC_DOC_SCORE):   data EMWS5.TextCluster6_hierds(drop=plus pos sub);
MPRINT(TMC_DOC_SCORE):   set EMWS5.TextCluster6_hierds;
MPRINT(TMC_DOC_SCORE):   plus='';
MPRINT(TMC_DOC_SCORE):   if substr(CLUS_DESC, 1, 1) = "+" then plus="+ ";
MPRINT(TMC_DOC_SCORE):   if ktrim(clus_desc) ne "" then do;
MPRINT(TMC_DOC_SCORE):   if(substr(CLUS_DESC, 1, 1)) = "'" then do;
MPRINT(TMC_DOC_SCORE):   pos = findc(CLUS_DESC, "'",2);
MPRINT(TMC_DOC_SCORE):   sub = substr(CLUS_DESC,1,pos);
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   else sub = scan(CLUS_DESC, 1);
MPRINT(TMC_DOC_SCORE):   graphdesc=_CLUSTER_ || ': ' || plus || sub;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   else graphdesc=_CLUSTER_;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 다음의 위치에서 숫자형 값이 문자형 값으로 변환되었습니다. (행):(칼럼)
      99:199   101:29   
NOTE: 31개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_HIERDS.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER6_HIERDS은(는) 31개의 관측값과 6개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):   proc sort data=_docdata (rename=(cluster=_cluster_));
MPRINT(TMC_DOC_SCORE):   by _cluster_;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 데이터셋 WORK._DOCDATA은(는) 500개의 관측값과 46개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.04 초
      

MPRINT(TMC_DOC_SCORE):   data _rmscalc;
MPRINT(TMC_DOC_SCORE):   merge _docdata(in=inhere) EMWS5.TextCluster6_clusters;
MPRINT(TMC_DOC_SCORE):   array _means(44) _mean1-_mean44;
MPRINT(TMC_DOC_SCORE):   array _svds(44) TextCluster6_SVD1 - TextCluster6_SVD44;
MPRINT(TMC_DOC_SCORE):   by _cluster_;
MPRINT(TMC_DOC_SCORE):   error=0;
MPRINT(TMC_DOC_SCORE):   do i = 1 to 44;
MPRINT(TMC_DOC_SCORE):   error +( (_svds{i}-_means{i}) * (_svds{i}-_means{i}));
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   drop i ;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._DOCDATA.에서 읽었습니다.
NOTE: 15개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 WORK._RMSCALC은(는) 500개의 관측값과 94개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.04 초
      

MPRINT(TMC_DOC_SCORE):   proc summary data=_rmscalc nway;
MPRINT(TMC_DOC_SCORE):   class _cluster_;
MPRINT(TMC_DOC_SCORE):   var error;
MPRINT(TMC_DOC_SCORE):   output out=_meanerr mean=meane sum=sume;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 500개의 관측값을 데이터셋 WORK._RMSCALC.에서 읽었습니다.
NOTE: 데이터셋 WORK._MEANERR은(는) 15개의 관측값과 5개의 변수를 가지고 있습니다.
NOTE: 프로시저 SUMMARY 실행(총 프로세스 시간):
      실행 시간           0.06 초
      cpu 시간            0.06 초
      

MPRINT(TMC_DOC_SCORE):   data _rmsse;
MPRINT(TMC_DOC_SCORE):   set _meanerr;
MPRINT(TMC_DOC_SCORE):   if _freq_ gt 1 then do;
MPRINT(TMC_DOC_SCORE):   _rmsstd_=sqrt(sume/((_freq_-1)*(44)));
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   else do;
MPRINT(TMC_DOC_SCORE):   _rmsstd_=0;
MPRINT(TMC_DOC_SCORE):   end;
MPRINT(TMC_DOC_SCORE):   keep _cluster_ _rmsstd_;
MPRINT(TMC_DOC_SCORE):   run;

NOTE: 15개의 관측값을 데이터셋 WORK._MEANERR.에서 읽었습니다.
NOTE: 데이터셋 WORK._RMSSE은(는) 15개의 관측값과 2개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

MPRINT(TMC_DOC_SCORE):   proc sql noprint;
MPRINT(TMC_DOC_SCORE):   create table _clusstat2 as select a.*,b.* from EMWS5.TextCluster6_clusters a left join _rmsse b on a._cluster_=b._cluster_;
WARNING: 변수 _cluster_이(가) 파일 WORK._CLUSSTAT2에 이미 존재합니다.
NOTE: Table WORK._CLUSSTAT2 created, with 15 rows and 49 columns.

MPRINT(TMC_DOC_SCORE):   create table EMWS5.TextCluster6_clusters as select * from _clusstat2;
NOTE: Table EMWS5.TEXTCLUSTER6_CLUSTERS created, with 15 rows and 49 columns.

MPRINT(TMC_DOC_SCORE):   quit;
NOTE: 프로시저 SQL 실행(총 프로세스 시간):
      실행 시간           0.07 초
      cpu 시간            0.07 초
      

MPRINT(TMC_SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):  ;
MPRINT(SCORE):   * path of the diagram ;
MPRINT(SCORE):   data _null_;
MPRINT(SCORE):   call symput("emwspath", strip(pathname("EMWS5")));
MPRINT(SCORE):   run;

NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.00 초
      cpu 시간            0.01 초
      

MPRINT(SCORE):   filename pre "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster6\PRESCORECODE.sas";
MPRINT(SCORE):   data _null_;
MPRINT(SCORE):   file pre;
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmemclus.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmpred.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtxtext.tmc_doc_score.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmsort.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmsvd.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp catalog "sashelp.emtext.tmfast.source";';
MPRINT(SCORE):   put '%include temp;';
MPRINT(SCORE):   put 'filename temp;';
MPRINT(SCORE):   run;

NOTE: 파일 PRE:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster6\PRESCORECODE.sas,
      RECFM=V,LRECL=32767,파일 크기 (바이트)=0,
      마지막 수정일=2018년 11월 28일 21시07분58초,
      생성 시간=2018년 11월 28일 21시07분58초

NOTE: 13개의 레코드를 파일 PRE에 기록했습니다.
      최소 레코드 길이는 14입니다.
      최대 레코드 길이는 62입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.00 초
      

MPRINT(SCORE):   filename tmpre "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextFilter6\PRESCORECODE.sas";
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file pre MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("tmpre",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;

NOTE: 파일 PRE:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster6\PRESCORECODE.sas,
      RECFM=V,LRECL=20000,파일 크기 (바이트)=452,
      마지막 수정일=2018년 11월 28일 21시07분58초,
      생성 시간=2018년 11월 28일 21시07분58초

NOTE: 23개의 레코드를 파일 PRE에 기록했습니다.
      최소 레코드 길이는 1입니다.
      최대 레코드 길이는 81입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(SCORE):  ;
MPRINT(SCORE):   filename tmpre;
NOTE: Fileref TMPRE을(를) 삭제했습니다.
MPRINT(SCORE):   data _codeclusters;
MPRINT(SCORE):   set EMWS5.TextCluster6_clusters (drop=clus_desc);
MPRINT(SCORE):   run;

NOTE: 15개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_CLUSTERS.에서 읽었습니다.
NOTE: 데이터셋 WORK._CODECLUSTERS은(는) 15개의 관측값과 48개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.01 초
      

MPRINT(SCORE):   libname termloc "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5";
NOTE: 라이브러리 참조 TERMLOC은(는) EMWS5과(와) 같은 물리적 라이브러리를 참조합니다.
NOTE: 라이브러리 참조 'TERMLOC'이(가) 다음과 같이 할당되었습니다. 
      엔진:        V9 
      물리적 경로: C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5
MPRINT(SCORE):   * Now save code, if necessary, for search phrase;
MPRINT(SCORE):   filename _tmscore "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster6\EMPUBLISHSCORE.sas";
MPRINT(SCORE):   data _NULL_;
MPRINT(SCORE):   file _tmscore;
MPRINT(SCORE):   string= '%'||"tmc_doc_score(import="||'&em_score_output'||",export=work._newexport,";
MPRINT(SCORE):   put string;
MPRINT(SCORE):   put "      termds=termloc.TextFilter6_filtterms,configds=termloc.TextCluster6_tmconfig,";
MPRINT(SCORE):   put "      clusters=termloc.TextCluster6_clusters, ";
MPRINT(SCORE):   put "      _scrout=work.TextFilter6_out, svd_u=termloc.TextCluster6_svd_u, svd_s=termloc.TextCluster6_svd_s, prefix=TextCluster6);";
MPRINT(SCORE):   put 'data &em_score_output; set work._newexport;';
MPRINT(SCORE):   run;

NOTE: 파일 _TMSCORE:
      파일 이름=C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster6\EMPUBLISHSCORE.sas,
      RECFM=V,LRECL=32767,파일 크기 (바이트)=0,
      마지막 수정일=2018년 11월 28일 21시07분58초,
      생성 시간=2018년 11월 28일 21시07분58초

NOTE: 5개의 레코드를 파일 _TMSCORE에 기록했습니다.
      최소 레코드 길이는 43입니다.
      최대 레코드 길이는 125입니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.01 초
      cpu 시간            0.01 초
      

MPRINT(SCORE):   filename _tmscore;
NOTE: Fileref _TMSCORE을(를) 삭제했습니다.
MPRINT(SCORE):   filename temp;
WARNING: 파일 이름 TEMP이(가) 논리적으로 할당되지 않았습니다.
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End SCORE: TextCluster6;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
28018      *------------------------------------------------------------*;
28019      * End SCORE: TextCluster6;
28020      *------------------------------------------------------------*;

28022      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
28023      * TextCluster6: Computing metadata for TRAIN data;
MPRINT(EM_DIAGRAM):   * TextCluster6: Computing metadata for TRAIN data;
28024      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * &nodeid: Computing Metadata for TRAIN data;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   filename _delta "C:\Users\Administrator\DM_Proj\DataMining2018\Workspaces\EMWS5\TextCluster6\CDELTA_TRAIN.sas";
MPRINT(EMADVISECOLUMNS):   proc display c=sashelp.emmeta.advisecolumns.scl;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    options validvarname=any;
MPRINT(EMADVISECOLUMNS):   proc contents data=EMWS5.TextCluster6_TRAIN out=_tempAdvisor noprint;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):   options validvarname=V7;
MPRINT(EMADVISECOLUMNS):    data _null_;
MPRINT(EMADVISECOLUMNS):   dsid = open('EMWS5.TextCluster6_TRAIN');
MPRINT(EMADVISECOLUMNS):   call symput('_dsidTable', strip(put(dsid, best.)));
MPRINT(EMADVISECOLUMNS):   if dsid then do;
MPRINT(EMADVISECOLUMNS):   call symput('_engineTable', attrc(dsid, 'ENGINE'));
MPRINT(EMADVISECOLUMNS):   dsid = close(dsid);
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    options fmterr;
MPRINT(EMADVISECOLUMNS):   data _metaTestView;
MPRINT(EMADVISECOLUMNS):   set EMWS5.TextCluster6_TRAIN;
MPRINT(EMADVISECOLUMNS):   if _N_=1 then do;
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   stop;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    proc contents data=EMWS5.TextCluster6_TRAIN out=WORK.M0E5LTE0 noprint;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M0E5LTE0;
MPRINT(EMADVISECOLUMNS):   length NAME $ 64 TYPE $ 1 LABEL $ 200 FORMAT $ 36 INFORMAT $36 INDEX $ 1 INDEXTYPE $ 9;
MPRINT(EMADVISECOLUMNS):   label NAME =;
MPRINT(EMADVISECOLUMNS):   set WORK.M0E5LTE0(keep=name type length label format formatl formatd informat informl informd idxusage rename=(type=itype));
MPRINT(EMADVISECOLUMNS):   if itype = 1 then type = 'N';
MPRINT(EMADVISECOLUMNS):   else type = 'C';
MPRINT(EMADVISECOLUMNS):   if formatl > 0 then do;
MPRINT(EMADVISECOLUMNS):   if format ne '' then do;
MPRINT(EMADVISECOLUMNS):   if type='N' then format = strip(format)!!strip(put(formatl, best12.))!!'.'!!strip(put(formatd, best12.));
MPRINT(EMADVISECOLUMNS):   else format = strip(format)!!strip(put(formatl, best12.))!!'.';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else format = strip(put(formatl, best12.))!!'.'!!strip(put(formatd, best12.));
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if format ne '' then format = strip(format)!!'.';
MPRINT(EMADVISECOLUMNS):   if informl > 0 then do;
MPRINT(EMADVISECOLUMNS):   if informat ne ' ' then do;
MPRINT(EMADVISECOLUMNS):   if type='N' then informat = strip(informat)!!strip(put(informl, best12.))!!'.'!!strip(put(informd, best12.));
MPRINT(EMADVISECOLUMNS):   else informat = strip(informat)!!strip(put(informl, best12.))!!'.';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else informat = strip(put(informl, best12.))!!'.'!!strip(put(informd, best12.));
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if informat ne '' then informat = strip(informat)!!'.';
MPRINT(EMADVISECOLUMNS):   if idxusage = 'NONE' then index ="N";
MPRINT(EMADVISECOLUMNS):   else index = "Y";
MPRINT(EMADVISECOLUMNS):   indextype = idxusage;
MPRINT(EMADVISECOLUMNS):   drop idxusage itype formatl formatd informl informd;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M0E5LTE0;
MPRINT(EMADVISECOLUMNS):   length UNAME $64;
MPRINT(EMADVISECOLUMNS):   set WORK.M0E5LTE0;
MPRINT(EMADVISECOLUMNS):   UNAME = upcase(NAME);
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    proc sort data=WORK.M1JPAIWZ NOTHREADS;
MPRINT(EMADVISECOLUMNS):   by UNAME;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M1JPAIWZ;
MPRINT(EMADVISECOLUMNS):   drop UNAME;
MPRINT(EMADVISECOLUMNS):   set WORK.M1JPAIWZ;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M3OTLHHZ(keep=NAME ATTR);
MPRINT(EMADVISECOLUMNS):   length ATTR $ 20;
MPRINT(EMADVISECOLUMNS):   set WORK.M1JPAIWZ;
MPRINT(EMADVISECOLUMNS):   if level ne "INTERVAL" then do;
MPRINT(EMADVISECOLUMNS):   if order = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'ORDER';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if format ne ' ' and formattype = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'FORMATTYPE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'ROLE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if level = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'LEVEL';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if type = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'TYPE';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if index = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'INDEX';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if report = ' ' then do;
MPRINT(EMADVISECOLUMNS):   attr = 'REPORT';
MPRINT(EMADVISECOLUMNS):   output;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):   proc sort NOTHREADS;
MPRINT(EMADVISECOLUMNS):   by attr;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M1JPAIWZ;
MPRINT(EMADVISECOLUMNS):   length NAME $64 ROLE $ 32 LEVEL $ 10 ORDER $ 8 CREATOR $32 FORMATTYPE $ 10 FAMILY $ 10 LOWERLIMIT 8 UPPERLIMIT 8 REPORT $1 DISTRIBUTION $ 20 COMMENT $64;
MPRINT(EMADVISECOLUMNS):   length levelAssigned 8 roleAssigned 8 PRICE 8;
MPRINT(EMADVISECOLUMNS):   set WORK.M1JPAIWZ;
MPRINT(EMADVISECOLUMNS):   if formattype = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if format ne ' ' then do;
MPRINT(EMADVISECOLUMNS):   if type = 'N' then do;
MPRINT(EMADVISECOLUMNS):   pos = indexc(format,'.1234567890');
MPRINT(EMADVISECOLUMNS):   if pos > 1 then tempfmt = substr(format,1, pos-1);
MPRINT(EMADVISECOLUMNS):   else tempfmt = ' ';
MPRINT(EMADVISECOLUMNS):   flen = length(tempfmt);
MPRINT(EMADVISECOLUMNS):   select;
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("DATE" "DAY" "DDMMYY" "DOWNAME" "JULDAY" "JULIAN" "MMDDYY" "MMDDYYD" "MMDDYYC" "MMDDYYN" "MMDDYYP" "MMDDYYS" "MONNAME" "MONTH" "MONYY" "NENGO" "QTR" "QTRR" "WEEKDATE" "WEEKDATX" "WEEKDAY" "WORDDATE" "WORDDATX" 
"YEAR" "YYMMDD" "YYMON" "YYMMDDC" "YYMMDDD" "YYMMDDN" "YYMMDDP" "YYMMDDS" "EURDFDE" "NJDATE" "NLDATE" "EURDFDD" "EURDFDWN" "EURDFMN" "EURDFMY" "EURDFWK" "EURDFWKX" "EURDFWDX" "EURDFDN" "EURDFDE" )) formattype = 'DATE';
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("DATETIME" "EURDFDT" "TOD" )) formattype = "DATETIME";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("HHMM" "HOUR" "MMSS" "TIME" "TIMEAMPM" )) formattype = "TIME";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("COMMA" "COMMAX" "DOLLAR" "DOLLARX" "E" "FRACT" "NEGPAREN" "PERCENT")) formattype="QUANTITY";
MPRINT(EMADVISECOLUMNS):   when(tempfmt in ("BINARY" "HEX" "IB" "OCTAL" "PD" "PIB" "PK" "RB" "SSN" "Z" "ZD")) formattype = "CODING";
MPRINT(EMADVISECOLUMNS):   otherwise do;
MPRINT(EMADVISECOLUMNS):   formattype = "USER";
MPRINT(EMADVISECOLUMNS):   if compress(tempfmt, '0123456789.', '') = '' then formattype='NUM';
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 6)='NLDATE' then formattype = "DATE";
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 6)='NLDATM' then formattype = "DATETIME";
MPRINT(EMADVISECOLUMNS):   else if substr(tempfmt, 1, 4)='NLTIM' then formattype = "TIME";
MPRINT(EMADVISECOLUMNS):   else if flen >= 4 then do;
MPRINT(EMADVISECOLUMNS):   str = substr(tempfmt,1,4);
MPRINT(EMADVISECOLUMNS):   if str in ("MMYY" "YYMM" "YYQR") then formattype ="DATE";
MPRINT(EMADVISECOLUMNS):   else if str = "S370" then formattype = "CODING";
MPRINT(EMADVISECOLUMNS):   else if str = "BEST" then formattype = "NUM";
MPRINT(EMADVISECOLUMNS):   drop str;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if flen >=3 and substr(tempfmt,1,3) = "YYQ" then formatType = "DATE";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   drop flen tempfmt pos;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   formatType = "CATEGORY";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if formatType = "NUM" then do;
MPRINT(EMADVISECOLUMNS):   if index = "Y" then formatType = "DISCRETE";
MPRINT(EMADVISECOLUMNS):   else formatType = "QUANTITY";
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if level = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if formatType in ("CATEGORY", "CODING", "ID") or type = "C" then level = "NOMINAL";
MPRINT(EMADVISECOLUMNS):   else level = "INTERVAL";
MPRINT(EMADVISECOLUMNS):   levelAssigned = 1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else level = upcase(level);
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   length name_prefix $8 _uname $64;
MPRINT(EMADVISECOLUMNS):   drop name_prefix _uname _freqflag;
MPRINT(EMADVISECOLUMNS):   retain _freqflag;
MPRINT(EMADVISECOLUMNS):   if LENGTH> 80 then ROLE = 'TEXT';
MPRINT(EMADVISECOLUMNS):   _uname = upcase(NAME);
MPRINT(EMADVISECOLUMNS):   select(_uname);
MPRINT(EMADVISECOLUMNS):   when('_PARTIND_') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'ID';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('_WARN_') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_SEGMENT') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('_NODE_') do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   when('EM_CLASSTARGET') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_VALUETARGET') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_PREDICTION') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_PROBABILITY') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_EVENTPROBABILITY') ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   when('EM_CLASSIFICATION') ROLE = 'CLASSIFICATION';
MPRINT(EMADVISECOLUMNS):   when('EM_DECISION') ROLE = 'DECISION';
MPRINT(EMADVISECOLUMNS):   when('EM_PROFIT') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_LOSS') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('EM_ROI') ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   when('URI') ROLE = 'URL';
MPRINT(EMADVISECOLUMNS):   when('FILTERED') ROLE = 'TEXTLOC';
MPRINT(EMADVISECOLUMNS):   otherwise do;
MPRINT(EMADVISECOLUMNS):   if upcase(NAME) =: 'ZIP' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'REJECTED';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   COMMENT = 'Rejected by: Exceed the maximum class level of %s';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if upcase(NAME) in('FREQ', 'FREQUENCY') then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'FREQ';
MPRINT(EMADVISECOLUMNS):   if TYPE = 'C' then ROLE = 'INPUT';
MPRINT(EMADVISECOLUMNS):   else if _freqflag =1 then ROLE='REJECTED';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   name_prefix = scan(_uname, 1, '_');
MPRINT(EMADVISECOLUMNS):   if scan(_uname, 2, '_') = '' then name_prefix='';
MPRINT(EMADVISECOLUMNS):   if name_prefix in('F', 'I', 'U') then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'CLASSIFICATION';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('Q') then ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('P', 'V') then ROLE = 'PREDICT';
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('R', 'RS', 'RT', 'RD', 'RDS', 'RDT', 'RA', 'RAS', 'RAT') then ROLE = 'RESIDUAL';
MPRINT(EMADVISECOLUMNS):   else if name_prefix ='D' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'DECISION';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix ='B' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'SEGMENT';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else if name_prefix in('EP', 'BP', 'CP', 'EL', 'CL', 'BL', 'W', 'ROI', 'IC') then ROLE = 'ASSESS';
MPRINT(EMADVISECOLUMNS):   else do;
MPRINT(EMADVISECOLUMNS):   array _ROLE_ (19) $32 _TEMPORARY_ ('ASSESS','CLASSIFICATION','CENSOR', 'COST', 'CROSSID', 'DECISION', 'ID','INPUT', 'LABEL', 'MISSING','PREDICT','REFERRER','REJECTED', 'RESIDUAL','SEGMENT', 'SEQUENCE','TARGET', 'TEXT', 'TIMEID');
MPRINT(EMADVISECOLUMNS):   drop _found_ i;
MPRINT(EMADVISECOLUMNS):   _found_=0;
MPRINT(EMADVISECOLUMNS):   do i=1 to 19 until(_found_=1);
MPRINT(EMADVISECOLUMNS):   if index(_uname, trim(_ROLE_{i}))=1 then do;
MPRINT(EMADVISECOLUMNS):   ROLE=_ROLE_{i};
MPRINT(EMADVISECOLUMNS):   if ROLE = 'ID' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'SEGMENT' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'TIMEID' and TYPE='N' then LEVEL = 'INTERVAL';
MPRINT(EMADVISECOLUMNS):   _found_=1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if length(_uname)>2 then do;
MPRINT(EMADVISECOLUMNS):   if substr(reverse(trim(_uname)), 1, 3) = 'DI_' then do;
MPRINT(EMADVISECOLUMNS):   ROLE = 'ID';
MPRINT(EMADVISECOLUMNS):   LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if ROLE='FREQ' then _freqflag=1;
MPRINT(EMADVISECOLUMNS):   else if ROLE = 'CLASSIFICATION' then LEVEL = 'NOMINAL';
MPRINT(EMADVISECOLUMNS):   if symexist('RATEMKG_ROLE') then do;
MPRINT(EMADVISECOLUMNS):   if upcase(symget('RATEMKG_ROLE')) in('Y', 'YES') then do;
MPRINT(EMADVISECOLUMNS):   if _uname =: 'POLICY' then ROLE = 'POLICYID';
MPRINT(EMADVISECOLUMNS):   else if _uname in ('PARTITION', '_PARTIND_') then ROLE = 'PARTITION';
MPRINT(EMADVISECOLUMNS):   else if type = 'N' then do;
MPRINT(EMADVISECOLUMNS):   if _uname = 'EXPOSURE' then ROLE = 'EXPOSURE';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'YEAR' then ROLE = 'YEAR';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'WEIGHT' then ROLE = 'WEIGHT';
MPRINT(EMADVISECOLUMNS):   else if _uname = 'OFFSET' then ROLE = 'OFFSET';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   if role = ' ' then do;
MPRINT(EMADVISECOLUMNS):   if formattype in('DATE', 'DATETIME', 'TIME') then role = 'TIMEID';
MPRINT(EMADVISECOLUMNS):   else role = 'INPUT';
MPRINT(EMADVISECOLUMNS):   roleAssigned = 1;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   else role = upcase(role);
MPRINT(EMADVISECOLUMNS):   if REPORT = '' then REPORT = 'N';
MPRINT(EMADVISECOLUMNS):   if symexist('dmwb_product') then do;
MPRINT(EMADVISECOLUMNS):   if upcase(symget('dmwb_product')) = 'FACTORYMINER_DATASOURCE' then do;
MPRINT(EMADVISECOLUMNS):   if ROLE ^in('INPUT', 'TARGET', 'REJECTED', 'SEGMENT', 'FREQ', 'ID', 'KEY') then ROLE='REJECTED';
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   end;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):    data WORK.M1JPAIWZ;
MPRINT(EMADVISECOLUMNS):   set WORK.M1JPAIWZ;
MPRINT(EMADVISECOLUMNS):   label NAME = "변수 이름" TYPE = "유형" ROLE = "역할" LEVEL= "측도 레벨" ORDER= "순서" CREATOR= "생성자" FORMATTYPE= "출력형식 유형" FAMILY= "군" DISTRIBUTION= "분포" PRICE= "가격" LOWERLIMIT= "하한" UPPERLIMIT= "상한" REPORT= 
"리 포트" COMMENT= "주석" INDEX= "인덱스" INDEXTYPE= "인덱스 유형" LABEL= "레이블" LENGTH= "길이";
MPRINT(EMADVISECOLUMNS):   drop levelAssigned roleAssigned;
MPRINT(EMADVISECOLUMNS):   run;
MPRINT(EMADVISECOLUMNS):   
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   proc sort data=WORK.COLUMNMETA;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * &nodeid: Merge incoming metadata;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   proc contents data=EMWS5.TextFilter6_TRAIN noprint out=_temp2(keep=NAME);
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc sort data=_temp2;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   proc sort data=EMWS5.TextFilter6_CMeta_TRAIN out=_temp;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data EMWS5.TextCluster6_CMeta_TRAIN;
MPRINT(EM_DIAGRAM):   merge WORK.COLUMNMETA(in=_a) _temp2(in=_b) _temp(drop=FORMAT INFORMAT LENGTH INDEX INDEXTYPE in=_c) end=_eof_;
MPRINT(EM_DIAGRAM):   by NAME;
MPRINT(EM_DIAGRAM):   if (^_a and _b) or (^_c and _a and _b) then delete;
MPRINT(EM_DIAGRAM):   if ^_b then CREATOR = "TextCluster6";
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * TextCluster6: Apply Delta Code;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   if upcase(NAME) = "TEXTCLUSTER6_CLUSTER_" then do;
MPRINT(EM_DIAGRAM):   ROLE = "SEGMENT";
MPRINT(EM_DIAGRAM):   LEVEL = "NOMINAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB1" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB10" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB11" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB12" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB13" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB14" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB15" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB2" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB3" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB4" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB5" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB6" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB7" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB8" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_PROB9" then do;
MPRINT(EM_DIAGRAM):   ROLE = "REJECTED";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD1" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD10" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD11" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD12" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD13" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD14" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD15" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD16" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD17" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD18" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD19" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD2" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD20" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD21" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD22" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD23" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD24" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD25" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD26" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD27" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD28" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD29" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD3" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD30" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD31" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD32" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD33" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD34" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD35" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD36" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD37" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD38" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD39" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD4" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD40" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD41" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD42" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD43" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD44" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD5" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD6" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD7" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD8" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   else if upcase(NAME) = "TEXTCLUSTER6_SVD9" then do;
MPRINT(EM_DIAGRAM):   ROLE = "INPUT";
MPRINT(EM_DIAGRAM):   LEVEL = "INTERVAL";
MPRINT(EM_DIAGRAM):   end;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _delta;
28654      proc sort data = EMWS5.TextFilter6_EMINFO OUT=WORK.SORTEDEMINFO NOTHREADS;
MPRINT(EM_DIAGRAM):    proc sort data = EMWS5.TextFilter6_EMINFO OUT=WORK.SORTEDEMINFO NOTHREADS;
28655      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
28656      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: 6개의 관측값을 데이터셋 EMWS5.TEXTFILTER6_EMINFO.에서 읽었습니다.
NOTE: 데이터셋 WORK.SORTEDEMINFO은(는) 6개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

28657      proc sort data = EMWS5.TextCluster6_EMINFO OUT=WORK.TEMP_INFO NOTHREADS;
MPRINT(EM_DIAGRAM):   proc sort data = EMWS5.TextCluster6_EMINFO OUT=WORK.TEMP_INFO NOTHREADS;
28658      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
28659      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: 4개의 관측값을 데이터셋 EMWS5.TEXTCLUSTER6_EMINFO.에서 읽었습니다.
NOTE: 데이터셋 WORK.TEMP_INFO은(는) 4개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: 프로시저 SORT 실행(총 프로세스 시간):
      실행 시간           0.02 초
      cpu 시간            0.03 초
      

28660      data EMWS5.TextCluster6_EMINFO;
MPRINT(EM_DIAGRAM):   data EMWS5.TextCluster6_EMINFO;
28661      merge WORK.SORTEDEMINFO WORK.TEMP_INFO;
MPRINT(EM_DIAGRAM):   merge WORK.SORTEDEMINFO WORK.TEMP_INFO;
28662      by TARGET KEY;
MPRINT(EM_DIAGRAM):   by TARGET KEY;
28663      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: 6개의 관측값을 데이터셋 WORK.SORTEDEMINFO.에서 읽었습니다.
NOTE: 4개의 관측값을 데이터셋 WORK.TEMP_INFO.에서 읽었습니다.
NOTE: 데이터셋 EMWS5.TEXTCLUSTER6_EMINFO은(는) 7개의 관측값과 3개의 변수를 가지고 있습니다.
NOTE: DATA 문장 실행(총 프로세스 시간):
      실행 시간           0.03 초
      cpu 시간            0.03 초
      

28664      proc datasets lib=work nolist;
MPRINT(EM_DIAGRAM):   proc datasets lib=work nolist;
28665      delete TEMP_INFO SORTEDEMINFO;
MPRINT(EM_DIAGRAM):   delete TEMP_INFO SORTEDEMINFO;
28666      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: WORK.TEMP_INFO(memtype=DATA)을(를) 삭제하는 중입니다.
NOTE: WORK.SORTEDEMINFO(memtype=DATA)을(를) 삭제하는 중입니다.
28667      quit;
MPRINT(EM_DIAGRAM):   quit;

NOTE: 프로시저 DATASETS 실행(총 프로세스 시간):
      실행 시간           0.05 초
      cpu 시간            0.06 초
      

MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
